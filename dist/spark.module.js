import * as THREE from "three";
import { Mesh as Mesh$1, OrthographicCamera as OrthographicCamera$1, BufferGeometry as BufferGeometry$1, Float32BufferAttribute as Float32BufferAttribute$1, Loader, FileLoader, Quaternion as Quaternion$1, Vector3 as Vector3$1, Color as Color$1, Matrix4 as Matrix4$1 } from "three";
const _camera$1 = new OrthographicCamera$1(-1, 1, 1, -1, 0, 1);
class FullscreenTriangleGeometry extends BufferGeometry$1 {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute$1([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute$1([0, 2, 0, 0, 2, 0], 2));
  }
}
const _geometry$1 = new FullscreenTriangleGeometry();
class FullScreenQuad {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(material) {
    this._mesh = new Mesh$1(_geometry$1, material);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(renderer) {
    renderer.render(this._mesh, _camera$1);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
  var x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var hMap = (function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
});
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
  flt[i] = 8;
for (var i = 144; i < 256; ++i)
  flt[i] = 9;
for (var i = 256; i < 280; ++i)
  flt[i] = 7;
for (var i = 280; i < 288; ++i)
  flt[i] = 8;
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
  fdt[i] = 5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$4 = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$4(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max$4(lt);
        dbt = max$4(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add2;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var Inflate = /* @__PURE__ */ (function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
})();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gunzip = /* @__PURE__ */ (function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
})();
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var slzh = function(d, b) {
  return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
var zh = function(d, b, z) {
  var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
  var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
function unzipSync(data, opts) {
  var files = {};
  var e = data.length - 22;
  for (; b4(data, e) != 101010256; --e) {
    if (!e || data.length - e > 65558)
      err(13);
  }
  var c = b2(data, e + 8);
  if (!c)
    return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295 || c == 65535;
  if (z) {
    var ze = b4(data, e - 12);
    z = b4(data, ze) == 101075792;
    if (z) {
      c = b4(data, ze + 32);
      o = b4(data, ze + 48);
    }
  }
  var fltr = opts && opts.filter;
  for (var i = 0; i < c; ++i) {
    var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
    o = no;
    if (!fltr || fltr({
      name: fn,
      size: sc,
      originalSize: su,
      compression: c_2
    })) {
      if (!c_2)
        files[fn] = slc(data, b, b + sc);
      else if (c_2 == 8)
        files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
      else
        err(14, "unknown compression type " + c_2);
    }
  }
  return files;
}
let wasm;
const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
let cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max) {
  const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);
  return ret;
}
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance2 = await WebAssembly.instantiate(module, imports);
    if (instance2 instanceof WebAssembly.Instance) {
      return { instance: instance2, module };
    } else {
      return instance2;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = arg0.buffer;
    return ret;
  };
  imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {
    const ret = new Uint16Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {
    const ret = new Uint32Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {
    const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {
    const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {
    const ret = new Float32Array(arg0 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_0;
    const offset = table.grow(4);
    table.set(0, void 0);
    table.set(offset + 0, void 0);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return ret;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance2, module) {
  wasm = instance2.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAN/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gAW8Bf2ADb29/AGAAAGAEf39/fwF/YAABf2AGf39/f39/AGAEf39/fwBgA39vbwF/YAF/AW9gAAFvYAF9AX1gDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAKA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAGA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEgN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAGA3diZxFfX3diaW5kZ2VuX21lbW9yeQATA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADANeXQQAAQcFAwINDgAUAQMAAQEDAAABCA8IDwMDAQMBBQMDAgIAAQMFAAEHABUMDAUWCAcXGRsFEAIREQUdAQEBBAQEBQEABAIADgANAQAAAwECAgIAAQEBAAAAAQEEBAQJAnABLi5vAIABBQMBABEGCQF/AUGAgMAACwdiBgZtZW1vcnkCAA5yYXljYXN0X3NwbGF0cwA7DXNvcnQzMl9zcGxhdHMASAtzb3J0X3NwbGF0cwBJE19fd2JpbmRnZW5fZXhwb3J0XzABARBfX3diaW5kZ2VuX3N0YXJ0ABAJMwEAQQELLU9RUFkzQShAQ0RAQkBGQT9HUmo6SjEiYVw0W2VFNyQra01MSjIjYmdXVF1oaQwBAwqQ2AFdySUCCX8BfiMAQRBrIggkAAJAAkACQAJAAkAgAEH1AU8EQCAAQcz/e0sEQEEAIQAMBgsgAEELaiICQXhxIQVB2JnAACgCACIJRQ0EQR8hBkEAIAVrIQMgAEH0//8HTQRAIAVBJiACQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBgsgBkECdEG8lsAAaigCACICRQRAQQAhAAwCCyAFQRkgBkEBdmtBACAGQR9HG3QhBEEAIQADQAJAIAIoAgRBeHEiByAFSQ0AIAcgBWsiByADTw0AIAIhASAHIgMNAEEAIQMgASEADAQLIAIoAhQiByAAIAcgAiAEQR12QQRxaigCECICRxsgACAHGyEAIARBAXQhBCACDQALDAELAkACQAJAAkACQEHUmcAAKAIAIgRBECAAQQtqQfgDcSAAQQtJGyIFQQN2IgB2IgFBA3EEQCABQX9zQQFxIABqIgdBA3QiAUHMl8AAaiIAIAFB1JfAAGooAgAiAigCCCIDRg0BIAMgADYCDCAAIAM2AggMAgsgBUHcmcAAKAIATQ0IIAENAkHYmcAAKAIAIgBFDQggAGhBAnRBvJbAAGooAgAiAigCBEF4cSAFayEDIAIhAQNAAkAgASgCECIADQAgASgCFCIADQAgAigCGCEGAkACQCACIAIoAgwiAEYEQCACQRRBECACKAIUIgAbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyACQRRqIAJBEGogABshBANAIAQhByABIgBBFGogAEEQaiAAKAIUIgEbIQQgAEEUQRAgARtqKAIAIgENAAsgB0EANgIACyAGRQ0GAkAgAigCHEECdEG8lsAAaiIBKAIAIAJHBEAgAiAGKAIQRwRAIAYgADYCFCAADQIMCQsgBiAANgIQIAANAQwICyABIAA2AgAgAEUNBgsgACAGNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNBiAAIAE2AhQgASAANgIYDAYLIAAoAgRBeHEgBWsiASADIAEgA0kiARshAyAAIAIgARshAiAAIQEMAAsAC0HUmcAAIARBfiAHd3E2AgALIAJBCGohACACIAFBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMBwsCQEECIAB0IgJBACACa3IgASAAdHFoIgdBA3QiAUHMl8AAaiICIAFB1JfAAGooAgAiACgCCCIDRwRAIAMgAjYCDCACIAM2AggMAQtB1JnAACAEQX4gB3dxNgIACyAAIAVBA3I2AgQgACAFaiIGIAEgBWsiB0EBcjYCBCAAIAFqIAc2AgBB3JnAACgCACICBEBB5JnAACgCACEBAkBB1JnAACgCACIEQQEgAkEDdnQiA3FFBEBB1JnAACADIARyNgIAIAJBeHFBzJfAAGoiAyEEDAELIAJBeHEiAkHMl8AAaiEEIAJB1JfAAGooAgAhAwsgBCABNgIIIAMgATYCDCABIAQ2AgwgASADNgIICyAAQQhqIQBB5JnAACAGNgIAQdyZwAAgBzYCAAwGC0HYmcAAQdiZwAAoAgBBfiACKAIcd3E2AgALAkACQCADQRBPBEAgAiAFQQNyNgIEIAIgBWoiByADQQFyNgIEIAMgB2ogAzYCAEHcmcAAKAIAIgFFDQFB5JnAACgCACEAAkBB1JnAACgCACIEQQEgAUEDdnQiBnFFBEBB1JnAACAEIAZyNgIAIAFBeHFBzJfAAGoiBCEBDAELIAFBeHEiBEHMl8AAaiEBIARB1JfAAGooAgAhBAsgASAANgIIIAQgADYCDCAAIAE2AgwgACAENgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELQeSZwAAgBzYCAEHcmcAAIAM2AgALIAJBCGoiAEUNAwwECyAAIAFyRQRAQQAhAUECIAZ0IgBBACAAa3IgCXEiAEUNAyAAaEECdEG8lsAAaigCACEACyAARQ0BCwNAIAMgACgCBEF4cSICIAVrIgQgAyADIARLIgQbIAIgBUkiAhshAyABIAAgASAEGyACGyEBIAAoAhAiAgR/IAIFIAAoAhQLIgANAAsLIAFFDQAgBUHcmcAAKAIAIgBNIAMgACAFa09xDQAgASgCGCEGAkACQCABIAEoAgwiAEYEQCABQRRBECABKAIUIgAbaigCACICDQFBACEADAILIAEoAggiAiAANgIMIAAgAjYCCAwBCyABQRRqIAFBEGogABshBANAIAQhByACIgBBFGogAEEQaiAAKAIUIgIbIQQgAEEUQRAgAhtqKAIAIgINAAsgB0EANgIACwJAIAZFDQACQAJAIAEoAhxBAnRBvJbAAGoiAigCACABRwRAIAEgBigCEEcEQCAGIAA2AhQgAA0CDAQLIAYgADYCECAADQEMAwsgAiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQEgACACNgIUIAIgADYCGAwBC0HYmcAAQdiZwAAoAgBBfiABKAIcd3E2AgALAkAgA0EQTwRAIAEgBUEDcjYCBCABIAVqIgAgA0EBcjYCBCAAIANqIAM2AgAgA0GAAk8EQCAAIAMQIAwCCwJAQdSZwAAoAgAiAkEBIANBA3Z0IgRxRQRAQdSZwAAgAiAEcjYCACADQfgBcUHMl8AAaiIDIQIMAQsgA0H4AXEiBEHMl8AAaiECIARB1JfAAGooAgAhAwsgAiAANgIIIAMgADYCDCAAIAI2AgwgACADNgIIDAELIAEgAyAFaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECyABQQhqIgANAQsCQAJAAkACQAJAIAVB3JnAACgCACIBSwRAIAVB4JnAACgCACIATwRAIAhBBGohAAJ/IAVBr4AEakGAgHxxIgFBEHYgAUH//wNxQQBHaiIBQAAiBEF/RgRAQQAhAUEADAELIAFBEHQiAkEQayACIARBEHQiAUEAIAJrRhsLIQIgAEEANgIIIAAgAjYCBCAAIAE2AgAgCCgCBCIBRQRAQQAhAAwICyAIKAIMIQdB7JnAACAIKAIIIgRB7JnAACgCAGoiADYCAEHwmcAAIABB8JnAACgCACICIAAgAksbNgIAAkACQEHomcAAKAIAIgIEQEG8l8AAIQADQCABIAAoAgAiAyAAKAIEIgZqRg0CIAAoAggiAA0ACwwCC0H4mcAAKAIAIgBBACAAIAFNG0UEQEH4mcAAIAE2AgALQfyZwABB/x82AgBByJfAACAHNgIAQcCXwAAgBDYCAEG8l8AAIAE2AgBB2JfAAEHMl8AANgIAQeCXwABB1JfAADYCAEHUl8AAQcyXwAA2AgBB6JfAAEHcl8AANgIAQdyXwABB1JfAADYCAEHwl8AAQeSXwAA2AgBB5JfAAEHcl8AANgIAQfiXwABB7JfAADYCAEHsl8AAQeSXwAA2AgBBgJjAAEH0l8AANgIAQfSXwABB7JfAADYCAEGImMAAQfyXwAA2AgBB/JfAAEH0l8AANgIAQZCYwABBhJjAADYCAEGEmMAAQfyXwAA2AgBBmJjAAEGMmMAANgIAQYyYwABBhJjAADYCAEGUmMAAQYyYwAA2AgBBoJjAAEGUmMAANgIAQZyYwABBlJjAADYCAEGomMAAQZyYwAA2AgBBpJjAAEGcmMAANgIAQbCYwABBpJjAADYCAEGsmMAAQaSYwAA2AgBBuJjAAEGsmMAANgIAQbSYwABBrJjAADYCAEHAmMAAQbSYwAA2AgBBvJjAAEG0mMAANgIAQciYwABBvJjAADYCAEHEmMAAQbyYwAA2AgBB0JjAAEHEmMAANgIAQcyYwABBxJjAADYCAEHYmMAAQcyYwAA2AgBB4JjAAEHUmMAANgIAQdSYwABBzJjAADYCAEHomMAAQdyYwAA2AgBB3JjAAEHUmMAANgIAQfCYwABB5JjAADYCAEHkmMAAQdyYwAA2AgBB+JjAAEHsmMAANgIAQeyYwABB5JjAADYCAEGAmcAAQfSYwAA2AgBB9JjAAEHsmMAANgIAQYiZwABB/JjAADYCAEH8mMAAQfSYwAA2AgBBkJnAAEGEmcAANgIAQYSZwABB/JjAADYCAEGYmcAAQYyZwAA2AgBBjJnAAEGEmcAANgIAQaCZwABBlJnAADYCAEGUmcAAQYyZwAA2AgBBqJnAAEGcmcAANgIAQZyZwABBlJnAADYCAEGwmcAAQaSZwAA2AgBBpJnAAEGcmcAANgIAQbiZwABBrJnAADYCAEGsmcAAQaSZwAA2AgBBwJnAAEG0mcAANgIAQbSZwABBrJnAADYCAEHImcAAQbyZwAA2AgBBvJnAAEG0mcAANgIAQdCZwABBxJnAADYCAEHEmcAAQbyZwAA2AgBB6JnAACABQQ9qQXhxIgBBCGsiAjYCAEHMmcAAQcSZwAA2AgBB4JnAACAEQShrIgQgASAAa2pBCGoiADYCACACIABBAXI2AgQgASAEakEoNgIEQfSZwABBgICAATYCAAwICyACIANJIAEgAk1yDQAgACgCDCIDQQFxDQAgA0EBdiAHRg0DC0H4mcAAQfiZwAAoAgAiACABIAAgAUkbNgIAIAEgBGohA0G8l8AAIQACQAJAA0AgAyAAKAIAIgZHBEAgACgCCCIADQEMAgsLIAAoAgwiA0EBcQ0AIANBAXYgB0YNAQtBvJfAACEAA0ACQCACIAAoAgAiA08EQCACIAMgACgCBGoiBkkNAQsgACgCCCEADAELC0HomcAAIAFBD2pBeHEiAEEIayIDNgIAQeCZwAAgBEEoayIJIAEgAGtqQQhqIgA2AgAgAyAAQQFyNgIEIAEgCWpBKDYCBEH0mcAAQYCAgAE2AgAgAiAGQSBrQXhxQQhrIgAgACACQRBqSRsiA0EbNgIEQbyXwAApAgAhCiADQRBqQcSXwAApAgA3AgAgA0EIaiIAIAo3AgBByJfAACAHNgIAQcCXwAAgBDYCAEG8l8AAIAE2AgBBxJfAACAANgIAIANBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgAiADRg0HIAMgAygCBEF+cTYCBCACIAMgAmsiAEEBcjYCBCADIAA2AgAgAEGAAk8EQCACIAAQIAwICwJAQdSZwAAoAgAiAUEBIABBA3Z0IgRxRQRAQdSZwAAgASAEcjYCACAAQfgBcUHMl8AAaiIAIQEMAQsgAEH4AXEiAEHMl8AAaiEBIABB1JfAAGooAgAhAAsgASACNgIIIAAgAjYCDCACIAE2AgwgAiAANgIIDAcLIAAgATYCACAAIAAoAgQgBGo2AgQgAUEPakF4cUEIayIEIAVBA3I2AgQgBkEPakF4cUEIayIDIAQgBWoiAGshBSADQeiZwAAoAgBGDQMgA0HkmcAAKAIARg0EIAMoAgQiAkEDcUEBRgRAIAMgAkF4cSIBEB8gASAFaiEFIAEgA2oiAygCBCECCyADIAJBfnE2AgQgACAFQQFyNgIEIAAgBWogBTYCACAFQYACTwRAIAAgBRAgDAYLAkBB1JnAACgCACIBQQEgBUEDdnQiAnFFBEBB1JnAACABIAJyNgIAIAVB+AFxQcyXwABqIgUhAwwBCyAFQfgBcSIBQcyXwABqIQMgAUHUl8AAaigCACEFCyADIAA2AgggBSAANgIMIAAgAzYCDCAAIAU2AggMBQtB4JnAACAAIAVrIgE2AgBB6JnAAEHomcAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwGC0HkmcAAKAIAIQACQCABIAVrIgJBD00EQEHkmcAAQQA2AgBB3JnAAEEANgIAIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBC0HcmcAAIAI2AgBB5JnAACAAIAVqIgQ2AgAgBCACQQFyNgIEIAAgAWogAjYCACAAIAVBA3I2AgQLIABBCGohAAwFCyAAIAQgBmo2AgRB6JnAAEHomcAAKAIAIgBBD2pBeHEiAUEIayICNgIAQeCZwABB4JnAACgCACAEaiIEIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgBGpBKDYCBEH0mcAAQYCAgAE2AgAMAwtB6JnAACAANgIAQeCZwABB4JnAACgCACAFaiIBNgIAIAAgAUEBcjYCBAwBC0HkmcAAIAA2AgBB3JnAAEHcmcAAKAIAIAVqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsgBEEIaiEADAELQQAhAEHgmcAAKAIAIgEgBU0NAEHgmcAAIAEgBWsiATYCAEHomcAAQeiZwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEACyAIQRBqJAAgAAvGBgEHfwJAAkAgASAAQQNqQXxxIgQgAGsiB0kNACABIAdrIgZBBEkNAEEAIQEgACAERwRAIAAgBGsiBEF8TQRAA0AgASAAIANqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEBIANBBGoiAw0ACwsgACADaiECA0AgASACLAAAQb9/SmohASACQQFqIQIgBEEBaiIEDQALCyAAIAdqIQQCQCAGQQNxIgBFDQAgBCAGQfz///8HcWoiAywAAEG/f0ohBSAAQQFGDQAgBSADLAABQb9/SmohBSAAQQJGDQAgBSADLAACQb9/SmohBQsgBkECdiEGIAEgBWohAwNAIAQhACAGRQ0CQcABIAYgBkHAAU8bIgVBA3EhBwJAIAVBAnQiBEHwB3EiAUUEQEEAIQIMAQsgACABaiEIQQAhAiAAIQEDQCACIAEoAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAUEEaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiABQQhqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIAFBDGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWohAiABQRBqIgEgCEcNAAsLIAYgBWshBiAAIARqIQQgAkEIdkH/gfwHcSACQf+B/AdxakGBgARsQRB2IANqIQMgB0UNAAsCfyAAIAVB/AFxQQJ0aiIAKAIAIgFBf3NBB3YgAUEGdnJBgYKECHEiASAHQQFGDQAaIAEgACgCBCIBQX9zQQd2IAFBBnZyQYGChAhxaiIBIAdBAkYNABogACgCCCIAQX9zQQd2IABBBnZyQYGChAhxIAFqCyIBQQh2Qf+BHHEgAUH/gfwHcWpBgYAEbEEQdiADaiEDDAELIAFFBEBBAA8LIAFBA3EhBAJAIAFBBEkEQAwBCyABQXxxIQUDQCADIAAgAmoiASwAAEG/f0pqIAFBAWosAABBv39KaiABQQJqLAAAQb9/SmogAUEDaiwAAEG/f0pqIQMgBSACQQRqIgJHDQALCyAERQ0AIAAgAmohAQNAIAMgASwAAEG/f0pqIQMgAUEBaiEBIARBAWsiBA0ACwsgAwuKBgEGfyAAKAIIIgMgAUkEQCABIAMiAmsiBCAAKAIAIAJrSwRAIAAgAiAEQQRBBBAnIAAoAgghAgsgACgCBCIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgIICyAAKAIUIgMgAUkEQCABIAMiAmsiBCAAKAIMIAJrSwRAIABBDGogAiAEQQRBBBAnIAAoAhQhAgsgACgCECIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgIUCyAAKAI4IgMgAUkEQCABIAMiAmsiBCAAKAIwIAJrSwRAIABBMGogAiAEQQRBBBAnIAAoAjghAgsgACgCNCIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgI4CyAAKAIgIgNB//8DTQRAIAMhAUGAgAQgA2siAiAAKAIYIANrSwRAIABBGGogAyACQQRBBBAnIAAoAiAhAQsgACgCHCIFIAFBAnQiBGohAiADQf//A0cEQEH8/w8gA0ECdCIGayIHBEAgAkEAIAf8CwALIAQgBmsgBWpB/P8PaiECIAEgA2tB//8DaiEBCyACQQA2AgAgACABQQFqNgIgCyAAKAIsIgNB//8DTQRAIAMhAUGAgAQgA2siAiAAKAIkIANrSwRAIABBJGogAyACQQRBBBAnIAAoAiwhAQsgACgCKCIFIAFBAnQiBGohAiADQf//A0cEQEH8/w8gA0ECdCIGayIHBEAgAkEAIAf8CwALIAQgBmsgBWpB/P8PaiECIAEgA2tB//8DaiEBCyACQQA2AgAgACABQQFqNgIsCwuwBQIIfwF+QStBgIDEACAAKAIIIghBgICAAXEiBhshCyAGQRV2IARqIQYCQCAIQYCAgARxRQRAQQAhAQwBCwJAIAJBEE8EQCABIAIQEiEFDAELIAJFBEAMAQsgAkEDcSEJAkAgAkEESQRADAELIAJBDHEhDANAIAUgASAHaiIKLAAAQb9/SmogCkEBaiwAAEG/f0pqIApBAmosAABBv39KaiAKQQNqLAAAQb9/SmohBSAMIAdBBGoiB0cNAAsLIAlFDQAgASAHaiEHA0AgBSAHLAAAQb9/SmohBSAHQQFqIQcgCUEBayIJDQALCyAFIAZqIQYLAkAgAC8BDCIJIAZLBEACQAJAIAhBgICACHFFBEAgCSAGayEJQQAhBUEAIQYCQAJAAkAgCEEddkEDcUEBaw4DAAEAAgsgCSEGDAELIAlB/v8DcUEBdiEGCyAIQf///wBxIQogACgCBCEIIAAoAgAhAANAIAVB//8DcSAGQf//A3FPDQJBASEHIAVBAWohBSAAIAogCCgCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEHIAAoAgAiCCAAKAIEIgogCyABIAIQOQ0DQQAhBSAJIAZrQf//A3EhAQNAIAVB//8DcSABTw0CIAVBAWohBSAIQTAgCigCEBEAAEUNAAsMAwtBASEHIAAgCCALIAEgAhA5DQIgACADIAQgCCgCDBECAA0CQQAhBSAJIAZrQf//A3EhAQNAIAVB//8DcSICIAFJIQcgASACTQ0DIAVBAWohBSAAIAogCCgCEBEAAEUNAAsMAgsgCCADIAQgCigCDBECAA0BIAAgDTcCCEEADwtBASEHIAAoAgAiBiAAKAIEIgAgCyABIAIQOQ0AIAYgAyAEIAAoAgwRAgAhBwsgBwuUBgEFfyAAQQhrIgEgAEEEaygCACIDQXhxIgBqIQICQAJAIANBAXENACADQQJxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUHkmcAAKAIARgRAIAIoAgRBA3FBA0cNAUHcmcAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQHwsCQAJAAkACQAJAIAIoAgQiA0ECcUUEQCACQeiZwAAoAgBGDQIgAkHkmcAAKAIARg0DIAIgA0F4cSICEB8gASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB5JnAACgCAEcNAUHcmcAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQIEEAIQFB/JnAAEH8mcAAKAIAQQFrIgA2AgAgAA0EQcSXwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtB/JnAAEH/HyABIAFB/x9NGzYCAA8LQeiZwAAgATYCAEHgmcAAQeCZwAAoAgAgAGoiADYCACABIABBAXI2AgRB5JnAACgCACABRgRAQdyZwABBADYCAEHkmcAAQQA2AgALIABB9JnAACgCACIDTQ0DQeiZwAAoAgAiAkUNA0EAIQBB4JnAACgCACIEQSlJDQJBvJfAACEBA0AgAiABKAIAIgVPBEAgAiAFIAEoAgRqSQ0ECyABKAIIIQEMAAsAC0HkmcAAIAE2AgBB3JnAAEHcmcAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAA8LAkBB1JnAACgCACICQQEgAEEDdnQiA3FFBEBB1JnAACACIANyNgIAIABB+AFxQcyXwABqIgAhAgwBCyAAQfgBcSIAQcyXwABqIQIgAEHUl8AAaigCACEACyACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0HEl8AAKAIAIgEEQANAIABBAWohACABKAIIIgENAAsLQfyZwABB/x8gACAAQf8fTRs2AgAgAyAETw0AQfSZwABBfzYCAAsL6QQBBX8CfwJAIAJBAk8EQCABKAIEIgRB//8BcUUEQCAEQRB0DAMLIARB/wdxIQUgBEGAgAJxIQMgBEGA+AFxIgZBgPgBRgRAIANBEHQhAyADQYCAgPwHciAFRQ0DGiADIAVBDXRyQYCAgP4HcgwDCyADQRB0IQMgBkUNASAGQQ10QYCAgPwAcSAFQQ10ckGAgIDAA2ogA3IMAgtBAUEBQdCKwAAQMAALIAUgBWdBEGsiBUH//wNxQQhqdEH///8DcSADQYCAgNgDciAFQRd0a3ILIQUCfyAEQYCAfHEgBEEQdiIDQf//AXFFDQAaIANB/wdxIQQgA0GAgAJxIQYgA0GA+AFxIgdBgPgBRgRAIAZBEHQhBiAGQYCAgPwHciAERQ0BGiAGIANBDXRyQYCAgP4HcgwBCyAGQRB0IQMgB0ENdEGAgID8AHEgBEENdHJBgICAwANqIANyIAcNABogBCAEZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgshBCAAAn8CQCACQQJHBEAgASgCCCICQf//AXFFBEAgAkEQdAwDCyACQf8HcSEBIAJBgIACcSEDIAJBgPgBcSICQYD4AUYEQCADQRB0IQIgAkGAgID8B3IgAUUNAxogAiABQQ10ckGAgID+B3IMAwsgA0EQdCEDIAJFDQEgAkENdEGAgID8AHEgAUENdHJBgICAwANqIANyDAILQQJBAkHgisAAEDAACyABIAFnQRBrIgFB//8DcUEIanRB////A3EgA0GAgIDYA3IgAUEXdGtyCzYCCCAAIAQ2AgQgACAFNgIAC9sEAQZ/AkACQCAAKAIIIgdBgICAwAFxRQ0AAkACQAJAAkAgB0GAgICAAXEEQCAALwEOIgMNAUEAIQIMAgsgAkEQTwRAIAEgAhASIQMMBAsgAkUEQAwECyACQQNxIQYCQCACQQRJBEAMAQsgAkEMcSEIA0AgAyABIAVqIgQsAABBv39KaiAEQQFqLAAAQb9/SmogBEECaiwAAEG/f0pqIARBA2osAABBv39KaiEDIAggBUEEaiIFRw0ACwsgBkUNAyABIAVqIQQDQCADIAQsAABBv39KaiEDIARBAWohBCAGQQFrIgYNAAsMAwsgASACaiEIQQAhAiABIQQgAyEFA0AgBCIGIAhGDQICfyAGQQFqIAYsAAAiBEEATg0AGiAGQQJqIARBYEkNABogBkEDaiAEQXBJDQAaIAZBBGoLIgQgBmsgAmohAiAFQQFrIgUNAAsLQQAhBQsgAyAFayEDCyADIAAvAQwiBE8NACAEIANrIQZBACEDQQAhBQJAAkACQCAHQR12QQNxQQFrDgIAAQILIAYhBQwBCyAGQf7/A3FBAXYhBQsgB0H///8AcSEIIAAoAgQhByAAKAIAIQADQCADQf//A3EgBUH//wNxSQRAQQEhBCADQQFqIQMgACAIIAcoAhARAABFDQEMAwsLQQEhBCAAIAEgAiAHKAIMEQIADQFBACEDIAYgBWtB//8DcSEBA0AgA0H//wNxIgIgAUkhBCABIAJNDQIgA0EBaiEDIAAgCCAHKAIQEQAARQ0ACwwBCyAAKAIAIAEgAiAAKAIEKAIMEQIAIQQLIAQL+wMBCH8jAEEQayIGJAACfwJAIANBAXFFBEAgAi0AACIFDQFBAAwCCyAAIAIgA0EBdiABKAIMEQIADAELIAEoAgwhCgNAIAJBAWohBAJAAkACQAJAIAXAQQBIBEAgBUH/AXEiCEGAAUYNASAIQcABRw0DIAYgATYCBCAGIAA2AgAgBkKggICABjcCCCADIAdBA3RqIgIoAgAgBiACKAIEEQAARQ0CQQEMBgsgACAEIAVB/wFxIgIgChECAEUEQCACIARqIQIMBAtBAQwFCyAAIAJBA2oiBCACLwABIgIgChECAEUEQCACIARqIQIMAwtBAQwECyAHQQFqIQcgBCECDAELQaCAgIAGIQsgBUEBcQRAIAIoAAEhCyACQQVqIQQLQQAhCAJ/IAVBAnFFBEBBACEJIAQMAQsgBC8AACEJIARBAmoLIQIgBUEEcQR/IAIvAAAhCCACQQJqBSACCyEEIAVBCHEEfyAELwAAIQcgBEECagUgBAshAiAFQRBxBEAgAyAJQQN0ai8BBCEJCyAGIAVBIHEEfyADIAhBA3RqLwEEBSAICzsBDiAGIAk7AQwgBiALNgIIIAYgATYCBCAGIAA2AgBBASADIAdBA3RqIgQoAgAgBiAEKAIEEQAADQIaIAdBAWohBwsgAi0AACIFDQALQQALIAZBEGokAAv/BQILfwF+IwBBMGsiACQAAkACQAJAAkBB+JTAACgCAEEBRgRAQfyUwAAoAgAhAQwBC0GQlcAAKAIAIQFBkJXAAEEANgIAIAFFDQEgAEEYaiABEQUAIABBEGoiAyAAQSRqKQIANwMAIAAgACkCHDcDCCAAKAIYIQFB+JTAACgCAEEBRg0CQfiUwABBATYCAEGAlcAAIAApAwg3AgBBiJXAACADKQMANwIAC0GMlcAAKAIAIQNBiJXAACgCACEHQYiVwABCADcCAEGElcAAKAIAIQRBhJXAAEEANgIAQYCVwAAoAgAhBkH8lMAAQoCAgIDAADcCAAJAAkACQAJAIAQgB0YEQCABIARHDQLQb0GAASABIAFBgAFNGyIF/A8BIgJBf0cNAQwHCyAEIAdNDQYgBiAHQQJ0aigCACECQYyVwAAgAzYCAEGIlcAAIAI2AgBBhJXAACAENgIAQYCVwAAgBjYCAEH8lMAAIAE2AgAMAwsCQCADRQRAIAIhAwwBCyABIANqIAJHDQYLIABBGGohCCABIQJBASEKQQQhCQJAIAEgBWoiAa1CAoYiC0IgiFBFBEBBACEFDAELIAunIgVB/P///wdLBEBBACEFDAELAkACQAJ/IAIEQCAGIAJBAnRBBCAFEFoMAQsgBUUNASAFQQQQYwsiCQ0AIAhBBDYCBAwBCyAIIAk2AgRBACEKC0EIIQkLIAggCWogBTYCACAIIAo2AgAgACgCGEEBRg0FIAAoAhwhBgwBCyABIARNDQQLIAYgBEECdGogBEEBaiICNgIAQYyVwAAgAzYCAEGIlcAAIAI2AgBBhJXAACACNgIAQYCVwAAoAgBBgJXAACAGNgIAQfyUwAAoAgAhAkH8lMAAIAE2AgAgAkUNACACQQJ0EF8LIABBMGokACADIAdqDwtBkI7AAEHVAEG8jsAAEDUACyAAQShqIAMpAwA3AgAgACAAKQMINwIgIAAgATYCHCAAQQE2AhggAEEYahA+QfKNwABBHUGAjsAAEDUACwAL9wMBCn9BCiECIAAiBEHoB08EQCABQQRrIQYgBCEDAkACQANAIAMgA0GQzgBuIgRBkM4AbGsiCUH//wNxQeQAbiEHAkAgBUEKaiICQQRrQQpJBEAgBkEKaiIIIAdBAXQiCi0A5ZJAOgAAIAJBA2siC0EKSQ0BIAtBCkHIksAAEDAACyACQQRrQQpByJLAABAwAAsgCEEBaiAKQeaSwABqLQAAOgAAIAJBAmtBCkkEQCAIQQJqIAkgB0HkAGxrQQF0Qf7/B3EiBy0A5ZJAOgAAIAJBAWtBCk8NAiAIQQNqIAdB5pLAAGotAAA6AAAgBkEEayEGIAVBBGshBSADQf+s4gRLIAQhA0UNAwwBCwsgAkECa0EKQciSwAAQMAALIAJBAWtBCkHIksAAEDAACyAFQQpqIQILAkAgBEEJTQRAIAQhBSACIQMMAQsgBEH//wNxQeQAbiEFAkAgAkECayIDQQpJBEAgASADaiAEIAVB5ABsa0H//wNxQQF0IgYtAOWSQDoAACACQQFrIgRBCk8NASABIARqIAZB5pLAAGotAAA6AAAMAgsgA0EKQciSwAAQMAALIARBCkHIksAAEDAAC0EAIAAgBRtFBEAgA0EBayIDQQpPBEAgA0EKQciSwAAQMAALIAEgA2ogBUEBdC0A5pJAOgAACyADC4cEAgR/An0jAEEQayEBIAC8IgNBH3YhBAJAAn0gAAJ/AkACQAJAIANB/////wdxIgJB0Ni6lQRPBEAgAkGAgID8B0sEQCAADwsgAkGX5MWVBE0EQCADQQBODQIgAUMAAICAIACVOAIIIAEqAggaDAILIANBAEgEQCABQwAAgIAgAJU4AgggASoCCBogAkG047+WBE0NAgwHCyAAQwAAAH+UDwsgAkGY5MX1A00EQCACQYCAgMgDTQ0CQQAhASAADAULIAJBkquU/ANNDQILIABDO6q4P5QgBEECdCoC8JRAkvwADAILIAEgAEMAAAB/kjgCDCABKgIMGiAAQwAAgD+SDwsgBEUgBGsLIgGyIgVDAHIxv5SSIgAgBUOOvr81lCIGkwshBSAAIAUgBSAFIAWUIgAgAEMVUjW7lEOPqio+kpSTIgCUQwAAAEAgAJOVIAaTkkMAAIA/kiEFIAFFDQACQAJAAkAgAUH/AEwEQCABQYJ/Tg0DIAVDAACADJQhBSABQZt+TQ0BIAFB5gBqIQEMAwsgBUMAAAB/lCEFIAFB/gFLDQEgAUH/AGshAQwCCyAFQwAAgAyUIQVBtn0gASABQbZ9TRtBzAFqIQEMAQsgBUMAAAB/lCEFQf0CIAEgAUH9Ak8bQf4BayEBCyAFIAFBF3RBgICA/ANqQYCAgPwHcb6UIQULIAULjwQBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEHkmcAAKAIARgRAIAIoAgRBA3FBA0cNAUHcmcAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEB8LAkACQAJAIAIoAgQiA0ECcUUEQCACQeiZwAAoAgBGDQIgAkHkmcAAKAIARg0DIAIgA0F4cSICEB8gACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB5JnAACgCAEcNAUHcmcAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQIA8LAkBB1JnAACgCACICQQEgAUEDdnQiA3FFBEBB1JnAACACIANyNgIAIAFB+AFxQcyXwABqIgEhAgwBCyABQfgBcSIBQcyXwABqIQIgAUHUl8AAaigCACEBCyACIAA2AgggASAANgIMIAAgAjYCDCAAIAE2AggPC0HomcAAIAA2AgBB4JnAAEHgmcAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABB5JnAACgCAEcNAUHcmcAAQQA2AgBB5JnAAEEANgIADwtB5JnAACAANgIAQdyZwABB3JnAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgALC9ADAQZ/IwBBEGsiBSQAAkACQAJAAkACQAJAIAJBAXEEQCACQQF2IQMMAQsgAS0AACIDRQ0BIAEhBANAIARBAWohBAJAIAPAQQBIBEAgA0H/AXFBgAFGBEAgBiAELwAAIgNqIQYgAyAEakECaiEEDAILIAQgA0EDcUEYdyIIQQV0QYCAgIAEcSAIQYCAgIACcSAIQYCAgAhxQQd0cnJBHXZqIANBAXZBAnFqIANBAnZBAnFqIQQgBkUgB3IhBwwBCyAEIANB/wFxIgNqIQQgAyAGaiEGCyAELQAAIgMNAAtBACEDIAcgBkEQSXENAEEAIQcgBkEBdCIDQQBIDQQLIAMNAQtBASEEQQAhAwwBC0EBIQcgA0EBEGMiBEUNAQsgBUEANgIIIAUgBDYCBCAFIAM2AgAgBUGMkcAAIAEgAhAYRQ0BIwBBIGsiACQAIABB1gA2AgQgAEG0kcAANgIAIABBpJHAADYCDCAAIAVBD2o2AgggACAAQQhqrUKAgICAkAWENwMYIAAgAK1CgICAgLAFhDcDEEHvg8AAIABBEGpBjJLAABA1AAsgByADEE4ACyAAIAUpAgA3AgAgAEEIaiAFQQhqKAIANgIAIAVBEGokAAvnAgEFfwJAIAFBzf97QRAgACAAQRBNGyIAa08NACAAQRAgAUELakF4cSABQQtJGyIEakEMahARIgJFDQAgAkEIayEBAkAgAEEBayIDIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSACIANqQQAgAGtxQQhrIgIgAEEAIAIgAWtBEE0baiIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgASACaiIDIAMoAgRBAXI2AgQgASACEBwMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgACgCBCIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIAAgBCABQQFxckECcjYCBCAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBAcCyAAQQhqIQMLIAMLggMBBH8gACgCDCECAkACQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAgJAIAAoAhxBAnRBvJbAAGoiASgCACAARwRAIAMoAhAgAEYNASADIAI2AhQgAg0DDAQLIAEgAjYCACACRQ0EDAILIAMgAjYCECACDQEMAgsgACgCCCIAIAJHBEAgACACNgIMIAIgADYCCA8LQdSZwABB1JnAACgCAEF+IAFBA3Z3cTYCAA8LIAIgAzYCGCAAKAIQIgEEQCACIAE2AhAgASACNgIYCyAAKAIUIgBFDQAgAiAANgIUIAAgAjYCGA8LDwtB2JnAAEHYmcAAKAIAQX4gACgCHHdxNgIAC8QCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEmIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiAjYCHCACQQJ0QbyWwABqIQRBASACdCIDQdiZwAAoAgBxRQRAIAQgADYCACAAIAQ2AhggACAANgIMIAAgADYCCEHYmcAAQdiZwAAoAgAgA3I2AgAPCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEFA0AgAyAFQR12QQRxaiIEKAIQIgJFDQIgBUEBdCEFIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAEQRBqIAA2AgAgACADNgIYIAAgADYCDCAAIAA2AggLgwEBAX8jAEEgayIDJAACQAJAIAAgAU0EQAwBCyADIAA2AgggAyABNgIMIAMgA0EMaq1CgICAgNAAhDcDGAwBCyADIAA2AgggAyABNgIMIAMgA0EMaq1CgICAgNAAhDcDGAsgAyADQQhqrUKAgICA0ACENwMQQfuBwAAgA0EQaiACEDUAC4gCAQZ/IAAoAggiBCECAn9BASABQYABSQ0AGkECIAFBgBBJDQAaQQNBBCABQYCABEkbCyIGIAAoAgAgBGtLBH8gACAEIAYQKSAAKAIIBSACCyAAKAIEaiECAkAgAUGAAU8EQCABQT9xQYB/ciEFIAFBBnYhAyABQYAQSQRAIAIgBToAASACIANBwAFyOgAADAILIAFBDHYhByADQT9xQYB/ciEDIAFB//8DTQRAIAIgBToAAiACIAM6AAEgAiAHQeABcjoAAAwCCyACIAU6AAMgAiADOgACIAIgB0E/cUGAf3I6AAEgAiABQRJ2QXByOgAADAELIAIgAToAAAsgACAEIAZqNgIIQQALiAIBBn8gACgCCCIEIQICf0EBIAFBgAFJDQAaQQIgAUGAEEkNABpBA0EEIAFBgIAESRsLIgYgACgCACAEa0sEfyAAIAQgBhAsIAAoAggFIAILIAAoAgRqIQICQCABQYABTwRAIAFBP3FBgH9yIQUgAUEGdiEDIAFBgBBJBEAgAiAFOgABIAIgA0HAAXI6AAAMAgsgAUEMdiEHIANBP3FBgH9yIQMgAUH//wNNBEAgAiAFOgACIAIgAzoAASACIAdB4AFyOgAADAILIAIgBToAAyACIAM6AAIgAiAHQT9xQYB/cjoAASACIAFBEnZBcHI6AAAMAQsgAiABOgAACyAAIAQgBmo2AghBAAv6AQIDfwF+IwBBMGsiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBLGoiBEEANgIAIAJCgICAgBA3AiQgAkEkakHMjsAAIAMoAgAiAygCACADKAIEEBgaIAJBIGogBCgCACIDNgIAIAIgAikCJCIFNwMYIAFBCGogAzYCACABIAU3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBEGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDCEEMQQQQYyIBRQRAQQRBDBBmAAsgASACKQMINwIAIAFBCGogAygCADYCACAAQdiQwAA2AgQgACABNgIAIAJBMGokAAuUAgECfyMAQSBrIgUkAEG4lsAAQbiWwAAoAgAiBkEBajYCAAJAAn9BACAGQQBIDQAaQQFBpJbAAC0AAA0AGkGklsAAQQE6AABBoJbAAEGglsAAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcUUNASAFQQhqIAAgASgCGBEBAAwBC0GslsAAKAIAIgZBAEgNAEGslsAAIAZBAWo2AgBBsJbAACgCAARAIAUgACABKAIUEQEAIAUgBDoAHSAFIAM6ABwgBSACNgIYIAUgBSkDADcCEEGwlsAAKAIAIAVBEGpBtJbAACgCACgCFBEBAAtBrJbAAEGslsAAKAIAQQFrNgIAQaSWwABBADoAACADRQ0AAAsAC6gBAgJ/AX5BASEHQQQhBgJAIAQgBWpBAWtBACAEa3GtIAOtfiIIQiCIUEUEQEEAIQMMAQsgCKciA0GAgICAeCAEa0sEQEEAIQMMAQsCQAJAAn8gAQRAIAIgASAFbCAEIAMQWgwBCyADRQRAIAQhBgwCCyADIAQQYwsiBg0AIAAgBDYCBAwBCyAAIAY2AgRBACEHC0EIIQYLIAAgBmogAzYCACAAIAc2AgALpwEBAX8jAEEQayIFJAAgBEUEQEEAQQAQTgALIAIgASACaiIBSwRAQQBBABBOAAsgBUEEaiAAKAIAIgIgACgCBCABIAJBAXQiAiABIAJLGyIBQQhBBEEBIARBgQhJGyAEQQFGGyICIAEgAksbIgEgAyAEECYgBSgCBEEBRgRAIAUoAgggBSgCDBBOAAsgBSgCCCECIAAgATYCACAAIAI2AgQgBUEQaiQAC6MBAQF/IwBBEGsiBiQAAkAgAQRAIAZBBGogASADIAQgBSACKAIQEQgAAkAgBigCBCICIAYoAgwiAU0EQCAGKAIIIQUMAQsgAkECdCECIAYoAgghAyABRQRAQQQhBSADIAIQXwwBCyADIAJBBCABQQJ0IgIQWiIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQcCNwABBMhBkAAtBBCACEE4AC4cBAQF/IwBBEGsiAyQAIAIgASACaiIBSwRAQQBBABBOAAsgA0EEaiAAKAIAIgIgACgCBEEIIAEgAkEBdCICIAEgAksbIgEgAUEITRsiAUEBQQEQJiADKAIEQQFGBEAgAygCCCADKAIMEE4ACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALjgECA38BbyMAQRBrIgMkACAAKAIAIgAQbSEEIAMgAjYCDCADIAQ2AgggAiAERgRAEFgiBRBVIgQlASABIAIQBCEGEBkiASAGJgEgBUGEAU8EQCAFEDYLIARBhAFPBEAgBBA2CyAAIAFBABBeIAFBhAFPBEAgARA2CyADQRBqJAAPCyADQQhqIANBDGoQOAALnAECA38BfiMAQSBrIgIkACABKAIAQYCAgIB4RgRAIAEoAgwhAyACQRxqIgRBADYCACACQoCAgIAQNwIUIAJBFGpBzI7AACADKAIAIgMoAgAgAygCBBAYGiACQRBqIAQoAgAiAzYCACACIAIpAhQiBTcDCCABQQhqIAM2AgAgASAFNwIACyAAQdiQwAA2AgQgACABNgIAIAJBIGokAAvxAQEEfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQTgALIANBBGohBCAAKAIEIQYCf0EIIAEgACgCACICQQF0IgUgASAFSxsiASABQQhNGyIFIgFBAEgEQEEBIQJBACEBQQQMAQsCfwJAAn8gAgRAIAYgAkEBIAEQWgwBCyABRQRAQQEhAgwCCyABQQEQYwsiAg0AIARBATYCBEEBDAELIAQgAjYCBEEACyECQQgLIARqIAE2AgAgBCACNgIAIAMoAgRBAUYEQCADKAIIIAMoAgwQTgALIAMoAgghASAAIAU2AgAgACABNgIEIANBEGokAAtoAQJ/QQEhAwJAIAFBAXEEQCABQQF2IQIgAUECTwRAIAJBARBjIgNFDQILIAIEQCADQfODwAAgAvwKAAALIAAgAjYCCCAAIAM2AgQgACACNgIADwsgAEHzg8AAIAEQHQ8LQQEgAhBOAAtpAQN/IwBBEGsiASQAIAFBBGogACgCACICIAAoAgRBBCACQQF0IgIgAkEETRsiAkEEQQQQJiABKAIEQQFGBEAgASgCCCABKAIMEE4ACyABKAIIIQMgACACNgIAIAAgAzYCBCABQRBqJAALiwECA38BbyMAQRBrIgMkACADIAAoAgAQbSIENgIIIAMgAjYCDCACIARHBEAgA0EIaiADQQxqEDgACxBYIgQQVSIFJQEQBiEGEBkiAiAGJgEgBUGEAU8EQCAFEDYLIAIgACgCACABQQJ2EF4gAkGEAU8EQCACEDYLIARBhAFPBEAgBBA2CyADQRBqJAALTwIBfwF+IwBBIGsiAyQAIAMgATYCDCADIAA2AgggA0KAgICA0AAiBCADQQhqrYQ3AxggAyAEIANBDGqthDcDEEGLgcAAIANBEGogAhA1AAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACECkgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACECwgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAs0AQF/IwBBEGsiAiQAIAFBAUEAIAAoAgAgAkEGaiIBEBoiACABakEKIABrEBQgAkEQaiQAC0QBAn8gASgCBCECIAEoAgAhA0EIQQQQYyIBRQRAQQRBCBBmAAsgASACNgIEIAEgAzYCACAAQbyQwAA2AgQgACABNgIAC94BAgF/AX4jAEEgayIDJAAgAyABNgIQIAMgADYCDCADQQE7ARwgAyACNgIYIAMgA0EMajYCFCMAQRBrIgEkACADQRRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIEIgNBAXEEQCACKAIAIQIgACADQQF2NgIEIAAgAjYCACAAQeSOwAAgASgCBCABKAIIIgAtAAggAC0ACRAlAAsgAEGAgICAeDYCACAAIAE2AgwgAEGAj8AAIAEoAgQgASgCCCIALQAIIAAtAAkQJQAL1gMBBn8jAEEQayIFJAAgBSAANgIMIABBhAFPBEAgANBvJgEgBUEMaiECIwBBMGsiACQAAkACQAJAAkACQEH4lMAAKAIAQQFGBEBB/JTAACgCACEDDAELQZCVwAAoAgAhA0GQlcAAQQA2AgAgA0UNASAAQRhqIAMRBQAgAEEQaiIBIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghA0H4lMAAKAIAQQFGDQJB+JTAAEEBNgIAQYCVwAAgACkDCDcCAEGIlcAAIAEpAwA3AgALQYCVwAAoAgAhAUH8lMAAQoCAgIDAADcCACACKAIAIgRBjJXAACgCACICSQ0CIAQgAmsiBEGElcAAKAIAIgZPDQIgASAEQQJ0akGIlcAAKAIANgIAQYyVwAAgAjYCAEGIlcAAIAQ2AgBBhJXAACAGNgIAQYCVwAAoAgAhAkGAlcAAIAE2AgBB/JTAACgCACEBQfyUwAAgAzYCACABBEAgAiABQQJ0EF8LIABBMGokAAwDC0GQjsAAQdUAQbyOwAAQNQALIABBKGogASkDADcCACAAIAApAwg3AiAgACADNgIcIABBATYCGCAAQRhqED5B8o3AAEEdQYCOwAAQNQsACwsgBUEQaiQACz4AIAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQVg8LIAEoAgAgASgCBCAAKAIMKAIAIgAoAgAgACgCBBAYC64BAQF/IwBBEGsiAiQAIAIgATYCDCACIAA2AggjAEFAaiIAJAAgAEG0ksAANgIEIAAgAkEIajYCACAAQbSSwAA2AgwgACACQQxqNgIIIABB5JTAACgCADYCFCAAQdiUwAAoAgA2AhAgACAAQQhqrUKAgICAkAWENwMwIAAgAK1CgICAgJAFhDcDKCAAIABBEGqtQoCAgICwBYQ3AyBBsoLAACAAQSBqQbCNwAAQNQALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgALswEBAn8jAEEQayIAJAAgASgCAEHMkMAAQQsgASgCBCgCDBECACEDIABBCGoiAkEAOgAFIAIgAzoABCACIAE2AgAgAiIBLQAEIQIgAS0ABQRAIAECf0EBIAJBAXENABogASgCACIBLQAKQYABcUUEQCABKAIAQdiSwABBAiABKAIEKAIMEQIADAELIAEoAgBBxJLAAEEBIAEoAgQoAgwRAgALIgI6AAQLIAJBAXEgAEEQaiQAC4sUAhp/EH0QGSIOIAkmASMAQYABayINJAAgDSAONgIsIA0gCDYCKCANIAc4AiQgDSAGOAIgIA0gBTgCHCANIAQ4AhggDSADOAIUIA0gAjgCECANIAE4AgwgDSAAOAIIIA0gCkEARzoAMyANIAs4AjQgDSAMOAI4IA1BADYCRCANQoCAgIDAADcCPCANIA1BOGo2AnwgDSANQTRqNgJ4IA0gDUEkajYCdCANIA1BIGo2AnAgDSANQRxqNgJsIA0gDUEYajYCaCANIA1BFGo2AmQgDSANQRBqNgJgIA0gDUEMajYCXCANIA1BCGo2AlggDSANQTxqNgJUIA0gDUEzajYCUCANIA1BLGo2AkwgDSANQShqNgJIIA1ByABqIiQhCCMAQSBrIg4kAAJAQQBBvIrAACgCABEEACIUBEACQCAUKAIARQRAIAgoAjQhFyAIKAIwIRggCCgCLCEZIAgoAighGiAIKAIkIRsgCCgCICEcIAgoAhwhHSAIKAIYIR4gCCgCFCEfIAgoAhAhICAIKAIMIRIgCCgCCCElIAgoAgQhJiAIKAIAISEgFEF/NgIAIBQgISgCACIPBH8gFEEMaigCACEiIBRBCGooAgAhCgNAIA4gJiAVQQJ0IBVBgIAEIA8gFWsiCCAIQYCABE8bIghqIhVBAnQQYCIjNgIEIAhBAnQiDyAiSw0DIA5BBGogCiAPEC8CQCAlLQAARQRAIA4gHioCADgCECAOIB8qAgA4AgwgDiAgKgIAOAIIIA4gGyoCADgCHCAOIBwqAgA4AhggDiAdKgIAOAIUIAohCCAaKgIAISggGSoCACEnIBgqAgAhACAXKgIAIQEjAEEQayITJAAgDwRAIA5BFGoiECoCACICIAKUIBAqAgQiAyADlJIgECoCCCIEIASUkiEFIAEgAJNDAAB+Q5UhASAOQQhqIhAqAgghKSAQKgIEISogECoCACErA0AgD0EEIA9BBEkiERshEAJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgE0EEaiAIIBAQFiARRQRAIAIgKyATKgIEkyIGlCADICogEyoCCJMiB5SSIAQgKSATKgIMkyILlJIiDCAMlCAFIAYgBpQgByAHlJIgCyALlJIgCCgCDCIRQf8BcQR9IAAgASARQQFrQf8BcbOUkhAbBUMAAAAACyARQQh2IhZB/wFxBH0gACABIBZBAWtB/wFxs5SSEBsFQwAAAAALkiARQRB2IhFB/wFxBH0gACABIBFBAWtB/wFxs5SSEBsFQwAAAAALkkMAAEBAlSIGIAaUk5STIgZDAAAAAF0NASAMjCAGkZMgBZUiBiAoYEUgBiAnX0VyDQEgEigCCCIRIBIoAgBGBEAgEhAuCyASKAIEIBFBAnRqIAY4AgAgEiARQQFqNgIIDAELQQMgEEHAisAAEDAACyAIIBBBAnRqIQggDyAQayIPDQALCwwBCyAOIB4qAgA4AhAgDiAfKgIAOAIMIA4gICoCADgCCCAOIBsqAgA4AhwgDiAcKgIAOAIYIA4gHSoCADgCFCAKIQggGioCACEyIBkqAgAhMyAYKgIAISggFyoCACEAIwBBEGsiEyQAIA8EQCAAICiTQwAAfkOVISkgDkEUaiIQKgIAISogECoCBCErIBAqAgghLiAOQQhqIhAqAgghNCAQKgIEITUgECoCACE2A0AgD0EEIA9BBEkiERshEAJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgE0EEaiAIIBAQFgJAIBFFBEAgEyoCDCEAIBMqAgghASATKgIEIQJDAAAAACEDQwAAAAAhBCAIKAIMIhFB/wFxBEAgKCApIBFBAWtB/wFxs5SSEBshBAsgEUEIdiIWQf8BcQRAICggKSAWQQFrQf8BcbOUkhAbIQMLIDQgAJMhJyA1IAGTIS8gNiACkyEwIBFBEHYiFkH/AXEEfSAoICkgFkEBa0H/AXGzlJIQGwVDAAAAAAshBSAuIAgoAggiFkEYdbJDAAD+QpUiACArIBFBGHWyQwAA/kKVIgGUIC4gAJSTIgyUIBZBEHbAskMAAP5ClSICIC4gApQgKiABlJMiLJSTICogAJQgKyAClJMiLUMAAIA/IAIgApSTIAAgAJSTIAEgAZSTQwAAAAAQS5EiBpSSIgcgB5KSIQcgKyACIC2UIAEgDJSTICwgBpSSIgsgC5KSIQsgKiABICyUIAAgLZSTIAwgBpSSIgwgDJKSIQwgJyAAIC8gAZQgJyAAlJMiLJQgAiAnIAKUIDAgAZSTIi2UkyAwIACUIC8gApSTIjEgBpSSIicgJ5KSIScgLyACIDGUIAEgLJSTIC0gBpSSIgIgApKSIQIgMCABIC2UIAAgMZSTICwgBpSSIgAgAJKSIQAgBSAEIAMQSyAFEEtDCtcjPJQiAV1FBEAgASADXkUEQCABIAReRQRAQwAAgD8gBZUiBSAnlCIBIAUgB5QiBZRDAACAPyAElSIEIACUIgAgBCAMlCIElEMAAIA/IAOVIgMgApQiAiADIAuUIgOUkpIiBiAGlCAFIAWUIAQgBJQgAyADlJKSIgMgASABlCAAIACUIAIgApSSkkMAAIC/kpSTIgBDAAAAAF0NBSAGjCAAkZMgA5UhAAwECyAMi0O9N4Y1XQ0EIAIgCyAAjCAMlSIAlJIgA5UiASABlCAnIAcgAJSSIAWVIgEgAZSSQwAAgD9eRQ0DDAQLIAuLQ703hjVdDQMgACAMIAKMIAuVIgCUkiAElSIBIAGUICcgByAAlJIgBZUiASABlJJDAACAP14NAwwCCyAHi0O9N4Y1XQ0CIAAgDCAnjCAHlSIAlJIgBJUiASABlCACIAsgAJSSIAOVIgEgAZSSQwAAgD9eRQ0BDAILQQMgEEHAisAAEDAACyAAIDJgRSAAIDNfRXINACASKAIIIhEgEigCAEYEQCASEC4LIBIoAgQgEUECdGogADgCACASIBFBAWo2AggLIAggEEECdGohCCAPIBBrIg8NAAsLCyATQRBqJAAgI0GEAU8EQCAjEDYLIBUgISgCACIPSQ0ACyAUKAIAQQFqBUEACzYCACAOQSBqJAAMAwsQPQALIA8gIkHQi8AAECEACxA8AAsgDSgCRBAMIQkQGSIIIAkmASANIAg2AkggDSgCQCEUIA0oAkQhDiMAQRBrIgokACAkKAIAIhUlARAJIQ8gCiAONgIMIAogDzYCCAJAIA4gD0YEQBBYIg8QVSISJQEgFCAOEAghCRAZIg4gCSYBIA9BhAFPBEAgDxA2CyASQYQBTwRAIBIQNgsgFSUBIA4lAUEAEAogDkGEAU8EQCAOEDYLIApBEGokAAwBCyAKQQhqIApBDGoQOAALIA0oAjwiCgRAIA0oAkAgCkECdBBfCyANKAIsIgpBhAFPBEAgChA2CyANQYABaiQAIAglASAIEDYLLwEBfyMAQRBrIgAkACAAIABBD2qtQoCAgIDAAoQ3AwBBpIPAACAAQfCKwAAQNQALLwEBfyMAQRBrIgAkACAAIABBD2qtQoCAgIDABYQ3AwBB84PAACAAQYCLwAAQNQALJQEBfwJAIAAoAgBFDQAgACgCBCIBRQ0AIAAoAgggAUECdBBfCwskACAARQRAQcCNwABBMhBkAAsgACACIAMgBCAFIAEoAhARBwALIgAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAQgASgCEBEQAAsiACAARQRAQcCNwABBMhBkAAsgACACIAMgBCABKAIQEQ0ACyIAIABFBEBBwI3AAEEyEGQACyAAIAIgAyAEIAEoAhARGAALIgAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAQgASgCEBEaAAsiACAARQRAQcCNwABBMhBkAAsgACACIAMgBCABKAIQERwACyUBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAEQXwsLIAAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAEoAhARAwALHgAgAEUEQEHAjcAAQTIQZAALIAAgAiABKAIQEQAAC4wPARZ/EBkiBCABJgEQGSIOIAImASMAQSBrIgokACAKIA42AgggCiAENgIEIAogADYCACAKIApBBGoiACgCABBtNgIMIAogCkEIajYCHCAKIAo2AhggCiAANgIUIAogCkEMajYCECAKQRBqIQAjAEEwayIJJAACQAJAAkACQAJAQQBBuIrAACgCABEEACIPBEAgDygCAA0BIAAoAgwhGCAAKAIIIQUgACgCACEEIA9BfzYCACAAKAIEIQAgD0EEaiILIAQoAgAQEyAJIABBACAFKAIAEGAiFjYCACAFKAIAIg4gDygCDCIASw0CIAkgDygCCCAOEC8gCUEEaiEVIAQoAgAhACAFKAIAIRAjAEEgayISJAAgCyAAEBMCQCALKAIIIgAgEE8EQCALKAIEIQ4gCygCHCEEIAsoAiAiFEECdCIGBEAgBEEAIAb8CwALIAsoAighEyALKAIsIhFBAnQiFwRAIBNBACAX/AsACyAQQQJ0IQwgEARAIAwhBSAOIQADQAJAIAAoAgAiA0GAgID8B08NACAUIANBf3MiB0H//wNxIgNLBEAgBCADQQJ0aiIDIAMoAgBBAWo2AgAgESAHQRB2IgNLBEAgEyADQQJ0aiIDIAMoAgBBAWo2AgAMAgsgAyARQbCMwAAQMAALIAMgFEGgjMAAEDAACyAAQQRqIQAgBUEEayIFDQALCwJAIBRFBEBBACEFDAELIAZBBGsiBUECdkEBaiIAQQdxIQ0CQCAFQRxJBEBBACEFIAQhAAwBCyAAQfj///8HcSEIQQAhBSAEIQADQCAAKAIAIQYgACAFNgIAIABBBGoiAygCACEHIAMgBSAGaiIDNgIAIABBCGoiBSgCACEGIAUgAyAHaiIDNgIAIABBDGoiBSgCACEHIAUgAyAGaiIDNgIAIABBEGoiBSgCACEGIAUgAyAHaiIDNgIAIABBFGoiBSgCACEHIAUgAyAGaiIDNgIAIABBGGoiBSgCACEGIAUgAyAHaiIHNgIAIABBHGoiBSgCACAFIAYgB2oiBTYCACAFaiEFIABBIGohACAIQQhrIggNAAsLIA1FDQAgDUECdCEIA0AgACgCACAAIAU2AgAgAEEEaiEAIAVqIQUgCEEEayIIDQALCyASIAU2AgwgEARAIAsoAjQhByALKAI4IQ1BACEIIA4hAANAAkAgACgCACIDQYCAgPwHTw0AAkAgFCADQX9zQf//A3EiA0sEQCAEIANBAnRqIgYoAgAiAyANTw0BIAcgA0ECdGogCDYCACAGIAYoAgBBAWo2AgAMAgsgAyAUQcCMwAAQMAALIAMgDUHQjMAAEDAACyAAQQRqIQAgCEEBaiEIIAxBBGsiDA0ACwsCQCARRQ0AIBdBBGsiDEECdkEBaiIEQQdxIQ1BACEIIBMhACAMQRxPBEAgBEH4////B3EhDANAIAAoAgAhAyAAIAg2AgAgAEEEaiIEKAIAIQcgBCADIAhqIgM2AgAgAEEIaiIEKAIAIQYgBCADIAdqIgM2AgAgAEEMaiIEKAIAIQcgBCADIAZqIgM2AgAgAEEQaiIEKAIAIQYgBCADIAdqIgM2AgAgAEEUaiIEKAIAIQcgBCADIAZqIgM2AgAgAEEYaiIEKAIAIQYgBCADIAdqIgc2AgAgAEEcaiIEKAIAIAQgBiAHaiIENgIAIARqIQggAEEgaiEAIAxBCGsiDA0ACwsgDUUNACANQQJ0IQwDQCAAKAIAIAAgCDYCACAAQQRqIQAgCGohCCAMQQRrIgwNAAsLIAVFDQEgCygCNCEIIAsoAjhBAnQhACALKAIQIQwgCygCFCEGIAUhBAJAAkADQCAARQ0EIBAgCCgCACINSwRAIA4gDUECdGooAgBBf3NBEHYiAyARTw0CIBMgA0ECdGoiBygCACIDIAZPDQMgCEEEaiEIIAwgA0ECdGogDTYCACAHIAcoAgBBAWo2AgAgAEEEayEAIARBAWsiBA0BDAULCyANIBBB4IzAABAwAAsgAyARQfCMwAAQMAALIAMgBkGAjcAAEDAACyAQIABBoI3AABAhAAsCQAJAIBFB//8DSwRAIBMoAvz/DyAFRw0BIBVBgICAgHg2AgAgFSAFNgIEDAILQf//AyARQZCNwAAQMAALIBIgE0H8/w9qrUKAgICA0ACENwMYIBIgEkEMaq1CgICAgNAAhDcDECAVQb6AwAAgEkEQahAdCyASQSBqJAAgCSgCBEGAgICAeEcNAyAJKAIIIgRFDQUgBCAPKAIYIgBLDQQgDygCFCEAIAkgGEEAIAQQYCIONgIcIAlBHGogACAEECogDkGEAUkNBSAOEDYMBQsQPAALED0ACyAOIABBwIvAABAhAAsgCUEYaiAJQQxqKAIANgIAIAkgCSkCBDcDECAJIAlBEGqtQoCAgIDAAIQ3AyggCUEcaiAJQShqEC0gCSgCICAJKAIkEGQACyAEIABBsIvAABAhAAsgFkGEAU8EQCAWEDYLIA8gDygCAEEBajYCACAJQTBqJAAgCigCCCIAQYQBTwRAIAAQNgsgCigCBCIAQYQBTwRAIAAQNgsgCkEgaiQAIAQLpQ4BEH8QGSIDIAEmARAZIgYgAiYBIwBBIGsiCSQAIAkgBjYCCCAJIAM2AgQgCSAANgIAIAkgCUEEaiIAKAIAEGw2AgwgCSAJQQhqNgIcIAkgCTYCGCAJIAA2AhQgCSAJQQxqNgIQIAlBEGohACMAQTBrIgckAAJAAkACQAJAAkBBAEG0isAAKAIAEQQAIg4EQCAOKAIADQEgACgCDCESIAAoAgghCyAOQX82AgAgACgCBCAAKAIAKAIAIgggDkEEaiIEKAIIIgNLBEAgCCADIgBrIgUgBCgCACAAa0sEQCAEIAAgBUECQQIQJyAEKAIIIQALIAQoAgQiDCAAQQF0aiEGIAVBAk8EQCAIIANBf3NqQQF0Ig0EQCAGQQAgDfwLAAsgACAIakEBdCADQQF0ayAMakECayEGIAAgBWpBAWshAAsgBkEAOwEAIAQgAEEBajYCCAsgBCgCFCIDIAhJBEAgCCADIgBrIgUgBCgCDCAAa0sEQCAEQQxqIAAgBUEEQQQQJyAEKAIUIQALIAQoAhAiDCAAQQJ0aiEGIAVBAk8EQCAIIANBf3NqQQJ0Ig0EQCAGQQAgDfwLAAsgACAIakECdCADQQJ0ayAMakEEayEGIAAgBWpBAWshAAsgBkEANgIAIAQgAEEBajYCFAsgBCgCICIAQYD4AU0EQEGB+AEgACIDayIGIAQoAhggAGtLBEAgBEEYaiAAIAZBBEEEECcgBCgCICEDCyAEKAIcIgggA0ECdCIFaiEGIABBgPgBRwR/QYDgByAAQQJ0IgxrIg0EQCAGQQAgDfwLAAsgAyAAa0GA+AFqIQMgBSAMayAIakGA4AdqBSAGC0EANgIAIAQgA0EBajYCIAsoAgAlAUEAIAsoAgAQCyEBEBkiECABJgEgByAQNgIAIAsoAgAiAyAOKAIMIgBLDQIgDigCCCEFIwBBEGsiACQAIAAgBygCABBsIgY2AgggACADNgIMIAMgBkcEQCAAQQhqIABBDGoQOAALEFgiBhBVIgglARACIQEQGSIDIAEmASAIQYQBTwRAIAgQNgsgAyUBIAcoAgAlASAFQQF2EAMgA0GEAU8EQCADEDYLIAZBhAFPBEAgBhA2CyAAQRBqJAAgB0EEaiERIAsoAgAhDEEAIQUjAEEgayILJAACQAJAAkACQCAEKAIIIgAgDE8EQCAEKAIEIQggBEEANgIgIAQoAhhBgPgBTQRAIARBGGpBAEGB+AFBBEEEECcgBCgCICEFCyAEKAIcIg8gBUECdGoiAEEAQYDgB/wLACAEIAVBgfgBaiINNgIgIABBgOAHakEANgIAIAxBAXQhBiAMBEAgBiEDIAghAANAIAAvAQAiCkGA+AFJBEAgCiANTw0EIA8gCkECdGoiCiAKKAIAQQFqNgIACyAAQQJqIQAgA0ECayIDDQALCyAPIA1BAnRqQQhrIgAoAgAhAyAAQQA2AgAgBUEDcUEBRwRAIAVBAWtBA3EhBQNAIABBBGsiACgCACEKIAAgAzYCACALIAMgCmoiAzYCDCAFQQFrIgUNAAsLIABBEGshAANAIABBDGoiBSgCACEKIAUgAzYCACALIAMgCmoiAzYCDCAAQQhqIgUoAgAhCiAFIAM2AgAgCyADIApqIgM2AgwgAEEEaiIFKAIAIQogBSADNgIAIAsgAyAKaiIDNgIMIAAoAgAhBSAAIAM2AgAgCyADIAVqIgM2AgwgACAPRyAAQRBrIQANAAsgDARAIAQoAhAhCiAEKAIUIQVBACEAA0AgCC8BACIEQf/3AU0EQCAEIA1PDQUgDyAEQQJ0aiIEKAIAIgwgBU8NBiAKIAxBAnRqIAA2AgAgBCAEKAIAQQFqNgIACyAIQQJqIQggAEEBaiEAIAZBAmsiBg0ACwsgAyAPKAIARgRAIBFBgICAgHg2AgAgESADNgIEDAULIAsgD61CgICAgNAAhDcDGCALIAtBDGqtQoCAgIDQAIQ3AxAgEUG+gMAAIAtBEGoQHQwECyAMIABBkIzAABAhAAsgCiANQeCLwAAQMAALIAQgDUHwi8AAEDAACyAMIAVBgIzAABAwAAsgC0EgaiQAIAcoAgRBgICAgHhHDQMgBygCCCIARQ0FIAAgDigCGCIDSw0EIA4oAhQhBiAHIBJBACAAEGAiAzYCHCAHQRxqIAYgABAqIANBhAFJDQUgAxA2DAULEDwACxA9AAsgAyAAQaCLwAAQIQALIAdBGGogB0EMaigCADYCACAHIAcpAgQ3AxAgByAHQRBqrUKAgICAwACENwMoIAdBHGogB0EoahAtIAcoAiAgBygCJBBkAAsgACADQZCLwAAQIQALIBBBhAFPBEAgEBA2CyAOIA4oAgBBAWo2AgAgB0EwaiQAIAkoAggiA0GEAU8EQCADEDYLIAkoAgQiA0GEAU8EQCADEDYLIAlBIGokACAACxcBAX8gACgCACIBBEAgACgCBCABEF8LCxQAIAEgASAAIAAgAV0bIAAgAFwbCx8AIABBCGpBtI/AACkCADcCACAAQayPwAApAgA3AgALHwAgAEEIakGkj8AAKQIANwIAIABBnI/AACkCADcCAAsdACAABEAgACABEGYAC0HokMAAQSNB/JDAABA1AAuIAwEKf0G8lcAALQAAQQFHBEACQAJ/AkAgAEUNACAAKAIAIABBADYCAEEBcUUNACAAKAIoIQIgACgCJCEIIAAoAiAhAyAAKAIcIQQgACgCGCEJIAAoAhQhBSAAKAIQIQYgACgCDCEKIAAoAgghByAAKAIEDAELQQIhCkEEIQhBACECQQQhCUEACyEAAkACQAJAQbyVwAAtAABBAWsOAgACAQtBvJXAAEECOgAAQZiVwAAoAgAiAQRAQZyVwAAoAgAgAUEBdBBfC0GklcAAKAIAIgEEQEGolcAAKAIAIAFBAnQQXwtBsJXAACgCACIBRQ0AQbSVwAAoAgAgAUECdBBfC0G8lcAAQQE6AABBuJXAACACNgIAQbSVwAAgCDYCAEGwlcAAIAM2AgBBrJXAACAENgIAQaiVwAAgCTYCAEGklcAAIAU2AgBBoJXAACAGNgIAQZyVwAAgCjYCAEGYlcAAIAc2AgBBlJXAACAANgIADAELQYCAwABB/QBBpIrAABA1AAsLQZSVwAALowIBBH9B0JXAAC0AAEEBRwRAAkACQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQMAQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBgIAQIQNBAAshAAJAAkBB0JXAAC0AAEEBaw4CAAMBC0HQlcAAQQI6AABBxJXAACgCACIERQ0AQciVwAAoAgAgBEECdBBfC0HQlcAAQQE6AABBzJXAACACNgIAQciVwAAgATYCAEHElcAAIAM2AgBBwJXAACAANgIADAILQQRBgIDAABBOAAtBgIDAAEH9AEGkisAAEDUACwtBwJXAAAvOBAERf0GUlsAALQAAQQFHBEACQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjghAyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELIAAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQAhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACEQCwJAAkACQEGUlsAALQAAQQFrDgIAAgELQZSWwABBAjoAAEHYlcAAKAIAIgAEQEHclcAAKAIAIABBAnQQXwtB5JXAACgCACIABEBB6JXAACgCACAAQQJ0EF8LQfCVwAAoAgAiAARAQfSVwAAoAgAgAEECdBBfC0H8lcAAKAIAIgAEQEGAlsAAKAIAIABBAnQQXwtBiJbAACgCACIARQ0AQYyWwAAoAgAgAEECdBBfC0GUlsAAQQE6AABBkJbAACABNgIAQYyWwAAgAjYCAEGIlsAAIAM2AgBBhJbAACAENgIAQYCWwAAgBTYCAEH8lcAAIAY2AgBB+JXAACAHNgIAQfSVwAAgCDYCAEHwlcAAIAk2AgBB7JXAACAKNgIAQeiVwAAgCzYCAEHklcAAIAw2AgBB4JXAACANNgIAQdyVwAAgDjYCAEHYlcAAIA82AgBB1JXAACAQNgIADAELQYCAwABB/QBBpIrAABA1AAsLQdSVwAALHAAgAEEANgIQIABCADcCCCAAQoCAgIDAADcCAAsMACAAQd0AIAEQNQALGAAgASgCACABKAIEIAAoAgAgACgCBBAYCxYBAW8gACUBEAAhARAZIgAgASYBIAALFgAgACgCACABIAIgACgCBCgCDBECAAsUACAAKAIAIAEgACgCBCgCDBEAAAsUAgFvAX8QDiEAEBkiASAAJgEgAQsQACABIAAoAgQgACgCCBAXC98GAQV/An8CQAJAAkACQAJAAkACQCAAQQRrIgcoAgAiCEF4cSIEQQRBCCAIQQNxIgUbIAFqTwRAIAVBACABQSdqIgYgBEkbDQECQCACQQlPBEAgAiADEB4iAg0BQQAMCgtBACECIANBzP97Sw0IQRAgA0ELakF4cSADQQtJGyEBIABBCGshBiAFRQRAIAZFIAFBgAJJciAEIAFrQYCACEsgASAET3JyDQcgAAwKCyAEIAZqIQUCQCABIARLBEAgBUHomcAAKAIARg0BQeSZwAAoAgAgBUcEQCAFKAIEIghBAnENCSAIQXhxIgggBGoiBCABSQ0JIAUgCBAfIAQgAWsiBUEQTwRAIAcgASAHKAIAQQFxckECcjYCACABIAZqIgEgBUEDcjYCBCAEIAZqIgQgBCgCBEEBcjYCBCABIAUQHAwJCyAHIAQgBygCAEEBcXJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgQMCAtB3JnAACgCACAEaiIEIAFJDQgCQCAEIAFrIgVBD00EQCAHIAhBAXEgBHJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgRBACEFQQAhAQwBCyAHIAEgCEEBcXJBAnI2AgAgASAGaiIBIAVBAXI2AgQgBCAGaiIEIAU2AgAgBCAEKAIEQX5xNgIEC0HkmcAAIAE2AgBB3JnAACAFNgIADAcLIAQgAWsiBEEPTQ0GIAcgASAIQQFxckECcjYCACABIAZqIgEgBEEDcjYCBCAFIAUoAgRBAXI2AgQgASAEEBwMBgtB4JnAACgCACAEaiIEIAFLDQQMBgsgAyABIAEgA0sbIgMEQCACIAAgA/wKAAALIAcoAgAiA0F4cSIHIAFBBEEIIANBA3EiAxtqSQ0CIANFIAYgB09yDQZB/I/AAEGskMAAEFMAC0G8j8AAQeyPwAAQUwALQfyPwABBrJDAABBTAAtBvI/AAEHsj8AAEFMACyAHIAEgCEEBcXJBAnI2AgAgASAGaiIFIAQgAWsiAUEBcjYCBEHgmcAAIAE2AgBB6JnAACAFNgIACyAGRQ0AIAAMAwsgAxARIgFFDQEgA0F8QXggBygCACICQQNxGyACQXhxaiICIAIgA0sbIgIEQCABIAAgAvwKAAALIAEhAgsgABAVCyACCwsTACAAQbyQwAA2AgQgACABNgIACxAAIAEgACgCACAAKAIEEFYLEAAgASAAKAIAIAAoAgQQFwsOACAAJQEgASUBIAIQBwtbAQJ/AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMAgtBvI/AAEHsj8AAEFMAC0H8j8AAQayQwAAQUwALCx0BAW8gACgCACUBIAEgAhANIQMQGSIAIAMmASAACw8AIABBzI7AACABIAIQGAsPACAAQYyRwAAgASACEBgLGQACfyABQQlPBEAgASAAEB4MAQsgABARCwsJACAAIAEQDwALDAAgACABKQIANwMACz0BAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQQhqIgAoAgAgACgCBEGolsAAKAIAIgBBEyAAGxEBAAALDQAgAUGcksAAQQUQVgsNACABQb+UwABBGBAXC4ACAQN/IAAoAgAhACMAQRBrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASABQQFBACAAKAIAIANBBmoiABAaIgEgAGpBCiABaxAUDAILIAAoAgAhAkEAIQADQCAAIANqQQ1qIAJBD3EtAKGSQDoAACAAQQFrIQAgAkEPSyACQQR2IQINAAsgAUGtlMAAQQIgACADakEOakEAIABrEBQMAQsgACgCACECQQAhAANAIAAgA2pBDWogAkEPcS0Ar5RAOgAAIABBAWshACACQQ9LIAJBBHYhAg0ACyABQa2UwABBAiAAIANqQQ5qQQAgAGsQFAsgA0EQaiQACwwAQYCawABBAToAAAsJACAAQQA2AgALCAAgACUBEAELCAAgACUBEAULC4kVAwBBgIDAAAuhEUF0dGVtcHRlZCB0byBpbml0aWFsaXplIHRocmVhZC1sb2NhbCB3aGlsZSBpdCBpcyBiZWluZyBkcm9wcGVkCUV4cGVjdGVkIMAXIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCDAABZzbGljZSBpbmRleCBzdGFydHMgYXQgwA0gYnV0IGVuZHMgYXQgwAAgaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyDAEiBidXQgdGhlIGluZGV4IGlzIMAAEnJhbmdlIHN0YXJ0IGluZGV4IMAiIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIMAAEHJhbmdlIGVuZCBpbmRleCDAIiBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCDAABBhc3NlcnRpb24gYGxlZnQgwBcgcmlnaHRgIGZhaWxlZAogIGxlZnQ6IMAJCiByaWdodDogwAAQYXNzZXJ0aW9uIGBsZWZ0IMAQIHJpZ2h0YCBmYWlsZWQ6IMAJCiAgbGVmdDogwAkKIHJpZ2h0OiDAAEhjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiDAAMACOiDAAHNwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAvVXNlcnMvYWFkaWtoYW5uYS8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3RocmVhZF9sb2NhbC9ub190aHJlYWRzLnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvY29yZS9zcmMvZm10L251bS5ycwAvVXNlcnMvYWFkaWtoYW5uYS8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL2xvY2FsLnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjExL3NyYy9kbG1hbGxvYy5ycwBzcGFyay1pbnRlcm5hbC1ycy9zcmMvbGliLnJzAC9Vc2Vycy9hYWRpa2hhbm5hLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9Vc2Vycy9hYWRpa2hhbm5hLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAfQIQAIUAAABrAAAADQAAAAEAAAACAAAAAwAAAPUBEAAgAAAAhQAAACAAAAD1ARAAIAAAAH4AAAAcAAAA9QEQACAAAACAAAAAHAAAAE8DEAB2AAAA3wEAABkAAABPAxAAdgAAAPUCAAAmAAAAQgQQABwAAAAoAAAALQAAAEIEEAAcAAAAHQAAADMAAABCBBAAHAAAAEUAAAAtAAAAQgQQABwAAAA6AAAAMwAAAEIEEAAcAAAAXgAAACgAAAAWAhAAHQAAACQAAAAUAAAAFgIQAB0AAAAzAAAAHQAAABYCEAAdAAAAMwAAABUAAAAWAhAAHQAAABsAAAAdAAAAFgIQAB0AAAB8AAAAGAAAABYCEAAdAAAAfQAAABgAAAAWAhAAHQAAAJAAAAAgAAAAFgIQAB0AAACQAAAAFAAAABYCEAAdAAAAnwAAABMAAAAWAhAAHQAAAKIAAAAdAAAAFgIQAB0AAACiAAAAEQAAABYCEAAdAAAApwAAABMAAAAWAhAAHQAAAHQAAAAZAAAAXwQQAF8AAAD7GAAAAQAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkcmVlbnRyYW50IGluaXS/BBAAYgAAAHoCAAANAAAATGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAC/BBAAYgAAAAgDAAAZAAAAFQAAAAwAAAAEAAAAFgAAABcAAAAYAAAAAAAAAAgAAAAEAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAQAAAABAAAAB4AAAAfAAAAIAAAACEAAABtXcvWLFDrY3hBpldxG4u5ow9nhBrchVEDQO3/txrs6mFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQAABcEEAAqAAAAsQQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAAAXBBAAKgAAALcEAAANAAAAAAAAAAgAAAAEAAAAIgAAAEFjY2Vzc0Vycm9yABUAAAAMAAAABAAAACMAAABjYXBhY2l0eSBvdmVyZmxvdwAAAMYDEABQAAAAHAAAAAUAAAAkAAAADAAAAAQAAAAlAAAAJgAAACcAQayRwAALzAMBAAAAKAAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90AAA0AhAASAAAAIoCAAAOAAAARXJyb3IwMTIzNDU2Nzg5YWJjZGVmAAAAAAAAAAQAAAAEAAAALQAAAH0AAAADAxAASwAAAFcCAAAFAAAAIH09PSE9bWF0Y2hlczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5MHgwMTIzNDU2Nzg5QUJDREVGUmVmQ2VsbCBhbHJlYWR5IGJvcnJvd2VkAFoJEABcCRAAXgkQAAIAAAACAAAABwAAAAAAAD8AAAC/AEGQlcAACwESAHgJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0YyUxLjk0LjAtbmlnaHRseSAoMjg1MGNhODI5IDIwMjYtMDEtMTMpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuBzAuMi4xMDAAaw90YXJnZXRfZmVhdHVyZXMGKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrC2J1bGstbWVtb3J5KwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl");
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance: instance2, module } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance2, module);
}
const LN_SCALE_MIN = -12;
const LN_SCALE_MAX = 9;
const SCALE_MIN = Math.exp(LN_SCALE_MIN);
const SCALE_MAX = Math.exp(LN_SCALE_MAX);
const LN_SCALE_ZERO = -30;
const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);
const SPLAT_TEX_WIDTH_BITS$1 = 11;
const SPLAT_TEX_HEIGHT_BITS$1 = 11;
const SPLAT_TEX_DEPTH_BITS = 11;
const SPLAT_TEX_LAYER_BITS$1 = SPLAT_TEX_WIDTH_BITS$1 + SPLAT_TEX_HEIGHT_BITS$1;
const SPLAT_TEX_WIDTH$1 = 1 << SPLAT_TEX_WIDTH_BITS$1;
const SPLAT_TEX_HEIGHT$1 = 1 << SPLAT_TEX_HEIGHT_BITS$1;
const SPLAT_TEX_DEPTH = 1 << SPLAT_TEX_DEPTH_BITS;
const SPLAT_TEX_MIN_HEIGHT = 1;
const SPLAT_TEX_WIDTH_MASK$1 = SPLAT_TEX_WIDTH$1 - 1;
const SPLAT_TEX_HEIGHT_MASK$1 = SPLAT_TEX_HEIGHT$1 - 1;
const SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1;
const WASM_SPLAT_SORT = true;
const USE_COMPILED_PARSER_FUNCTION = true;
const defines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LN_SCALE_MAX,
  LN_SCALE_MIN,
  LN_SCALE_ZERO,
  SCALE_MAX,
  SCALE_MIN,
  SCALE_ZERO,
  SPLAT_TEX_DEPTH,
  SPLAT_TEX_DEPTH_BITS,
  SPLAT_TEX_DEPTH_MASK,
  SPLAT_TEX_HEIGHT: SPLAT_TEX_HEIGHT$1,
  SPLAT_TEX_HEIGHT_BITS: SPLAT_TEX_HEIGHT_BITS$1,
  SPLAT_TEX_HEIGHT_MASK: SPLAT_TEX_HEIGHT_MASK$1,
  SPLAT_TEX_LAYER_BITS: SPLAT_TEX_LAYER_BITS$1,
  SPLAT_TEX_MIN_HEIGHT,
  SPLAT_TEX_WIDTH: SPLAT_TEX_WIDTH$1,
  SPLAT_TEX_WIDTH_BITS: SPLAT_TEX_WIDTH_BITS$1,
  SPLAT_TEX_WIDTH_MASK: SPLAT_TEX_WIDTH_MASK$1,
  USE_COMPILED_PARSER_FUNCTION,
  WASM_SPLAT_SORT
}, Symbol.toStringTag, { value: "Module" }));
function isBoolType(type) {
  return type === "bool" || type === "bvec2" || type === "bvec3" || type === "bvec4";
}
function isScalarType(type) {
  return type === "int" || type === "uint" || type === "float";
}
function isIntType(type) {
  return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";
}
function isUintType(type) {
  return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";
}
function isFloatType(type) {
  return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";
}
function isMatFloatType(type) {
  return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";
}
function isAllFloatType(type) {
  return isFloatType(type) || isMatFloatType(type);
}
function isVector2Type(type) {
  return type === "vec2" || type === "ivec2" || type === "uvec2";
}
function isVector3Type(type) {
  return type === "vec3" || type === "ivec3" || type === "uvec3";
}
function isVector4Type(type) {
  return type === "vec4" || type === "ivec4" || type === "uvec4";
}
function isVectorType(type) {
  return isVector2Type(type) || isVector3Type(type) || isVector4Type(type);
}
function isMat2(type) {
  return type === "mat2" || type === "mat2x2";
}
function isMat3(type) {
  return type === "mat3" || type === "mat3x3";
}
function isMat4(type) {
  return type === "mat4" || type === "mat4x4";
}
function vectorElementType(type) {
  switch (type) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
function vectorDim(type) {
  switch (type) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
function sameSizeVec(type) {
  if (isScalarType(type)) {
    return "float";
  }
  if (isVector2Type(type)) {
    return "vec2";
  }
  if (isVector3Type(type)) {
    return "vec3";
  }
  if (isVector4Type(type)) {
    return "vec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function sameSizeUvec(type) {
  if (isScalarType(type)) {
    return "uint";
  }
  if (isVector2Type(type)) {
    return "uvec2";
  }
  if (isVector3Type(type)) {
    return "uvec3";
  }
  if (isVector4Type(type)) {
    return "uvec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function sameSizeIvec(type) {
  if (isScalarType(type)) {
    return "int";
  }
  if (isVector2Type(type)) {
    return "ivec2";
  }
  if (isVector3Type(type)) {
    return "ivec3";
  }
  if (isVector4Type(type)) {
    return "ivec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function typeLiteral(type) {
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "object" && type.type) {
    return type.type;
  }
  throw new Error(`Invalid DynoType: ${String(type)}`);
}
function numberAsInt(value) {
  return Math.trunc(value).toString();
}
function numberAsUint(value) {
  const v = Math.max(0, Math.trunc(value));
  return `${v.toString()}u`;
}
function numberAsFloat(value) {
  return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();
}
function valType(val) {
  if (val instanceof DynoValue) {
    return val.type;
  }
  const value = val.dynoOut();
  return value.type;
}
class DynoValue {
  constructor(type) {
    this.__isDynoValue = true;
    this.type = type;
  }
}
class DynoOutput extends DynoValue {
  constructor(dyno2, key) {
    super(dyno2.outTypes[key]);
    this.dyno = dyno2;
    this.key = key;
  }
}
class DynoLiteral extends DynoValue {
  constructor(type, literal) {
    super(type);
    this.literal = literal;
  }
  getLiteral() {
    return this.literal;
  }
}
function dynoLiteral(type, literal) {
  return new DynoLiteral(type, literal);
}
class DynoConst extends DynoLiteral {
  constructor(type, value) {
    super(type, "");
    this.value = value;
  }
  getLiteral() {
    const { type, value } = this;
    switch (type) {
      case "bool":
        return value ? "true" : "false";
      case "uint":
        return numberAsUint(value);
      case "int":
        return numberAsInt(value);
      case "float":
        return numberAsFloat(value);
      case "bvec2": {
        const v = value;
        return `bvec2(${v[0]}, ${v[1]})`;
      }
      case "uvec2": {
        if (value instanceof THREE.Vector2) {
          return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;
        }
        const v = value;
        return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;
      }
      case "ivec2": {
        if (value instanceof THREE.Vector2) {
          return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;
        }
        const v = value;
        return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;
      }
      case "vec2": {
        if (value instanceof THREE.Vector2) {
          return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;
        }
        const v = value;
        return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;
      }
      case "bvec3": {
        const v = value;
        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;
      }
      case "uvec3": {
        if (value instanceof THREE.Vector3) {
          return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;
        }
        const v = value;
        return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;
      }
      case "ivec3": {
        if (value instanceof THREE.Vector3) {
          return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;
        }
        const v = value;
        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;
      }
      case "vec3": {
        if (value instanceof THREE.Vector3) {
          return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;
        }
        const v = value;
        return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;
      }
      case "bvec4": {
        const v = value;
        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;
      }
      case "uvec4": {
        if (value instanceof THREE.Vector4) {
          return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;
        }
        const v = value;
        return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;
      }
      case "ivec4": {
        if (value instanceof THREE.Vector4) {
          return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;
        }
        const v = value;
        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;
      }
      case "vec4": {
        if (value instanceof THREE.Vector4) {
          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;
        }
        if (value instanceof THREE.Quaternion) {
          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;
        }
        const v = value;
        return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const m = value;
        const e = m instanceof THREE.Matrix2 ? m.elements : value;
        const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat2x3": {
        const e = value;
        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat2x4": {
        const e = value;
        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const m = value;
        const e = m instanceof THREE.Matrix3 ? m.elements : value;
        const arg = new Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3x2": {
        const e = value;
        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3x4": {
        const e = value;
        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const m = value;
        const e = m instanceof THREE.Matrix4 ? m.elements : value;
        const arg = new Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4x2": {
        const e = value;
        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4x3": {
        const e = value;
        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(type)}`);
    }
  }
}
function dynoConst(type, value) {
  return new DynoConst(type, value);
}
function literalZero(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(false)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(0.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(0)`;
  }
  if (isUintType(type)) {
    return `${typeString}(0u)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
function literalOne(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(true)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(1.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(1)`;
  }
  if (isUintType(type)) {
    return `${typeString}(1u)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
function literalNegOne(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(true)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(-1.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(-1)`;
  }
  if (isUintType(type)) {
    return `${typeString}(0xFFFFFFFFu)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
const DEFAULT_INDENT = "    ";
class Compilation {
  constructor({ indent } = {}) {
    this.globals = /* @__PURE__ */ new Set();
    this.statements = [];
    this.uniforms = {};
    this.declares = /* @__PURE__ */ new Set();
    this.updaters = [];
    this.sequence = 0;
    this.indent = DEFAULT_INDENT;
    this.indent = indent ?? DEFAULT_INDENT;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class Dyno {
  constructor({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    statements,
    generate
  }) {
    this.inTypes = inTypes ?? {};
    this.outTypes = outTypes ?? {};
    this.inputs = inputs ?? {};
    this.update = update;
    this.globals = globals;
    this.statements = statements;
    this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {
      var _a2, _b2;
      return {
        globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),
        statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })
      };
    });
  }
  get outputs() {
    const outputs = {};
    for (const key in this.outTypes) {
      outputs[key] = new DynoOutput(this, key);
    }
    return outputs;
  }
  apply(inputs) {
    Object.assign(this.inputs, inputs);
    return this.outputs;
  }
  compile({
    inputs,
    outputs,
    compile
  }) {
    const result = [
      `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`
    ];
    const declares = [];
    for (const key in outputs) {
      const name = outputs[key];
      if (name && !compile.declares.has(name)) {
        compile.declares.add(name);
        declares.push(key);
      }
    }
    const { globals, statements, uniforms } = this.generate({
      inputs,
      outputs,
      compile
    });
    for (const global of globals ?? []) {
      compile.globals.add(global);
    }
    for (const key in uniforms) {
      compile.uniforms[key] = uniforms[key];
    }
    if (this.update) {
      compile.updaters.push(this.update);
    }
    for (const key of declares) {
      const name = outputs[key];
      if (name) {
        if (!compile.uniforms[name]) {
          result.push(`${dynoDeclare(name, this.outTypes[key])};`);
        }
      }
    }
    if (statements == null ? void 0 : statements.length) {
      result.push("{");
      result.push(...statements.map((line) => compile.indent + line));
      result.push("}");
    }
    return result;
  }
}
class DynoBlock extends Dyno {
  constructor({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    construct
  }) {
    super({
      inTypes,
      outTypes,
      inputs,
      update,
      globals,
      generate: (args) => this.generateBlock(args)
    });
    this.construct = construct;
  }
  generateBlock({
    inputs,
    outputs,
    compile
  }) {
    var _a2, _b2;
    const blockInputs = {};
    const blockOutputs = {};
    for (const key in inputs) {
      if (inputs[key] != null) {
        blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);
      }
    }
    for (const key in outputs) {
      if (outputs[key] != null) {
        blockOutputs[key] = new DynoValue(this.outTypes[key]);
      }
    }
    const options = { roots: [] };
    const returned = this.construct(blockInputs, blockOutputs, options);
    for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {
      compile.globals.add(global);
    }
    const ordering = [];
    const nodeOuts = /* @__PURE__ */ new Map();
    function visit(node, outKey, outName) {
      let outs = nodeOuts.get(node);
      if (!outs) {
        outs = {
          sequence: compile.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        };
        nodeOuts.set(node, outs);
        for (const key in node.inputs) {
          let input = node.inputs[key];
          while (input) {
            if (input instanceof DynoValue) {
              if (input instanceof DynoOutput) {
                visit(input.dyno, input.key);
              }
              break;
            }
            input = input.dynoOut();
          }
        }
        ordering.push(node);
      }
      if (outKey) {
        if (!outName) {
          outs.newOuts.add(outKey);
        }
        outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);
      }
    }
    for (const root of options.roots) {
      visit(root);
    }
    for (const key in blockOutputs) {
      let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];
      while (value) {
        if (value instanceof DynoValue) {
          if (value instanceof DynoOutput) {
            visit(value.dyno, value.key, outputs[key]);
          }
          break;
        }
        value = value.dynoOut();
      }
      blockOutputs[key] = value;
    }
    const steps = [];
    for (const dyno2 of ordering) {
      const inputs2 = {};
      const outputs2 = {};
      for (const key in dyno2.inputs) {
        let value = dyno2.inputs[key];
        while (value) {
          if (value instanceof DynoValue) {
            if (value instanceof DynoLiteral) {
              inputs2[key] = value.getLiteral();
            } else if (value instanceof DynoOutput) {
              const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);
              if (!source) {
                throw new Error(
                  `Source not found for ${value.dyno.constructor.name}.${value.key}`
                );
              }
              inputs2[key] = source;
            }
            break;
          }
          value = value.dynoOut();
        }
      }
      const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [key, name] of outs.outNames.entries()) {
        outputs2[key] = name;
      }
      const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });
      steps.push(newSteps);
    }
    const literalOutputs = [];
    for (const key in outputs) {
      if (blockOutputs[key] instanceof DynoLiteral) {
        literalOutputs.push(
          `${outputs[key]} = ${blockOutputs[key].getLiteral()};`
        );
      }
    }
    if (literalOutputs.length > 0) {
      steps.push(literalOutputs);
    }
    const statements = steps.flatMap((step2, index) => {
      return index === 0 ? step2 : ["", ...step2];
    });
    return { statements };
  }
}
function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {
  return new DynoBlock({ inTypes, outTypes, construct, update, globals });
}
function dyno$1({
  inTypes,
  outTypes,
  inputs,
  update,
  globals,
  statements,
  generate
}) {
  return new Dyno({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    statements,
    generate
  });
}
function dynoDeclare(name, type, count) {
  const typeStr = typeof type === "string" ? type : type.type;
  if (!typeStr) {
    throw new Error(`Invalid DynoType: ${String(type)}`);
  }
  return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;
}
function unindentLines(s) {
  var _a2;
  let seenNonEmpty = false;
  const lines = s.split("\n").map((line) => {
    const trimmedLine = line.trimEnd();
    if (seenNonEmpty) {
      return trimmedLine;
    }
    if (trimmedLine.length > 0) {
      seenNonEmpty = true;
      return trimmedLine;
    }
    return null;
  }).filter((line) => line != null);
  while (lines.length > 0 && lines[lines.length - 1].length === 0) {
    lines.pop();
  }
  if (lines.length === 0) {
    return [];
  }
  const indent = (_a2 = lines[0].match(/^\s*/)) == null ? void 0 : _a2[0];
  if (!indent) {
    return lines;
  }
  const regex = new RegExp(`^${indent}`);
  return lines.map((line) => line.replace(regex, ""));
}
function unindent(s) {
  return unindentLines(s).join("\n");
}
class UnaryOp extends Dyno {
  constructor({
    a,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a) };
    const outType = outTypeFunc(valType(a));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class BinaryOp extends Dyno {
  constructor({
    a,
    b,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a), b: valType(b) };
    const outType = outTypeFunc(valType(a), valType(b));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a, b } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class TrinaryOp extends Dyno {
  constructor({
    a,
    b,
    c,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a), b: valType(b), c: valType(c) };
    const outType = outTypeFunc(valType(a), valType(b), valType(c));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a, b, c } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
const Gsplat = { type: "Gsplat" };
const TPackedSplats = { type: "PackedSplats" };
const numPackedSplats = (packedSplats) => new NumPackedSplats({ packedSplats });
const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });
const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });
const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });
const combineGsplat = ({
  gsplat,
  flags,
  index,
  center,
  scales,
  quaternion,
  rgba,
  rgb,
  opacity,
  x,
  y,
  z,
  r,
  g,
  b
}) => {
  return new CombineGsplat({
    gsplat,
    flags,
    index,
    center,
    scales,
    quaternion,
    rgba,
    rgb,
    opacity,
    x,
    y,
    z,
    r,
    g,
    b
  });
};
const gsplatNormal = (gsplat) => new GsplatNormal({ gsplat });
const transformGsplat = (gsplat, {
  scale,
  rotate: rotate2,
  translate,
  recolor
}) => {
  return new TransformGsplat({ gsplat, scale, rotate: rotate2, translate, recolor });
};
const defineGsplat = unindent(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`);
const definePackedSplats = unindent(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
    vec4 rgbMinMaxLnScaleMinMax;
  };
`);
class NumPackedSplats extends UnaryOp {
  constructor({
    packedSplats
  }) {
    super({ a: packedSplats, outKey: "numSplats", outTypeFunc: () => "int" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.numSplats} = ${inputs.a}.numSplats;`
    ];
  }
}
const defineReadPackedSplat = unindent(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);
class ReadPackedSplat extends Dyno {
  constructor({
    packedSplats,
    index
  }) {
    super({
      inTypes: { packedSplats: TPackedSplats, index: "int" },
      outTypes: { gsplat: Gsplat },
      inputs: { packedSplats, index },
      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat } = outputs;
        if (!gsplat) {
          return [];
        }
        const { packedSplats: packedSplats2, index: index2 } = inputs;
        let statements;
        if (packedSplats2 && index2) {
          statements = unindentLines(`
            if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${gsplat}.flags = 0u;
            }
          `);
        } else {
          statements = [`${gsplat}.flags = 0u;`];
        }
        statements.push(`${gsplat}.index = ${index2 ?? "0"};`);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
class ReadPackedSplatRange extends Dyno {
  constructor({
    packedSplats,
    index,
    base,
    count
  }) {
    super({
      inTypes: {
        packedSplats: TPackedSplats,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: Gsplat },
      inputs: { packedSplats, index, base, count },
      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat } = outputs;
        if (!gsplat) {
          return [];
        }
        const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;
        let statements;
        if (packedSplats2 && index2 && base2 && count2) {
          statements = unindentLines(`
            ${gsplat}.flags = 0u;
            if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) {
              if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `);
        } else {
          statements = [`${gsplat}.flags = 0u;`];
        }
        statements.push(`${gsplat}.index = ${index2 ?? "0"};`);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
class SplitGsplat extends Dyno {
  constructor({ gsplat }) {
    super({
      inTypes: { gsplat: Gsplat },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat: gsplat2 } = inputs;
        const {
          flags,
          active,
          index,
          center,
          scales,
          quaternion,
          rgba,
          rgb,
          opacity,
          x,
          y,
          z,
          r,
          g,
          b
        } = outputs;
        return [
          !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,
          !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,
          !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,
          !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,
          !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,
          !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,
          !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,
          !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,
          !x ? null : `${x} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,
          !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,
          !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,
          !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,
          !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,
          !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`
        ].filter(Boolean);
      }
    });
  }
}
class CombineGsplat extends Dyno {
  constructor({
    gsplat,
    flags,
    index,
    center,
    scales,
    quaternion,
    rgba,
    rgb,
    opacity,
    x,
    y,
    z,
    r,
    g,
    b
  }) {
    super({
      inTypes: {
        gsplat: Gsplat,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: Gsplat },
      inputs: {
        gsplat,
        flags,
        index,
        center,
        scales,
        quaternion,
        rgba,
        rgb,
        opacity,
        x,
        y,
        z,
        r,
        g,
        b
      },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat: outGsplat } = outputs;
        if (!outGsplat) {
          return [];
        }
        const {
          gsplat: gsplat2,
          flags: flags2,
          index: index2,
          center: center2,
          scales: scales2,
          quaternion: quaternion2,
          rgba: rgba2,
          rgb: rgb2,
          opacity: opacity2,
          x: x2,
          y: y2,
          z: z2,
          r: r2,
          g: g2,
          b: b22
        } = inputs;
        return [
          `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,
          `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,
          `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,
          !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,
          !x2 ? null : `${outGsplat}.center.x = ${x2};`,
          !y2 ? null : `${outGsplat}.center.y = ${y2};`,
          !z2 ? null : `${outGsplat}.center.z = ${z2};`,
          !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,
          !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,
          !b22 ? null : `${outGsplat}.rgba.b = ${b22};`
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
const defineGsplatNormal = unindent(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class GsplatNormal extends UnaryOp {
  constructor({ gsplat }) {
    super({ a: gsplat, outKey: "normal", outTypeFunc: () => "vec3" });
    this.globals = () => [defineGsplat, defineGsplatNormal];
    this.statements = ({ inputs, outputs }) => [
      `${outputs.normal} = gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`
    ];
  }
}
class TransformGsplat extends Dyno {
  constructor({
    gsplat,
    scale,
    rotate: rotate2,
    translate,
    recolor
  }) {
    super({
      inTypes: {
        gsplat: Gsplat,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: Gsplat },
      inputs: { gsplat, scale, rotate: rotate2, translate, recolor },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs, compile }) => {
        const { gsplat: gsplat2 } = outputs;
        if (!gsplat2 || !inputs.gsplat) {
          return [];
        }
        const { scale: scale2, rotate: rotate22, translate: translate2, recolor: recolor2 } = inputs;
        const indent = compile.indent;
        const statements = [
          `${gsplat2} = ${inputs.gsplat};`,
          `if (isGsplatActive(${gsplat2}.flags)) {`,
          scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,
          rotate22 ? `${indent}${gsplat2}.center = quatVec(${rotate22}, ${gsplat2}.center);` : null,
          translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,
          scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,
          rotate22 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate22}, ${gsplat2}.quaternion);` : null,
          recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,
          "}"
        ].filter(Boolean);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
const outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });
const outputRgba8 = (rgba8) => new OutputRgba8({ rgba8 });
class OutputPackedSplat extends Dyno {
  constructor({
    gsplat,
    rgbMinMaxLnScaleMinMax
  }) {
    super({
      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: "vec4" },
      inputs: { gsplat, rgbMinMaxLnScaleMinMax },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { output: output2 } = outputs;
        if (!output2) {
          return [];
        }
        const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: rgbMinMaxLnScaleMinMax2 } = inputs;
        if (gsplat2) {
          return unindentLines(`
            if (isGsplatActive(${gsplat2}.flags)) {
              ${output2} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});
            } else {
              ${output2} = uvec4(0u, 0u, 0u, 0u);
            }
          `);
        }
        return [`${output2} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "output");
  }
}
class OutputRgba8 extends Dyno {
  constructor({ rgba8 }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8 },
      statements: ({ inputs, outputs }) => [
        `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "rgba8");
  }
}
const uniform$3 = (key, type, value) => new DynoUniform({ key, type, value });
const dynoBool = (value = false, key) => new DynoBool({ key, value });
const dynoUint = (value = 0, key) => new DynoUint({ key, value });
const dynoInt = (value = 0, key) => new DynoInt({ key, value });
const dynoFloat = (value = 0, key) => new DynoFloat({ key, value });
const dynoBvec2 = (value, key) => new DynoBvec2({ key, value });
const dynoUvec2 = (value, key) => new DynoUvec2({ key, value });
const dynoIvec2 = (value, key) => new DynoIvec2({ key, value });
const dynoVec2 = (value, key) => new DynoVec2({ key, value });
const dynoBvec3 = (value, key) => new DynoBvec3({ key, value });
const dynoUvec3 = (value, key) => new DynoUvec3({ key, value });
const dynoIvec3 = (value, key) => new DynoIvec3({ key, value });
const dynoVec3 = (value, key) => new DynoVec3({ key, value });
const dynoBvec4 = (value, key) => new DynoBvec4({ key, value });
const dynoUvec4 = (value, key) => new DynoUvec4({ key, value });
const dynoIvec4 = (value, key) => new DynoIvec4({ key, value });
const dynoVec4 = (value, key) => new DynoVec4({ key, value });
const dynoMat2 = (value, key) => new DynoMat2({ key, value });
const dynoMat2x2 = (value, key) => new DynoMat2x2({ key, value });
const dynoMat2x3 = (value, key) => new DynoMat2x3({ key, value });
const dynoMat2x4 = (value, key) => new DynoMat2x4({ key, value });
const dynoMat3 = (value, key) => new DynoMat3({ key, value });
const dynoMat3x2 = (value, key) => new DynoMat3x2({ key, value });
const dynoMat3x3 = (value, key) => new DynoMat3x3({ key, value });
const dynoMat3x4 = (value, key) => new DynoMat3x4({ key, value });
const dynoMat4 = (value, key) => new DynoMat4({ key, value });
const dynoMat4x2 = (value, key) => new DynoMat4x2({ key, value });
const dynoMat4x3 = (value, key) => new DynoMat4x3({ key, value });
const dynoMat4x4 = (value, key) => new DynoMat4x4({ key, value });
const dynoUsampler2D = (value, key) => new DynoUsampler2D({ key, value });
const dynoIsampler2D = (value, key) => new DynoIsampler2D({ key, value });
const dynoSampler2D = (value, key) => new DynoSampler2D({ key, value });
const dynoUsampler2DArray = (value, key) => new DynoUsampler2DArray({ key, value });
const dynoIsampler2DArray = (key, value) => new DynoIsampler2DArray({ key, value });
const dynoSampler2DArray = (value, key) => new DynoSampler2DArray({ key, value });
const dynoUsampler3D = (value, key) => new DynoUsampler3D({ key, value });
const dynoIsampler3D = (value, key) => new DynoIsampler3D({ key, value });
const dynoSampler3D = (value, key) => new DynoSampler3D({ key, value });
const dynoUsamplerCube = (value, key) => new DynoUsamplerCube({ key, value });
const dynoIsamplerCube = (value, key) => new DynoIsamplerCube({ key, value });
const dynoSamplerCube = (value, key) => new DynoSamplerCube({ key, value });
const dynoSampler2DShadow = (value, key) => new DynoSampler2DShadow({ key, value });
const dynoSampler2DArrayShadow = (value, key) => new DynoSampler2DArrayShadow({ key, value });
const dynoSamplerCubeShadow = (value, key) => new DynoSamplerCubeShadow({ key, value });
class DynoUniform extends Dyno {
  constructor({
    key,
    type,
    count,
    value,
    update,
    globals
  }) {
    key = key ?? "value";
    super({
      outTypes: { [key]: type },
      update: () => {
        if (update) {
          const value2 = update(this.value);
          if (value2 !== void 0) {
            this.value = value2;
          }
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs, outputs }) => {
        const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];
        const uniforms = {};
        const name = outputs[key];
        if (name) {
          allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);
          uniforms[name] = this.uniform;
        }
        return { globals: allGlobals, uniforms };
      }
    });
    this.type = type;
    this.count = count;
    this.value = value;
    this.uniform = { value };
    this.outKey = key;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class DynoBool extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bool", value, update });
  }
}
class DynoUint extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uint", value, update });
  }
}
class DynoInt extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "int", value, update });
  }
}
class DynoFloat extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "float", value, update });
  }
}
class DynoBvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec2", value, update });
  }
}
class DynoUvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec2", value, update });
  }
}
class DynoIvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec2", value, update });
  }
}
class DynoVec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec2", value, update });
  }
}
class DynoBvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec3", value, update });
  }
}
class DynoUvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec3", value, update });
  }
}
class DynoIvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec3", value, update });
  }
}
class DynoVec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec3", value, update });
  }
}
class DynoBvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec4", value, update });
  }
}
class DynoUvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec4", value, update });
  }
}
class DynoIvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec4", value, update });
  }
}
class DynoVec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec4", value, update });
  }
}
class DynoMat2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2", value, update });
  }
}
class DynoMat2x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x2", value, update });
  }
}
class DynoMat2x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x3", value, update });
  }
}
class DynoMat2x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x4", value, update });
  }
}
class DynoMat3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3", value, update });
  }
}
class DynoMat3x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x2", value, update });
  }
}
class DynoMat3x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x3", value, update });
  }
}
class DynoMat3x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x4", value, update });
  }
}
class DynoMat4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4", value, update });
  }
}
class DynoMat4x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x2", value, update });
  }
}
class DynoMat4x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x3", value, update });
  }
}
class DynoMat4x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x4", value, update });
  }
}
class DynoUsampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler2D", value, update });
  }
}
class DynoIsampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler2D", value, update });
  }
}
class DynoSampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2D", value, update });
  }
}
class DynoUsampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler2DArray", value, update });
  }
}
class DynoIsampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler2DArray", value, update });
  }
}
class DynoSampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DArray", value, update });
  }
}
class DynoUsampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler3D", value, update });
  }
}
class DynoIsampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler3D", value, update });
  }
}
class DynoSampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler3D", value, update });
  }
}
class DynoUsamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usamplerCube", value, update });
  }
}
class DynoIsamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isamplerCube", value, update });
  }
}
class DynoSamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "samplerCube", value, update });
  }
}
class DynoSampler2DShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DShadow", value, update });
  }
}
class DynoSampler2DArrayShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DArrayShadow", value, update });
  }
}
class DynoSamplerCubeShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "samplerCubeShadow", value, update });
  }
}
const f32buffer = new Float32Array(1);
const u32buffer = new Uint32Array(f32buffer.buffer);
const supportsFloat16Array = "Float16Array" in globalThis;
const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;
const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);
function normalize$4(vec) {
  const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));
  return vec.map((v) => v / norm);
}
function floatBitsToUint$2(f) {
  f32buffer[0] = f;
  return u32buffer[0];
}
function uintBitsToFloat$2(u) {
  u32buffer[0] = u;
  return f32buffer[0];
}
const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;
const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;
function toHalfNative(f) {
  f16buffer[0] = f;
  return u16buffer[0];
}
function toHalfJS(f) {
  f32buffer[0] = f;
  const bits2 = u32buffer[0];
  const sign2 = bits2 >> 31 & 1;
  const exp3 = bits2 >> 23 & 255;
  const frac = bits2 & 8388607;
  const halfSign = sign2 << 15;
  if (exp3 === 255) {
    if (frac !== 0) {
      return halfSign | 32767;
    }
    return halfSign | 31744;
  }
  const newExp = exp3 - 127 + 15;
  if (newExp >= 31) {
    return halfSign | 31744;
  }
  if (newExp <= 0) {
    if (newExp < -10) {
      return halfSign;
    }
    const subFrac = (frac | 8388608) >> 1 - newExp + 13;
    return halfSign | subFrac;
  }
  const halfFrac = frac >> 13;
  return halfSign | newExp << 10 | halfFrac;
}
function fromHalfNative(u) {
  u16buffer[0] = u;
  return f16buffer[0];
}
function fromHalfJS(h) {
  const sign2 = h >> 15 & 1;
  const exp3 = h >> 10 & 31;
  const frac = h & 1023;
  let f32bits;
  if (exp3 === 0) {
    if (frac === 0) {
      f32bits = sign2 << 31;
    } else {
      let mant = frac;
      let e = -14;
      while ((mant & 1024) === 0) {
        mant <<= 1;
        e--;
      }
      mant &= 1023;
      const newExp = e + 127;
      const newFrac = mant << 13;
      f32bits = sign2 << 31 | newExp << 23 | newFrac;
    }
  } else if (exp3 === 31) {
    if (frac === 0) {
      f32bits = sign2 << 31 | 2139095040;
    } else {
      f32bits = sign2 << 31 | 2143289344;
    }
  } else {
    const newExp = exp3 - 15 + 127;
    const newFrac = frac << 13;
    f32bits = sign2 << 31 | newExp << 23 | newFrac;
  }
  u32buffer[0] = f32bits;
  return f32buffer[0];
}
function floatToUint8(v) {
  return Math.max(0, Math.min(255, Math.round(v * 255)));
}
function floatToSint8(v) {
  return Math.max(-127, Math.min(127, Math.round(v * 127)));
}
function Uint8ToFloat(v) {
  return v / 255;
}
function Sint8ToFloat(v) {
  return v / 127;
}
class DataCache {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch,
    maxItems = 5
  }) {
    this.asyncFetch = asyncFetch;
    this.maxItems = maxItems;
    this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(key) {
    const index = this.items.findIndex((item) => item.key === key);
    if (index >= 0) {
      const item = this.items.splice(index, 1)[0];
      this.items.push(item);
      return item.data;
    }
    const data = await this.asyncFetch(key);
    this.items.push({ key, data });
    while (this.items.length > this.maxItems) {
      this.items.shift();
    }
    return data;
  }
}
function mapObject(obj, fn) {
  const entries = Object.entries(obj).map(([key, value]) => [
    key,
    fn(value, key)
  ]);
  return Object.fromEntries(entries);
}
function mapFilterObject(obj, fn) {
  const entries = Object.entries(obj).map(([key, value]) => [key, fn(value, key)]).filter(([_, value]) => value !== void 0);
  return Object.fromEntries(entries);
}
function getArrayBuffers(ctx) {
  const buffers = [];
  const seen = /* @__PURE__ */ new Set();
  function traverse(obj) {
    if (obj && typeof obj === "object" && !seen.has(obj)) {
      seen.add(obj);
      if (obj instanceof ArrayBuffer) {
        buffers.push(obj);
      } else if (ArrayBuffer.isView(obj)) {
        buffers.push(obj.buffer);
      } else if (Array.isArray(obj)) {
        obj.forEach(traverse);
      } else {
        Object.values(obj).forEach(traverse);
      }
    }
  }
  traverse(ctx);
  return buffers;
}
function newArray(n, initFunction) {
  return new Array(n).fill(null).map((_, i) => initFunction(i));
}
class FreeList {
  constructor({
    // Allocate a new item with the given args
    allocate,
    // Dispose of an item (optional, if GC is enough)
    dispose,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid
  }) {
    this.items = [];
    this.allocate = allocate;
    this.dispose = dispose;
    this.valid = valid;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(args) {
    while (true) {
      const item = this.items.pop();
      if (!item) {
        break;
      }
      if (this.valid(item, args)) {
        return item;
      }
      if (this.dispose) {
        this.dispose(item);
      }
    }
    return this.allocate(args);
  }
  free(item) {
    this.items.push(item);
  }
  disposeAll() {
    let item;
    item = this.items.pop();
    while (item) {
      if (this.dispose) {
        this.dispose(item);
      }
      item = this.items.pop();
    }
  }
}
function setPackedSplat(packedSplats, index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const uA = floatToUint8(opacity);
  const uQuat = encodeQuatOctXy88R8(
    tempQuaternion.set(quatX, quatY, quatZ, quatW)
  );
  const uQuatX = uQuat & 255;
  const uQuatY = uQuat >>> 8 & 255;
  const uQuatZ = uQuat >>> 16 & 255;
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uCenterX = toHalf(x);
  const uCenterY = toHalf(y);
  const uCenterZ = toHalf(z);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
  packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;
  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;
}
function setPackedSplatCenter(packedSplats, index, x, y, z) {
  const uCenterX = toHalf(x);
  const uCenterY = toHalf(y);
  const uCenterZ = toHalf(z);
  const i4 = index * 4;
  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
  packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;
}
function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const i4 = index * 4;
  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;
}
const tempQuaternion = new THREE.Quaternion();
function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {
  const uQuat = encodeQuatOctXy88R8(
    tempQuaternion.set(quatX, quatY, quatZ, quatW)
  );
  const uQuatX = uQuat & 255;
  const uQuatY = uQuat >>> 8 & 255;
  const uQuatZ = uQuat >>> 16 & 255;
  const i4 = index * 4;
  packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;
  packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;
}
function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const uA = floatToUint8(a);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
}
function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;
}
function setPackedSplatOpacity(packedSplats, index, opacity) {
  const uA = floatToUint8(opacity);
  const i4 = index * 4;
  packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;
}
const packedCenter = new THREE.Vector3();
const packedScales = new THREE.Vector3();
const packedQuaternion = new THREE.Quaternion();
const packedColor = new THREE.Color();
const packedFields = {
  center: packedCenter,
  scales: packedScales,
  quaternion: packedQuaternion,
  color: packedColor,
  opacity: 0
};
function unpackSplat(packedSplats, index, encoding) {
  const result = packedFields;
  const i4 = index * 4;
  const word0 = packedSplats[i4];
  const word1 = packedSplats[i4 + 1];
  const word2 = packedSplats[i4 + 2];
  const word3 = packedSplats[i4 + 3];
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  result.color.set(
    rgbMin + (word0 & 255) / 255 * rgbRange,
    rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,
    rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange
  );
  result.opacity = (word0 >>> 24 & 255) / 255;
  result.center.set(
    fromHalf(word1 & 65535),
    fromHalf(word1 >>> 16 & 65535),
    fromHalf(word2 & 65535)
  );
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = (lnScaleMax - lnScaleMin) / 254;
  const uScalesX = word3 & 255;
  result.scales.x = uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);
  const uScalesY = word3 >>> 8 & 255;
  result.scales.y = uScalesY === 0 ? 0 : Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);
  const uScalesZ = word3 >>> 16 & 255;
  result.scales.z = uScalesZ === 0 ? 0 : Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);
  const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;
  decodeQuatOctXy88R8$1(uQuat, result.quaternion);
  return result;
}
function getTextureSize(numSplats) {
  const width = SPLAT_TEX_WIDTH$1;
  const height = Math.max(
    SPLAT_TEX_MIN_HEIGHT,
    Math.min(SPLAT_TEX_HEIGHT$1, Math.ceil(numSplats / width))
  );
  const depth2 = Math.ceil(numSplats / (width * height));
  const maxSplats = width * height * depth2;
  return { width, height, depth: depth2, maxSplats };
}
function computeMaxSplats(numSplats) {
  const width = SPLAT_TEX_WIDTH$1;
  const height = Math.max(
    SPLAT_TEX_MIN_HEIGHT,
    Math.min(SPLAT_TEX_HEIGHT$1, Math.ceil(numSplats / width))
  );
  const depth2 = Math.ceil(numSplats / (width * height));
  return width * height * depth2;
}
function isMobile() {
  if (navigator.maxTouchPoints > 0) {
    return true;
  }
  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function isAndroid() {
  return /Android/.test(navigator.userAgent);
}
function isOculus() {
  return /Oculus/.test(navigator.userAgent);
}
function flipPixels(pixels, width, height) {
  const tempLine = new Uint8Array(width * 4);
  for (let y = 0; y < height / 2; y++) {
    const topOffset = y * width * 4;
    const bottomOffset = (height - 1 - y) * width * 4;
    tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));
    pixels.set(
      pixels.subarray(bottomOffset, bottomOffset + width * 4),
      topOffset
    );
    pixels.set(tempLine, bottomOffset);
  }
  return pixels;
}
function pixelsToPngUrl(pixels, width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Can't get 2d context");
  }
  const imageData = ctx.createImageData(width, height);
  imageData.data.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  return canvas.toDataURL("image/png");
}
function cloneClock(clock) {
  const newClock = new THREE.Clock(clock.autoStart);
  newClock.startTime = clock.startTime;
  newClock.oldTime = clock.oldTime;
  newClock.elapsedTime = clock.elapsedTime;
  newClock.running = clock.running;
  return newClock;
}
function omitUndefined(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, value]) => value !== void 0)
  );
}
const IDENT_VERTEX_SHADER = unindent(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function averagePositions(positions) {
  const sum = new THREE.Vector3();
  for (const position of positions) {
    sum.add(position);
  }
  return sum.divideScalar(positions.length);
}
function averageQuaternions(quaternions) {
  if (quaternions.length === 0) {
    return new THREE.Quaternion();
  }
  const sum = quaternions[0].clone();
  for (let i = 1; i < quaternions.length; i++) {
    if (quaternions[i].dot(quaternions[0]) < 0) {
      sum.x -= quaternions[i].x;
      sum.y -= quaternions[i].y;
      sum.z -= quaternions[i].z;
      sum.w -= quaternions[i].w;
    } else {
      sum.x += quaternions[i].x;
      sum.y += quaternions[i].y;
      sum.z += quaternions[i].z;
      sum.w += quaternions[i].w;
    }
  }
  return sum.normalize();
}
function coinciDist(matrix1, matrix2) {
  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);
  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);
  const direction1 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix1).sub(origin1).normalize();
  const direction2 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix2).sub(origin2).normalize();
  const distance2 = origin1.distanceTo(origin2);
  const coincidence = direction1.dot(direction2);
  return { distance: distance2, coincidence };
}
function withinDist({
  matrix1,
  matrix2,
  maxDistance
}) {
  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);
  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);
  return origin1.distanceTo(origin2) <= maxDistance;
}
function withinCoinciDist({
  matrix1,
  matrix2,
  maxDistance,
  minCoincidence
}) {
  const { distance: distance2, coincidence } = coinciDist(matrix1, matrix2);
  return distance2 <= maxDistance && (minCoincidence == null || coincidence >= minCoincidence);
}
function coorientDist(matrix1, matrix2) {
  const [origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];
  const [origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];
  matrix1.decompose(origin1, rotate1, new THREE.Vector3());
  matrix2.decompose(origin2, rotate2, new THREE.Vector3());
  const distance2 = origin1.distanceTo(origin2);
  const coorient = Math.abs(rotate1.dot(rotate2));
  return { distance: distance2, coorient };
}
function withinCoorientDist({
  matrix1,
  matrix2,
  maxDistance,
  minCoorient
}) {
  const { distance: distance2, coorient } = coorientDist(matrix1, matrix2);
  return distance2 <= maxDistance && (minCoorient == null || coorient >= minCoorient);
}
function epsilonSign(value, epsilon = 1e-3) {
  if (Math.abs(value) < epsilon) {
    return 0;
  }
  return Math.sign(value);
}
function encodeQuatXyz888(q) {
  const negQuat = q.w < 0;
  const iQuatX = floatToSint8(negQuat ? -q.x : q.x);
  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);
  const iQuatZ = floatToSint8(negQuat ? -q.z : q.z);
  const uQuatX = iQuatX & 255;
  const uQuatY = iQuatY & 255;
  const uQuatZ = iQuatZ & 255;
  return uQuatX | uQuatY << 8 | uQuatZ << 16;
}
function decodeQuatXyz888(encoded, out) {
  const iQuatX = encoded << 24 >> 24;
  const iQuatY = encoded << 16 >> 24;
  const iQuatZ = encoded << 8 >> 24;
  out.set(iQuatX / 127, iQuatY / 127, iQuatZ / 127, 0);
  const dotSelf = out.x * out.x + out.y * out.y + out.z * out.z;
  out.w = Math.sqrt(Math.max(0, 1 - dotSelf));
  return out;
}
const tempNormalizedQuaternion = new THREE.Quaternion();
const tempAxis = new THREE.Vector3();
function encodeQuatOctXy88R8(q) {
  const qnorm = tempNormalizedQuaternion.copy(q).normalize();
  if (qnorm.w < 0) {
    qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);
  }
  const theta = 2 * Math.acos(qnorm.w);
  const xyz_norm = Math.sqrt(
    qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z
  );
  const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);
  const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);
  let p_x = axis.x / sum;
  let p_y = axis.y / sum;
  if (axis.z < 0) {
    const tmp = p_x;
    p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);
    p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);
  }
  const u_f = p_x * 0.5 + 0.5;
  const v_f = p_y * 0.5 + 0.5;
  const quantU = Math.round(u_f * 255);
  const quantV = Math.round(v_f * 255);
  const angleInt = Math.round(theta * (255 / Math.PI));
  return angleInt << 16 | quantV << 8 | quantU;
}
function decodeQuatOctXy88R8$1(encoded, out) {
  const quantU = encoded & 255;
  const quantV = encoded >>> 8 & 255;
  const angleInt = encoded >>> 16 & 255;
  const u_f = quantU / 255;
  const v_f = quantV / 255;
  let f_x = (u_f - 0.5) * 2;
  let f_y = (v_f - 0.5) * 2;
  const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));
  const t = Math.max(-f_z, 0);
  f_x += f_x >= 0 ? -t : t;
  f_y += f_y >= 0 ? -t : t;
  const axis = tempAxis.set(f_x, f_y, f_z).normalize();
  const theta = angleInt / 255 * Math.PI;
  const halfTheta = theta * 0.5;
  const s = Math.sin(halfTheta);
  const w = Math.cos(halfTheta);
  out.set(axis.x * s, axis.y * s, axis.z * s, w);
  return out;
}
function encodeQuatEulerXyz888(q) {
  const qNorm = q.clone().normalize();
  const sinr_cosp = 2 * (qNorm.w * qNorm.x + qNorm.y * qNorm.z);
  const cosr_cosp = 1 - 2 * (qNorm.x * qNorm.x + qNorm.y * qNorm.y);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);
  const sinp = 2 * (qNorm.w * qNorm.y - qNorm.z * qNorm.x);
  const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);
  const siny_cosp = 2 * (qNorm.w * qNorm.z + qNorm.x * qNorm.y);
  const cosy_cosp = 1 - 2 * (qNorm.y * qNorm.y + qNorm.z * qNorm.z);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);
  const normRoll = (roll + Math.PI) / (2 * Math.PI);
  const normPitch = (pitch + Math.PI) / (2 * Math.PI);
  const normYaw = (yaw + Math.PI) / (2 * Math.PI);
  const rollQ = Math.round(normRoll * 255);
  const pitchQ = Math.round(normPitch * 255);
  const yawQ = Math.round(normYaw * 255);
  return yawQ << 16 | pitchQ << 8 | rollQ;
}
function decodeQuatEulerXyz888(encoded, out) {
  const rollQ = encoded & 255;
  const pitchQ = encoded >>> 8 & 255;
  const yawQ = encoded >>> 16 & 255;
  const normRoll = rollQ / 255;
  const normPitch = pitchQ / 255;
  const normYaw = yawQ / 255;
  const roll = normRoll * (2 * Math.PI) - Math.PI;
  const pitch = normPitch * (2 * Math.PI) - Math.PI;
  const yaw = normYaw * (2 * Math.PI) - Math.PI;
  const cr = Math.cos(roll * 0.5);
  const sr = Math.sin(roll * 0.5);
  const cp = Math.cos(pitch * 0.5);
  const sp = Math.sin(pitch * 0.5);
  const cy = Math.cos(yaw * 0.5);
  const sy = Math.sin(yaw * 0.5);
  out.w = cr * cp * cy + sr * sp * sy;
  out.x = sr * cp * cy - cr * sp * sy;
  out.y = cr * sp * cy + sr * cp * sy;
  out.z = cr * cp * sy - sr * sp * cy;
  out.normalize();
  return out;
}
function packSint8Bytes(b0, b1, b22, b3) {
  const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));
  const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));
  const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));
  const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));
  return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;
}
function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {
  const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;
  const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;
  const sh1Mid = 0.5 * (sh1Min + sh1Max);
  const sh1Scale = 126 / (sh1Max - sh1Min);
  const base = index * 2;
  for (let i = 0; i < 9; ++i) {
    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;
    const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;
    const bitStart = i * 7;
    const bitEnd = bitStart + 7;
    const wordStart = Math.floor(bitStart / 32);
    const bitOffset = bitStart - wordStart * 32;
    const firstWord = value << bitOffset & 4294967295;
    sh1Array[base + wordStart] |= firstWord;
    if (bitEnd > wordStart * 32 + 32) {
      const secondWord = value >>> 32 - bitOffset & 4294967295;
      sh1Array[base + wordStart + 1] |= secondWord;
    }
  }
}
function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {
  const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;
  const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;
  const sh2Mid = 0.5 * (sh2Min + sh2Max);
  const sh2Scale = 2 / (sh2Max - sh2Min);
  sh2Array[index * 4 + 0] = packSint8Bytes(
    (sh2Rgb[0] - sh2Mid) * sh2Scale,
    (sh2Rgb[1] - sh2Mid) * sh2Scale,
    (sh2Rgb[2] - sh2Mid) * sh2Scale,
    (sh2Rgb[3] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 1] = packSint8Bytes(
    (sh2Rgb[4] - sh2Mid) * sh2Scale,
    (sh2Rgb[5] - sh2Mid) * sh2Scale,
    (sh2Rgb[6] - sh2Mid) * sh2Scale,
    (sh2Rgb[7] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 2] = packSint8Bytes(
    (sh2Rgb[8] - sh2Mid) * sh2Scale,
    (sh2Rgb[9] - sh2Mid) * sh2Scale,
    (sh2Rgb[10] - sh2Mid) * sh2Scale,
    (sh2Rgb[11] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 3] = packSint8Bytes(
    (sh2Rgb[12] - sh2Mid) * sh2Scale,
    (sh2Rgb[13] - sh2Mid) * sh2Scale,
    (sh2Rgb[14] - sh2Mid) * sh2Scale,
    0
  );
}
function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {
  const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;
  const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;
  const sh3Mid = 0.5 * (sh3Min + sh3Max);
  const sh3Scale = 62 / (sh3Max - sh3Min);
  const base = index * 4;
  for (let i = 0; i < 21; ++i) {
    const s = (sh3Rgb[i] - sh3Mid) * sh3Scale;
    const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;
    const bitStart = i * 6;
    const bitEnd = bitStart + 6;
    const wordStart = Math.floor(bitStart / 32);
    const bitOffset = bitStart - wordStart * 32;
    const firstWord = value << bitOffset & 4294967295;
    sh3Array[base + wordStart] |= firstWord;
    if (bitEnd > wordStart * 32 + 32) {
      const secondWord = value >>> 32 - bitOffset & 4294967295;
      sh3Array[base + wordStart + 1] |= secondWord;
    }
  }
}
function decompressPartialGzip(fileBytes, numBytes) {
  const chunks = [];
  let totalBytes = 0;
  let result = null;
  const gunzip = new Gunzip((data, final) => {
    chunks.push(data);
    totalBytes += data.length;
    if (final || totalBytes >= numBytes) {
      const allBytes = new Uint8Array(totalBytes);
      let offset2 = 0;
      for (const chunk of chunks) {
        allBytes.set(chunk, offset2);
        offset2 += chunk.length;
      }
      result = allBytes.slice(0, numBytes);
    }
  });
  const CHUNK_SIZE = 1024;
  let offset = 0;
  while (result == null && offset < fileBytes.length) {
    const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);
    gunzip.push(chunk, false);
    offset += CHUNK_SIZE;
  }
  if (result == null) {
    gunzip.push(new Uint8Array(), true);
    if (result == null) {
      throw new Error("Failed to decompress partial gzip");
    }
  }
  return result;
}
class GunzipReader {
  constructor({
    fileBytes,
    chunkBytes = 64 * 1024
  }) {
    this.fileBytes = fileBytes;
    this.chunkBytes = chunkBytes;
    this.chunks = [];
    this.totalBytes = 0;
    const ds = new DecompressionStream("gzip");
    const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);
    this.reader = decompressionStream.getReader();
  }
  async read(numBytes) {
    while (this.totalBytes < numBytes) {
      const { value: chunk, done: readerDone } = await this.reader.read();
      if (readerDone) {
        break;
      }
      this.chunks.push(chunk);
      this.totalBytes += chunk.length;
    }
    if (this.totalBytes < numBytes) {
      throw new Error(
        `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`
      );
    }
    const allBytes = new Uint8Array(this.totalBytes);
    let outOffset = 0;
    for (const chunk of this.chunks) {
      allBytes.set(chunk, outOffset);
      outOffset += chunk.length;
    }
    const result = allBytes.subarray(0, numBytes);
    this.chunks = [allBytes.subarray(numBytes)];
    this.totalBytes -= numBytes;
    return result;
  }
}
function isWebGPURenderer(renderer) {
  if (renderer == null || typeof renderer !== "object") {
    return false;
  }
  if ("isWebGPURenderer" in renderer && renderer.isWebGPURenderer === true) {
    return true;
  }
  if ("_sparkRendererType" in renderer && renderer._sparkRendererType === "webgpu") {
    return true;
  }
  return false;
}
let _usingWebGPU = false;
function setUsingWebGPU(value) {
  _usingWebGPU = value;
}
function isUsingWebGPU() {
  return _usingWebGPU;
}
function setTextureInternalFormat(texture2, format) {
  if (!_usingWebGPU) {
    texture2.internalFormat = format;
  }
}
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache,
  FreeList,
  GunzipReader,
  IDENT_VERTEX_SHADER,
  Sint8ToFloat,
  Uint8ToFloat,
  averagePositions,
  averageQuaternions,
  cloneClock,
  coinciDist,
  computeMaxSplats,
  coorientDist,
  decodeQuatEulerXyz888,
  decodeQuatOctXy88R8: decodeQuatOctXy88R8$1,
  decodeQuatXyz888,
  decompressPartialGzip,
  encodeQuatEulerXyz888,
  encodeQuatOctXy88R8,
  encodeQuatXyz888,
  encodeSh1Rgb,
  encodeSh2Rgb,
  encodeSh3Rgb,
  epsilonSign,
  flipPixels,
  floatBitsToUint: floatBitsToUint$2,
  floatToSint8,
  floatToUint8,
  fromHalf,
  getArrayBuffers,
  getTextureSize,
  isAndroid,
  isMobile,
  isOculus,
  isUsingWebGPU,
  isWebGPURenderer,
  mapFilterObject,
  mapObject,
  newArray,
  normalize: normalize$4,
  omitUndefined,
  pixelsToPngUrl,
  setPackedSplat,
  setPackedSplatCenter,
  setPackedSplatOpacity,
  setPackedSplatQuat,
  setPackedSplatRgb,
  setPackedSplatRgba,
  setPackedSplatScales,
  setTextureInternalFormat,
  setUsingWebGPU,
  toHalf,
  uintBitsToFloat: uintBitsToFloat$2,
  unpackSplat,
  withinCoinciDist,
  withinCoorientDist,
  withinDist
}, Symbol.toStringTag, { value: "Module" }));
class DynoProgram {
  constructor({
    graph,
    inputs,
    outputs,
    template
  }) {
    this.graph = graph;
    this.template = template;
    this.inputs = inputs ?? {};
    this.outputs = outputs ?? {};
    const compile = new Compilation({ indent: this.template.indent });
    for (const key in this.outputs) {
      if (this.outputs[key]) {
        compile.declares.add(this.outputs[key]);
      }
    }
    const statements = graph.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile
    });
    this.shader = template.generate({ globals: compile.globals, statements });
    this.uniforms = compile.uniforms;
    this.updaters = compile.updaters;
  }
  prepareMaterial() {
    return getMaterial(this);
  }
  update() {
    for (const updater of this.updaters) {
      updater();
    }
  }
}
class DynoProgramTemplate {
  constructor(template) {
    const globals = template.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m);
    const statements = template.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!globals || !statements) {
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    }
    this.before = template.substring(0, globals.index);
    this.between = template.substring(
      globals.index + globals[0].length,
      statements.index
    );
    this.after = template.substring(
      statements.index + statements[0].length
    );
    this.indent = statements[1];
  }
  generate({
    globals,
    statements
  }) {
    return this.before + Array.from(globals).join("\n\n") + this.between + statements.map((s) => this.indent + s).join("\n") + this.after;
  }
}
const programMaterial = /* @__PURE__ */ new WeakMap();
function getMaterial(program) {
  let material = programMaterial.get(program);
  if (material) {
    return material;
  }
  material = new THREE.RawShaderMaterial({
    glslVersion: THREE.GLSL3,
    vertexShader: IDENT_VERTEX_SHADER,
    fragmentShader: program.shader,
    uniforms: program.uniforms
  });
  programMaterial.set(program, material);
  return material;
}
function addOutputType(a, b, operation = "add") {
  const error2 = () => {
    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
  };
  if (a === b) return a;
  if (a === "int") {
    if (isIntType(b)) return b;
    error2();
  }
  if (b === "int") {
    if (isIntType(a)) return a;
    error2();
  }
  if (a === "uint") {
    if (isUintType(b)) return b;
    error2();
  }
  if (b === "uint") {
    if (isUintType(a)) return a;
    error2();
  }
  if (a === "float") {
    if (isAllFloatType(b)) return b;
    error2();
  }
  if (b === "float") {
    if (isAllFloatType(a)) return a;
    error2();
  }
  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
}
function subOutputType(a, b) {
  return addOutputType(a, b, "sub");
}
function mulOutputType(a, b) {
  const error2 = () => {
    throw new Error(`Invalid mul types: ${a}, ${b}`);
  };
  const result = (value) => value;
  if (a === "int") {
    if (isIntType(b)) return result(b);
    error2();
  }
  if (b === "int") {
    if (isIntType(a)) return result(a);
    error2();
  }
  if (a === "uint") {
    if (isUintType(b)) return result(b);
    error2();
  }
  if (b === "uint") {
    if (isUintType(a)) return result(a);
    error2();
  }
  if (a === "float") {
    if (isAllFloatType(b)) return result(b);
    error2();
  }
  if (b === "float") {
    if (isAllFloatType(a)) return result(a);
    error2();
  }
  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {
    if (a === b) return result(a);
    error2();
  }
  if (a === "vec2") {
    if (b === "vec2" || isMat2(b)) return result("vec2");
    if (b === "mat3x2") return result("vec3");
    if (b === "mat4x2") return result("vec4");
    error2();
  }
  if (a === "vec3") {
    if (b === "mat2x3") return result("vec2");
    if (b === "vec3" || isMat3(b)) return result("vec3");
    if (b === "mat4x3") return result("vec4");
    error2();
  }
  if (a === "vec4") {
    if (b === "mat2x4") return result("vec2");
    if (b === "mat3x4") return result("vec3");
    if (b === "vec4" || isMat4(b)) return result("vec4");
    error2();
  }
  if (b === "vec2") {
    if (isMat2(a)) return result("vec2");
    if (a === "mat2x3") return result("vec3");
    if (a === "mat2x4") return result("vec4");
    error2();
  }
  if (b === "vec3") {
    if (a === "mat3x2") return result("vec2");
    if (isMat3(a)) return result("vec3");
    if (a === "mat3x4") return result("vec4");
    error2();
  }
  if (b === "vec4") {
    if (a === "mat4x2") return result("vec2");
    if (a === "mat4x3") return result("vec3");
    if (isMat4(a)) return result("vec4");
    error2();
  }
  if (isMat2(a)) {
    if (isMat2(b)) return result("mat2");
    if (b === "mat3x2") return result("mat3x2");
    if (b === "mat4x2") return result("mat4x2");
    error2();
  }
  if (a === "mat2x3") {
    if (isMat2(b)) return result("mat2x3");
    if (b === "mat3x2") return result("mat3");
    if (b === "mat4x2") return result("mat4x3");
    error2();
  }
  if (a === "mat2x4") {
    if (isMat2(b)) return result("mat2x4");
    if (b === "mat3x2") return result("mat3x4");
    if (b === "mat4x2") return result("mat4");
    error2();
  }
  if (a === "mat3x2") {
    if (b === "mat2x3") return result("mat2");
    if (isMat3(b)) return result("mat3x2");
    if (b === "mat4x3") return result("mat4x2");
    error2();
  }
  if (isMat3(a)) {
    if (b === "mat2x3") return result("mat2x3");
    if (isMat3(b)) return result("mat3");
    if (b === "mat4x3") return result("mat4x3");
    error2();
  }
  if (a === "mat3x4") {
    if (b === "mat2x3") return result("mat2x4");
    if (isMat3(b)) return result("mat3x4");
    if (b === "mat4x3") return result("mat4");
    error2();
  }
  if (a === "mat4x2") {
    if (b === "mat2x4") return result("mat2");
    if (b === "mat3x4") return result("mat3x2");
    if (isMat4(b)) return result("mat4x2");
    error2();
  }
  if (a === "mat4x3") {
    if (b === "mat2x4") return result("mat2x3");
    if (b === "mat3x4") return result("mat3");
    if (isMat4(b)) return result("mat4x3");
    error2();
  }
  if (isMat4(a)) {
    if (b === "mat2x4") return result("mat2x4");
    if (b === "mat3x4") return result("mat3x4");
    if (isMat4(b)) return result("mat4");
    error2();
  }
  throw new Error(`Invalid mul types: ${a}, ${b}`);
}
function divOutputType(a, b) {
  return addOutputType(a, b, "div");
}
function imodOutputType(a, b) {
  if (a === b) return a;
  if (a === "int") {
    if (isIntType(b)) return b;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (a === "uint") {
    if (isUintType(b)) return b;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid imod types: ${a}, ${b}`);
}
function modOutputType(a, b) {
  if (a === b || b === "float") return a;
  throw new Error(`Invalid mod types: ${a}, ${b}`);
}
function modfOutputType(a) {
  return a;
}
function negOutputType(a) {
  return a;
}
function absOutputType(a) {
  return a;
}
function signOutputType(a) {
  return a;
}
function floorOutputType(a) {
  return a;
}
function ceilOutputType(a) {
  return a;
}
function truncOutputType(a) {
  return a;
}
function roundOutputType(a) {
  return a;
}
function fractOutputType(a) {
  return a;
}
function powOutputType(a) {
  return a;
}
function expOutputType(a) {
  return a;
}
function exp2OutputType(a) {
  return a;
}
function logOutputType(a) {
  return a;
}
function log2OutputType(a) {
  return a;
}
function sqrOutputType(a) {
  return a;
}
function sqrtOutputType(a) {
  return a;
}
function inversesqrtOutputType(a) {
  return a;
}
function minOutputType(a, b, operation = "min") {
  if (a === b) return a;
  if (b === "float") {
    if (isFloatType(a)) return a;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
}
function maxOutputType(a, b) {
  return minOutputType(a, b, "max");
}
function clampOutputType(a, b, _c) {
  if (b === "float") {
    if (isFloatType(a)) return a;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid clamp types: ${a}, ${b}`);
}
function mixOutputType(a, b, c) {
  if (c === a) return a;
  if (c === "float") return a;
  if (c === "bool" && a === "float") return a;
  if (c === "bvec2" && a === "vec2") return a;
  if (c === "bvec3" && a === "vec3") return a;
  if (c === "bvec4" && a === "vec4") return a;
  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);
}
function stepOutputType(a, b) {
  if (a === b || b === "float") return b;
  throw new Error(`Invalid step types: ${a}, ${b}`);
}
function smoothstepOutputType(a, b, c) {
  if (a === b) {
    if (a === c || a === "float") return c;
  }
  throw new Error(`Invalid smoothstep types: ${a}, ${b}, ${c}`);
}
function isNanOutputType(a, operation = "isNan") {
  if (a === "float") return "bool";
  if (a === "vec2") return "bvec2";
  if (a === "vec3") return "bvec3";
  if (a === "vec4") return "bvec4";
  throw new Error(`Invalid ${operation} types: ${a}`);
}
function isInfOutputType(a) {
  return isNanOutputType(a, "isInf");
}
const add$4 = (a, b) => new Add({ a, b });
const sub$4 = (a, b) => new Sub({ a, b });
const mul$4 = (a, b) => new Mul({ a, b });
const div$3 = (a, b) => new Div({ a, b });
const imod = (a, b) => new IMod({ a, b });
const mod$1 = (a, b) => new Mod({ a, b });
const modf = (a) => new Modf({ a }).outputs;
const neg = (a) => new Neg({ a });
const abs$3 = (a) => new Abs({ a });
const sign$1 = (a) => new Sign({ a });
const floor$1 = (a) => new Floor({ a });
const ceil$1 = (a) => new Ceil({ a });
const trunc$1 = (a) => new Trunc({ a });
const round$1 = (a) => new Round({ a });
const fract$1 = (a) => new Fract({ a });
const pow$1 = (a, b) => new Pow({ a, b });
const exp$3 = (a) => new Exp({ a });
const exp2$1 = (a) => new Exp2({ a });
const log$3 = (a) => new Log({ a });
const log2$1 = (a) => new Log2({ a });
const sqr = (a) => new Sqr({ a });
const sqrt$4 = (a) => new Sqrt({ a });
const inversesqrt$1 = (a) => new InverseSqrt({ a });
const min$3 = (a, b) => new Min({ a, b });
const max$3 = (a, b) => new Max({ a, b });
const clamp$3 = (a, min2, max2) => new Clamp({ a, min: min2, max: max2 });
const mix$1 = (a, b, t) => new Mix({ a, b, t });
const step$1 = (edge, x) => new Step({ edge, x });
const smoothstep$2 = (edge0, edge1, x) => new Smoothstep({ edge0, edge1, x });
const isNan = (a) => new IsNan({ a });
const isInf = (a) => new IsInf({ a });
class Add extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "sum", outTypeFunc: addOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];
    };
  }
}
class Sub extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "difference", outTypeFunc: subOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];
    };
  }
}
class Mul extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "product", outTypeFunc: mulOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];
    };
  }
}
class Div extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "quotient", outTypeFunc: divOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.quotient} = ${inputs.a} / ${inputs.b};`];
    };
  }
}
class IMod extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "remainder", outTypeFunc: imodOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];
    };
  }
}
class Mod extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "remainder", outTypeFunc: modOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Modf extends Dyno {
  constructor({ a }) {
    const inTypes = { a: valType(a) };
    const outType = modfOutputType(inTypes.a);
    const outTypes = {
      fract: outType,
      integer: outType
    };
    super({ inTypes, outTypes, inputs: { a } });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.fract} = modf(${inputs.a}, ${outputs.integer});`];
    };
  }
}
class Neg extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "neg", outTypeFunc: negOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.neg} = -${inputs.a};`];
    };
  }
}
class Abs extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "abs", outTypeFunc: absOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.abs} = abs(${inputs.a});`];
    };
  }
}
class Sign extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sign", outTypeFunc: signOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sign} = sign(${inputs.a});`];
    };
  }
}
class Floor extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "floor", outTypeFunc: floorOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.floor} = floor(${inputs.a});`];
    };
  }
}
class Ceil extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "ceil", outTypeFunc: ceilOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.ceil} = ceil(${inputs.a});`];
    };
  }
}
class Trunc extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "trunc", outTypeFunc: truncOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.trunc} = trunc(${inputs.a});`];
    };
  }
}
class Round extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "round", outTypeFunc: roundOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.round} = round(${inputs.a});`];
    };
  }
}
class Fract extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "fract", outTypeFunc: fractOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.fract} = fract(${inputs.a});`];
    };
  }
}
class Pow extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "power", outTypeFunc: powOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.power} = pow(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Exp extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "exp", outTypeFunc: expOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.exp} = exp(${inputs.a});`];
    };
  }
}
class Exp2 extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "exp2", outTypeFunc: exp2OutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.exp2} = exp2(${inputs.a});`];
    };
  }
}
class Log extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "log", outTypeFunc: logOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.log} = log(${inputs.a});`];
    };
  }
}
class Log2 extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "log2", outTypeFunc: log2OutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.log2} = log2(${inputs.a});`];
    };
  }
}
class Sqr extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sqr", outTypeFunc: sqrOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sqr} = ${inputs.a} * ${inputs.a};`];
    };
  }
}
class Sqrt extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sqrt", outTypeFunc: sqrtOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sqrt} = sqrt(${inputs.a});`];
    };
  }
}
class InverseSqrt extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "inversesqrt", outTypeFunc: inversesqrtOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.inversesqrt} = inversesqrt(${inputs.a});`];
    };
  }
}
class Min extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "min", outTypeFunc: minOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Max extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "max", outTypeFunc: maxOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.max} = max(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Clamp extends TrinaryOp {
  constructor({
    a,
    min: min2,
    max: max2
  }) {
    super({
      a,
      b: min2,
      c: max2,
      outKey: "clamp",
      outTypeFunc: clampOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: a2, b: min3, c: max3 } = inputs;
      return [`${outputs.clamp} = clamp(${a2}, ${min3}, ${max3});`];
    };
  }
}
class Mix extends TrinaryOp {
  constructor({ a, b, t }) {
    super({ a, b, c: t, outKey: "mix", outTypeFunc: mixOutputType });
    this.statements = ({ inputs, outputs }) => {
      const { a: a2, b: b22, c: t2 } = inputs;
      return [`${outputs.mix} = mix(${a2}, ${b22}, ${t2});`];
    };
  }
}
class Step extends BinaryOp {
  constructor({ edge, x }) {
    super({
      a: edge,
      b: x,
      outKey: "step",
      outTypeFunc: stepOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: edge2, b: x2 } = inputs;
      return [`${outputs.step} = step(${edge2}, ${x2});`];
    };
  }
}
class Smoothstep extends TrinaryOp {
  constructor({
    edge0,
    edge1,
    x
  }) {
    super({
      a: edge0,
      b: edge1,
      c: x,
      outKey: "smoothstep",
      outTypeFunc: smoothstepOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: edge02, b: edge12, c: x2 } = inputs;
      return [`${outputs.smoothstep} = smoothstep(${edge02}, ${edge12}, ${x2});`];
    };
  }
}
class IsNan extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "isNan", outTypeFunc: isNanOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.isNan} = isNan(${inputs.a});`];
    };
  }
}
class IsInf extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "isInf", outTypeFunc: isInfOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.isInf} = isInf(${inputs.a});`];
    };
  }
}
const and$1 = (a, b) => new And({ a, b });
const or$1 = (a, b) => new Or({ a, b });
const xor$1 = (a, b) => new Xor({ a, b });
const not$1 = (a) => new Not({ a });
const lessThan$1 = (a, b) => new LessThan({ a, b });
const lessThanEqual$1 = (a, b) => new LessThanEqual({ a, b });
const greaterThan$1 = (a, b) => new GreaterThan({ a, b });
const greaterThanEqual$1 = (a, b) => new GreaterThanEqual({ a, b });
const equal$1 = (a, b) => new Equal({ a, b });
const notEqual$1 = (a, b) => new NotEqual({ a, b });
const any$1 = (a) => new Any({ a });
const all$1 = (a) => new All({ a });
const select$4 = (cond, t, f) => new Select({ cond, t, f });
const compXor = (a) => new CompXor({ a });
class And extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "and" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.and === "bool") {
        return [`${outputs.and} = ${inputs.a} && ${inputs.b};`];
      }
      return [`${outputs.and} = ${inputs.a} & ${inputs.b};`];
    };
  }
}
class Or extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "or" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.or === "bool") {
        return [`${outputs.or} = ${inputs.a} || ${inputs.b};`];
      }
      return [`${outputs.or} = ${inputs.a} | ${inputs.b};`];
    };
  }
}
class Xor extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "xor" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.xor === "bool") {
        return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];
      }
      return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];
    };
  }
}
class Not extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => aType, outKey: "not" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.not === "bool") {
        return [`${outputs.not} = !${inputs.a};`];
      }
      return [`${outputs.not} = not(${inputs.a});`];
    };
  }
}
class LessThan extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "lessThan"),
      outKey: "lessThan"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.lessThan === "bool") {
        return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];
      }
      return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];
    };
  }
}
class LessThanEqual extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "lessThanEqual"),
      outKey: "lessThanEqual"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.lessThanEqual === "bool") {
        return [`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];
      }
      return [
        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class GreaterThan extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "greaterThan"),
      outKey: "greaterThan"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.greaterThan === "bool") {
        return [`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];
      }
      return [
        `${outputs.greaterThan} = greaterThan(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class GreaterThanEqual extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.greaterThanEqual === "bool") {
        return [`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];
      }
      return [
        `${outputs.greaterThanEqual} = greaterThanEqual(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class Equal extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: equalOutputType, outKey: "equal" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.equal === "bool") {
        return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];
      }
      return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];
    };
  }
}
class NotEqual extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: notEqualOutputType, outKey: "notEqual" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.notEqual === "bool") {
        return [`${outputs.notEqual} = ${inputs.a} != ${inputs.b};`];
      }
      return [`${outputs.notEqual} = notEqual(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Any extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "bool", outKey: "any" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.any} = any(${inputs.a});`];
    };
  }
}
class All extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "bool", outKey: "all" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.all} = all(${inputs.a});`];
    };
  }
}
class Select extends TrinaryOp {
  constructor({
    cond,
    t,
    f
  }) {
    super({
      a: cond,
      b: t,
      c: f,
      outKey: "select",
      outTypeFunc: (aType, bType, cType) => bType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: cond2, b: t2, c: f2 } = inputs;
      return [`${outputs.select} = (${cond2}) ? (${t2}) : (${f2});`];
    };
  }
}
function compareOutputType(type, operator) {
  if (isScalarType(type)) {
    return "bool";
  }
  if (type === "ivec2" || type === "uvec2" || type === "vec2") {
    return "bvec2";
  }
  if (type === "ivec3" || type === "uvec3" || type === "vec3") {
    return "bvec3";
  }
  if (type === "ivec4" || type === "uvec4" || type === "vec4") {
    return "bvec4";
  }
  throw new Error(`Invalid ${operator} type: ${type}`);
}
function equalOutputType(type, operator = "equal") {
  if (isScalarType(type)) {
    return "bool";
  }
  if (isBoolType(type)) {
    return type;
  }
  if (type === "ivec2" || type === "uvec2" || type === "vec2") {
    return "bvec2";
  }
  if (type === "ivec3" || type === "uvec3" || type === "vec3") {
    return "bvec3";
  }
  if (type === "ivec4" || type === "uvec4" || type === "vec4") {
    return "bvec4";
  }
  throw new Error(`Invalid ${operator} type: ${type}`);
}
function notEqualOutputType(type) {
  return equalOutputType(type, "notEqual");
}
function compXorOutputType(type) {
  if (isBoolType(type)) {
    return "bool";
  }
  if (isIntType(type)) {
    return "int";
  }
  if (isUintType(type)) {
    return "uint";
  }
  throw new Error(`Invalid compXor type: ${type}`);
}
class CompXor extends UnaryOp {
  constructor({ a }) {
    const outType = compXorOutputType(valType(a));
    super({ a, outTypeFunc: (aType) => outType, outKey: "compXor" });
    this.statements = ({ inputs, outputs }) => {
      if (isScalarType(this.outTypes.compXor)) {
        return [`${outputs.compXor} = ${inputs.a};`];
      }
      const components = isVector2Type(outType) ? ["x", "y"] : isVector3Type(outType) ? ["x", "y", "z"] : ["x", "y", "z", "w"];
      const operands = components.map((c) => `${inputs.a}.${c}`);
      const operator = isBoolType(outType) ? "^^" : "^";
      return [`${outputs.compXor} = ${operands.join(` ${operator} `)};`];
    };
  }
}
const bool$1 = (value) => new Bool({ value });
const int$4 = (value) => new Int({ value });
const uint$4 = (value) => new Uint({ value });
const float$5 = (value) => new Float({ value });
const bvec2$1 = (value) => new BVec2({ value });
const bvec3$1 = (value) => new BVec3({ value });
const bvec4$1 = (value) => new BVec4({ value });
const ivec2$3 = (value) => new IVec2({ value });
const ivec3$4 = (value) => new IVec3({ value });
const ivec4$1 = (value) => new IVec4({ value });
const uvec2$1 = (value) => new UVec2({ value });
const uvec3$1 = (value) => new UVec3({ value });
const uvec4$1 = (value) => new UVec4({ value });
const vec2$3 = (value) => new Vec2({ value });
const vec3$3 = (value) => new Vec3({ value });
const vec4$4 = (value) => new Vec4({ value });
const mat2$1 = (value) => new Mat2({ value });
const mat3$1 = (value) => new Mat3({ value });
const mat4$1 = (value) => new Mat4({ value });
const floatBitsToInt$1 = (value) => new FloatBitsToInt({ value });
const floatBitsToUint$1 = (value) => new FloatBitsToUint({ value });
const intBitsToFloat$1 = (value) => new IntBitsToFloat({ value });
const uintBitsToFloat$1 = (value) => new UintBitsToFloat({ value });
const packSnorm2x16$1 = (value) => new PackSnorm2x16({ value });
const unpackSnorm2x16$1 = (value) => new UnpackSnorm2x16({ value });
const packUnorm2x16$1 = (value) => new PackUnorm2x16({ value });
const unpackUnorm2x16$1 = (value) => new UnpackUnorm2x16({ value });
const packHalf2x16$1 = (value) => new PackHalf2x16({ value });
const unpackHalf2x16$2 = (value) => new UnpackHalf2x16({ value });
const uintToRgba8 = (value) => new UintToRgba8({ value });
class SimpleCast extends UnaryOp {
  constructor({
    value,
    outType,
    outKey
  }) {
    super({ a: value, outTypeFunc: () => outType, outKey });
    this.statements = ({ inputs, outputs }) => [
      `${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`
    ];
  }
}
class Bool extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bool", outKey: "bool" });
  }
}
class Int extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "int", outKey: "int" });
  }
}
class Uint extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uint", outKey: "uint" });
  }
}
class Float extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "float", outKey: "float" });
  }
}
class BVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec2", outKey: "bvec2" });
  }
}
class BVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec3", outKey: "bvec3" });
  }
}
class BVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec4", outKey: "bvec4" });
  }
}
class IVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec2", outKey: "ivec2" });
  }
}
class IVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec3", outKey: "ivec3" });
  }
}
class IVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec4", outKey: "ivec4" });
  }
}
class UVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec2", outKey: "uvec2" });
  }
}
class UVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec3", outKey: "uvec3" });
  }
}
class UVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec4", outKey: "uvec4" });
  }
}
class Vec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec2", outKey: "vec2" });
  }
}
class Vec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec3", outKey: "vec3" });
  }
}
class Vec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec4", outKey: "vec4" });
  }
}
class Mat2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat2", outKey: "mat2" });
  }
}
class Mat3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat3", outKey: "mat3" });
  }
}
class Mat4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat4", outKey: "mat4" });
  }
}
class FloatBitsToInt extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "int", outTypeFunc: () => "int" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.int} = floatBitsToInt(${inputs.a});`];
    };
  }
}
class FloatBitsToUint extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = floatBitsToUint(${inputs.a});`];
    };
  }
}
class IntBitsToFloat extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "float", outTypeFunc: () => "float" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.float} = intBitsToFloat(${inputs.a});`];
    };
  }
}
class UintBitsToFloat extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "float", outTypeFunc: () => "float" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.float} = uintBitsToFloat(${inputs.a});`];
    };
  }
}
class PackSnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packSnorm2x16(${inputs.a});`];
    };
  }
}
class UnpackSnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackSnorm2x16(${inputs.a});`];
    };
  }
}
class PackUnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packUnorm2x16(${inputs.a});`];
    };
  }
}
class UnpackUnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackUnorm2x16(${inputs.a});`];
    };
  }
}
class PackHalf2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packHalf2x16(${inputs.a});`];
    };
  }
}
class UnpackHalf2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackHalf2x16(${inputs.a});`];
    };
  }
}
class UintToRgba8 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "rgba8", outTypeFunc: () => "vec4" });
    this.statements = ({ inputs, outputs }) => {
      return [
        `uvec4 uRgba = uvec4(${inputs.a} & 0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, (${inputs.a} >> 24u) & 0xffu);`,
        `${outputs.rgba8} = vec4(uRgba) / 255.0;`
      ];
    };
  }
}
const length$1 = (a) => new Length({ a });
const distance$1 = (a, b) => new Distance({ a, b });
const dot$4 = (a, b) => new Dot({ a, b });
const cross$2 = (a, b) => new Cross({ a, b });
const normalize$3 = (a) => new Normalize({ a });
const faceforward$1 = (a, b, c) => new FaceForward({ a, b, c });
const reflectVec = (incident, normal2) => new ReflectVec({ incident, normal: normal2 });
const refractVec = (incident, normal2, eta) => new RefractVec({ incident, normal: normal2, eta });
const split$1 = (vector) => new Split({ vector });
const combine = ({
  vector,
  vectorType,
  x,
  y,
  z,
  w,
  r,
  g,
  b,
  a
}) => new Combine({ vector, vectorType, x, y, z, w, r, g, b, a });
const projectH = (a) => new ProjectH({ a });
const extendVec = (a, b) => new ExtendVec({ a, b });
const swizzle = (a, select2) => new Swizzle({ vector: a, select: select2 });
const compMult = (a, b) => new CompMult({ a, b });
const outer = (a, b) => new Outer({ a, b });
const transpose$1 = (a) => new Transpose({ a });
const determinant$1 = (a) => new Determinant({ a });
const inverse$1 = (a) => new Inverse({ a });
class Length extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "float", outKey: "length" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.length} = length(${inputs.a});`
    ];
  }
}
class Distance extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "distance", outTypeFunc: (aType, bType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Dot extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "dot", outTypeFunc: (aType, bType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.dot} = dot(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Cross extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "cross", outTypeFunc: (aType, bType) => "vec3" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cross} = cross(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Normalize extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.normalize} = normalize(${inputs.a});`
    ];
  }
}
function projectHOutputType(type) {
  if (type === "vec3") {
    return "vec2";
  }
  if (type === "vec4") {
    return "vec3";
  }
  throw new Error("Invalid type");
}
class ProjectH extends UnaryOp {
  constructor({ a }) {
    super({
      a,
      outTypeFunc: (aType) => projectHOutputType(aType),
      outKey: "projected"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.inTypes.a === "vec3") {
        return [`${outputs.projected} = ${inputs.a}.xy / ${inputs.a}.z;`];
      }
      if (this.inTypes.a === "vec4") {
        return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];
      }
      throw new Error("Invalid type");
    };
  }
}
function extendVecOutputType(type) {
  if (type === "float") return "vec2";
  if (type === "vec2") return "vec3";
  if (type === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class ExtendVec extends BinaryOp {
  constructor({ a, b }) {
    const type = valType(a);
    const outType = extendVecOutputType(type);
    super({ a, b, outKey: "extend", outTypeFunc: () => outType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`
    ];
  }
}
class FaceForward extends TrinaryOp {
  constructor({ a, b, c }) {
    super({
      a,
      b,
      c,
      outKey: "forward",
      outTypeFunc: (aType, bType, cType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`
    ];
  }
}
class ReflectVec extends BinaryOp {
  constructor({
    incident,
    normal: normal2
  }) {
    super({
      a: incident,
      b: normal2,
      outKey: "reflection",
      outTypeFunc: (aType, bType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`
    ];
  }
}
class RefractVec extends TrinaryOp {
  constructor({
    incident,
    normal: normal2,
    eta
  }) {
    super({
      a: incident,
      b: normal2,
      c: eta,
      outKey: "refraction",
      outTypeFunc: (aType, bType, cType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.refraction} = refract(${inputs.a}, ${inputs.b}, ${inputs.c});`
    ];
  }
}
class CompMult extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "product", outTypeFunc: (aType, bType) => aType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.product} = matrixCompMult(${a}, ${b});`
    ];
  }
}
function outerOutputType(aType, bType) {
  if (aType === "vec2") {
    if (bType === "vec2") return "mat2";
    if (bType === "vec3") return "mat3x2";
    if (bType === "vec4") return "mat4x2";
  }
  if (aType === "vec3") {
    if (bType === "vec2") return "mat2x3";
    if (bType === "vec3") return "mat3";
    if (bType === "vec4") return "mat4x3";
  }
  if (aType === "vec4") {
    if (bType === "vec2") return "mat2x4";
    if (bType === "vec3") return "mat3x4";
    if (bType === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${aType}, ${bType}`);
}
class Outer extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "outer", outTypeFunc: outerOutputType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.outer} = outerProduct(${inputs.a}, ${inputs.b});`
    ];
  }
}
function transposeOutputType(type) {
  if (type === "mat2") return "mat2";
  if (type === "mat3") return "mat3";
  if (type === "mat4") return "mat4";
  if (type === "mat2x2") return "mat2x2";
  if (type === "mat2x3") return "mat3x2";
  if (type === "mat2x4") return "mat4x2";
  if (type === "mat3x2") return "mat2x3";
  if (type === "mat3x3") return "mat3x3";
  if (type === "mat3x4") return "mat4x3";
  if (type === "mat4x2") return "mat2x4";
  if (type === "mat4x3") return "mat3x4";
  if (type === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${type}`);
}
class Transpose extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "transpose", outTypeFunc: transposeOutputType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.transpose} = transpose(${inputs.a});`
    ];
  }
}
class Determinant extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "det", outTypeFunc: (aType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.det} = determinant(${inputs.a});`
    ];
  }
}
class Inverse extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "inverse", outTypeFunc: (aType) => aType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.inverse} = inverse(${a});`
    ];
  }
}
function splitOutTypes(type) {
  const result = (value) => value;
  switch (type) {
    case "vec2":
      return result({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return result({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return result({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return result({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return result({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return result({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return result({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return result({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return result({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
class Split extends Dyno {
  constructor({ vector }) {
    const type = valType(vector);
    const inTypes = { vector: type };
    const outTypes = splitOutTypes(inTypes.vector);
    super({ inTypes, outTypes, inputs: { vector } });
    this.statements = ({ inputs, outputs }) => {
      const { x, y, z, w, r, g, b, a } = outputs;
      const { vector: vector2 } = inputs;
      return [
        x ? `${x} = ${vector2}.x;` : null,
        y ? `${y} = ${vector2}.y;` : null,
        z ? `${z} = ${vector2}.z;` : null,
        w ? `${w} = ${vector2}.w;` : null,
        r ? `${r} = ${vector2}.r;` : null,
        g ? `${g} = ${vector2}.g;` : null,
        b ? `${b} = ${vector2}.b;` : null,
        a ? `${a} = ${vector2}.a;` : null
      ].filter(Boolean);
    };
  }
}
class Combine extends Dyno {
  constructor({
    vector,
    vectorType,
    x,
    y,
    z,
    w,
    r,
    g,
    b,
    a
  }) {
    if (!vector && !vectorType) {
      throw new Error("Either vector or vectorType must be provided");
    }
    const vType = vectorType ?? valType(vector);
    const elType = vectorElementType(vType);
    const dim = vectorDim(vType);
    const inTypes = {
      vector: vType,
      x: elType,
      y: elType,
      r: elType,
      g: elType
    };
    const inputs = { vector, x, y, r, g };
    if (dim >= 3) {
      Object.assign(inTypes, { z: elType, b: elType });
      Object.assign(inputs, { z, b });
    }
    if (dim >= 4) {
      Object.assign(inTypes, { w: elType, a: elType });
      Object.assign(inputs, { w, a });
    }
    super({ inTypes, outTypes: { vector: vType }, inputs });
    this.statements = ({ inputs: inputs2, outputs }) => {
      const { vector: vector2 } = outputs;
      const {
        vector: input,
        x: x2,
        y: y2,
        z: z2,
        w: w22,
        r: r2,
        g: g2,
        b: b22,
        a: a2
      } = inputs2;
      const statements = [
        `${vector2}.x = ${x2 ?? r2 ?? (input ? `${input}.x` : literalZero(elType))};`,
        `${vector2}.y = ${y2 ?? g2 ?? (input ? `${input}.y` : literalZero(elType))};`
      ];
      if (dim >= 3)
        statements.push(
          `${vector2}.z = ${z2 ?? b22 ?? (input ? `${input}.z` : literalZero(elType))};`
        );
      if (dim >= 4)
        statements.push(
          `${vector2}.w = ${w22 ?? a2 ?? (input ? `${input}.w` : literalZero(elType))};`
        );
      return statements;
    };
  }
  dynoOut() {
    return new DynoOutput(
      this,
      "vector"
    );
  }
}
function swizzleOutputType(type, swizzle2) {
  let result = null;
  if (isFloatType(type)) {
    result = swizzle2.length === 1 ? "float" : swizzle2.length === 2 ? "vec2" : swizzle2.length === 3 ? "vec3" : swizzle2.length === 4 ? "vec4" : null;
  } else if (isIntType(type)) {
    result = swizzle2.length === 1 ? "int" : swizzle2.length === 2 ? "ivec2" : swizzle2.length === 3 ? "ivec3" : swizzle2.length === 4 ? "ivec4" : null;
  } else if (isUintType(type)) {
    result = swizzle2.length === 1 ? "uint" : swizzle2.length === 2 ? "uvec2" : swizzle2.length === 3 ? "uvec3" : swizzle2.length === 4 ? "uvec4" : null;
  }
  if (result == null) {
    throw new Error(`Invalid swizzle: ${swizzle2}`);
  }
  return result;
}
class Swizzle extends UnaryOp {
  constructor({ vector, select: select2 }) {
    super({
      a: vector,
      outKey: "swizzle",
      outTypeFunc: (aType) => swizzleOutputType(aType, select2)
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.swizzle} = ${inputs.a}.${select2};`
    ];
  }
}
const remapIndex = (index, from, to) => {
  return new DynoRemapIndex({ index, from, to });
};
const pcgMix = (value) => {
  return new PcgMix({ value });
};
const pcgNext = (state) => {
  return new PcgNext({ state });
};
const pcgHash = (state) => {
  return new PcgHash({ state });
};
const hash$2 = (value) => {
  return new Hash({ value });
};
const hash2 = (value) => {
  return new Hash2({ value });
};
const hash3 = (value) => {
  return new Hash3({ value });
};
const hash4 = (value) => {
  return new Hash4({ value });
};
const hashFloat = (value) => {
  return new HashFloat({ value });
};
const hashVec2 = (value) => {
  return new HashVec2({ value });
};
const hashVec3 = (value) => {
  return new HashVec3({ value });
};
const hashVec4 = (value) => {
  return new HashVec4({ value });
};
const normalizedDepth = (z, zNear, zFar) => {
  return new NormalizedDepth({ z, zNear, zFar }).outputs.depth;
};
class DynoRemapIndex extends Dyno {
  constructor({
    from,
    to,
    index
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from, to, index },
      statements: ({ inputs, outputs }) => {
        return [
          `${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`
        ];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "index");
  }
}
class PcgNext extends Dyno {
  constructor({ state }) {
    const type = valType(state);
    super({
      inTypes: { state: type },
      outTypes: { state: "uint" },
      inputs: { state },
      globals: () => [
        unindent(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => {
        const toUint = type === "uint" ? `${inputs.state}` : type === "int" ? `uint(${inputs.state})` : `floatBitsToUint(${inputs.state})`;
        return [`${outputs.state} = pcg_next(${toUint});`];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "state");
  }
}
class PcgHash extends Dyno {
  constructor({ state }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state },
      globals: () => [
        unindent(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => [
        `${outputs.hash} = pcg_hash(${inputs.state});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class PcgMix extends Dyno {
  constructor({ value }) {
    const type = valType(value);
    const tempType = sameSizeUvec(type);
    super({
      inTypes: { value: type },
      outTypes: { state: "uint" },
      inputs: { value },
      globals: () => [
        unindent(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => {
        const toUvec = isUintType(type) ? `${inputs.value}` : isIntType(type) ? `${tempType}(${inputs.value})` : `floatBitsToUint(${inputs.value})`;
        return [
          `${tempType} bits = ${toUvec};`,
          `${outputs.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "state");
  }
}
class Hash extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uint" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        return new PcgHash({ state }).outputs;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash2 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec2" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec2", x, y }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash3 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec3" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const z = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec3", x, y, z }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash4 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec4" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const z = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const w = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec4", x, y, z, w }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashFloat extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "float" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const word = hash$2(value2);
        return { hash: mul$4(float$5(word), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec2 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec2" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash2(value2);
        return { hash: mul$4(vec2$3(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec3 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec3" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash3(value2);
        return { hash: mul$4(vec3$3(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec4 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec4" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash4(value2);
        return { hash: mul$4(vec4$4(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class NormalizedDepth extends Dyno {
  constructor({
    z,
    zNear,
    zFar
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z, zNear, zFar },
      statements: ({ inputs, outputs }) => [
        `float clamped = clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,
        `${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / (log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "depth");
  }
}
const transformPos = (position, {
  scale,
  scales,
  rotate: rotate2,
  translate
}) => {
  return new TransformPosition({ position, scale, scales, rotate: rotate2, translate }).outputs.position;
};
const transformDir = (dir, {
  scale,
  scales,
  rotate: rotate2
}) => {
  return new TransformDir({ dir, scale, scales, rotate: rotate2 }).outputs.dir;
};
const transformQuat = (quaternion, { rotate: rotate2 }) => {
  return new TransformQuaternion({ quaternion, rotate: rotate2 }).outputs.quaternion;
};
class TransformPosition extends Dyno {
  constructor({
    position,
    scale,
    scales,
    rotate: rotate2,
    translate
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position, scale, scales, rotate: rotate2, translate },
      statements: ({ inputs, outputs }) => {
        const { position: position2 } = outputs;
        if (!position2) {
          return [];
        }
        const { scale: scale2, scales: scales2, rotate: rotate22, translate: translate2 } = inputs;
        return [
          `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          !scale2 ? null : `${position2} *= ${scale2};`,
          !scales2 ? null : `${position2} *= ${scales2};`,
          !rotate22 ? null : `${position2} = quatVec(${rotate22}, ${position2});`,
          !translate2 ? null : `${position2} += ${translate2};`
        ].filter(Boolean);
      }
    });
  }
}
class TransformDir extends Dyno {
  constructor({
    dir,
    scale,
    scales,
    rotate: rotate2
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir, scale, scales, rotate: rotate2 },
      statements: ({ inputs, outputs }) => {
        const { dir: dir2 } = outputs;
        if (!dir2) {
          return [];
        }
        const { scale: scale2, scales: scales2, rotate: rotate22 } = inputs;
        return [
          `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          !scale2 ? null : `${dir2} *= ${scale2};`,
          !scales2 ? null : `${dir2} *= ${scales2};`,
          !rotate22 ? null : `${dir2} = quatVec(${rotate22}, ${dir2});`
        ].filter(Boolean);
      }
    });
  }
}
class TransformQuaternion extends Dyno {
  constructor({
    quaternion,
    rotate: rotate2
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion, rotate: rotate2 },
      statements: ({ inputs, outputs }) => {
        const { quaternion: quaternion2 } = outputs;
        if (!quaternion2) {
          return [];
        }
        return [
          `${quaternion2} = ${inputs.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          !rotate2 ? null : `${quaternion2} = quatQuat(${inputs.rotate}, ${quaternion2});`
        ].filter(Boolean);
      }
    });
  }
}
const dynoIf = () => {
  throw new Error("Not implemented");
};
const dynoSwitch = () => {
  throw new Error("Not implemented");
};
const dynoFor = () => {
  throw new Error("Not implemented");
};
const comment = () => {
  throw new Error("Not implemented");
};
const arrayIndex = () => {
  throw new Error("Not implemented");
};
const arrayLength = () => {
  throw new Error("Not implemented");
};
const textureSize$1 = (texture2, lod) => new TextureSize({ texture: texture2, lod });
const texture$3 = (texture2, coord, bias) => new Texture$1({ texture: texture2, coord, bias });
const texelFetch = (texture2, coord, lod) => new TexelFetch({ texture: texture2, coord, lod });
class TextureSize extends Dyno {
  constructor({ texture: texture2, lod }) {
    const textureType = valType(texture2);
    super({
      inTypes: { texture: textureType, lod: "int" },
      outTypes: { size: textureSizeType(textureType) },
      inputs: { texture: texture2, lod },
      statements: ({ inputs, outputs }) => [
        `${outputs.size} = textureSize(${inputs.texture}, ${inputs.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "size");
  }
}
let Texture$1 = class Texture extends Dyno {
  constructor({
    texture: texture2,
    coord,
    bias
  }) {
    const textureType = valType(texture2);
    super({
      inTypes: {
        texture: textureType,
        coord: textureCoordType(textureType),
        bias: "float"
      },
      outTypes: { sample: textureReturnType(textureType) },
      inputs: { texture: texture2, coord, bias },
      statements: ({ inputs, outputs }) => [
        `${outputs.sample} = texture(${inputs.texture}, ${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "sample");
  }
};
class TexelFetch extends Dyno {
  constructor({
    texture: texture2,
    coord,
    lod
  }) {
    const textureType = valType(texture2);
    super({
      inTypes: {
        texture: textureType,
        coord: textureSizeType(textureType),
        lod: "int"
      },
      outTypes: { texel: textureReturnType(textureType) },
      inputs: { texture: texture2, coord, lod },
      statements: ({ inputs, outputs }) => [
        `${outputs.texel} = texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "texel");
  }
}
function textureSizeType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
function textureCoordType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
function textureReturnType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
const radians$1 = (degrees2) => new Radians({ degrees: degrees2 });
const degrees$1 = (radians2) => new Degrees({ radians: radians2 });
const sin$2 = (radians2) => new Sin({ radians: radians2 });
const cos$2 = (radians2) => new Cos({ radians: radians2 });
const tan$1 = (radians2) => new Tan({ radians: radians2 });
const asin$1 = (sin2) => new Asin({ sin: sin2 });
const acos$1 = (cos2) => new Acos({ cos: cos2 });
const atan$1 = (tan2) => new Atan({ tan: tan2 });
const atan2$1 = (y, x) => new Atan2({ y, x });
const sinh = (x) => new Sinh({ x });
const cosh = (x) => new Cosh({ x });
const tanh = (x) => new Tanh({ x });
const asinh = (x) => new Asinh({ x });
const acosh = (x) => new Acosh({ x });
const atanh = (x) => new Atanh({ x });
class Radians extends UnaryOp {
  constructor({ degrees: degrees2 }) {
    super({ a: degrees2, outTypeFunc: (aType) => aType, outKey: "radians" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.radians} = radians(${inputs.a});`
    ];
  }
}
class Degrees extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "degrees" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.degrees} = degrees(${inputs.a});`
    ];
  }
}
class Sin extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "sin" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.sin} = sin(${inputs.a});`
    ];
  }
}
class Cos extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "cos" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cos} = cos(${inputs.a});`
    ];
  }
}
class Tan extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "tan" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.tan} = tan(${inputs.a});`
    ];
  }
}
class Asin extends UnaryOp {
  constructor({ sin: sin2 }) {
    super({ a: sin2, outTypeFunc: (aType) => aType, outKey: "asin" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.asin} = asin(${inputs.a});`
    ];
  }
}
class Acos extends UnaryOp {
  constructor({ cos: cos2 }) {
    super({ a: cos2, outTypeFunc: (aType) => aType, outKey: "acos" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.acos} = acos(${inputs.a});`
    ];
  }
}
class Atan extends UnaryOp {
  constructor({ tan: tan2 }) {
    super({ a: tan2, outTypeFunc: (aType) => aType, outKey: "atan" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atan} = atan(${inputs.a});`
    ];
  }
}
class Atan2 extends BinaryOp {
  constructor({ y, x }) {
    super({
      a: y,
      b: x,
      outTypeFunc: (aType, bType) => aType,
      outKey: "atan2"
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atan2} = atan2(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Sinh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "sinh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.sinh} = sinh(${inputs.a});`
    ];
  }
}
class Cosh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "cosh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cosh} = cosh(${inputs.a});`
    ];
  }
}
class Tanh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "tanh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.tanh} = tanh(${inputs.a});`
    ];
  }
}
class Asinh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "asinh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.asinh} = asinh(${inputs.a});`
    ];
  }
}
class Acosh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "acosh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.acosh} = acosh(${inputs.a});`
    ];
  }
}
class Atanh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "atanh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atanh} = atanh(${inputs.a});`
    ];
  }
}
const dyno = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs,
  Acos,
  Acosh,
  Add,
  All,
  And,
  Any,
  Asin,
  Asinh,
  Atan,
  Atan2,
  Atanh,
  BVec2,
  BVec3,
  BVec4,
  BinaryOp,
  Bool,
  Ceil,
  Clamp,
  Combine,
  CombineGsplat,
  CompMult,
  CompXor,
  Compilation,
  Cos,
  Cosh,
  Cross,
  Degrees,
  Determinant,
  Distance,
  Div,
  Dot,
  Dyno,
  DynoBlock,
  DynoBool,
  DynoBvec2,
  DynoBvec3,
  DynoBvec4,
  DynoConst,
  DynoFloat,
  DynoInt,
  DynoIsampler2D,
  DynoIsampler2DArray,
  DynoIsampler3D,
  DynoIsamplerCube,
  DynoIvec2,
  DynoIvec3,
  DynoIvec4,
  DynoLiteral,
  DynoMat2,
  DynoMat2x2,
  DynoMat2x3,
  DynoMat2x4,
  DynoMat3,
  DynoMat3x2,
  DynoMat3x3,
  DynoMat3x4,
  DynoMat4,
  DynoMat4x2,
  DynoMat4x3,
  DynoMat4x4,
  DynoOutput,
  DynoProgram,
  DynoProgramTemplate,
  DynoRemapIndex,
  DynoSampler2D,
  DynoSampler2DArray,
  DynoSampler2DArrayShadow,
  DynoSampler2DShadow,
  DynoSampler3D,
  DynoSamplerCube,
  DynoSamplerCubeShadow,
  DynoUint,
  DynoUniform,
  DynoUsampler2D,
  DynoUsampler2DArray,
  DynoUsampler3D,
  DynoUsamplerCube,
  DynoUvec2,
  DynoUvec3,
  DynoUvec4,
  DynoValue,
  DynoVec2,
  DynoVec3,
  DynoVec4,
  Equal,
  Exp,
  Exp2,
  ExtendVec,
  FaceForward,
  Float,
  FloatBitsToInt,
  FloatBitsToUint,
  Floor,
  Fract,
  GreaterThan,
  GreaterThanEqual,
  Gsplat,
  GsplatNormal,
  Hash,
  Hash2,
  Hash3,
  Hash4,
  HashFloat,
  HashVec2,
  HashVec3,
  HashVec4,
  IMod,
  IVec2,
  IVec3,
  IVec4,
  Int,
  IntBitsToFloat,
  Inverse,
  InverseSqrt,
  IsInf,
  IsNan,
  Length,
  LessThan,
  LessThanEqual,
  Log,
  Log2,
  Mat2,
  Mat3,
  Mat4,
  Max,
  Min,
  Mix,
  Mod,
  Modf,
  Mul,
  Neg,
  Normalize,
  NormalizedDepth,
  Not,
  NotEqual,
  NumPackedSplats,
  Or,
  Outer,
  OutputPackedSplat,
  OutputRgba8,
  PackHalf2x16,
  PackSnorm2x16,
  PackUnorm2x16,
  PcgHash,
  PcgMix,
  PcgNext,
  Pow,
  ProjectH,
  Radians,
  ReadPackedSplat,
  ReadPackedSplatRange,
  ReflectVec,
  RefractVec,
  Round,
  Select,
  Sign,
  SimpleCast,
  Sin,
  Sinh,
  Smoothstep,
  Split,
  SplitGsplat,
  Sqr,
  Sqrt,
  Step,
  Sub,
  Swizzle,
  TPackedSplats,
  Tan,
  Tanh,
  TexelFetch,
  Texture: Texture$1,
  TextureSize,
  TransformDir,
  TransformGsplat,
  TransformPosition,
  TransformQuaternion,
  Transpose,
  TrinaryOp,
  Trunc,
  UVec2,
  UVec3,
  UVec4,
  Uint,
  UintBitsToFloat,
  UintToRgba8,
  UnaryOp,
  UnpackHalf2x16,
  UnpackSnorm2x16,
  UnpackUnorm2x16,
  Vec2,
  Vec3,
  Vec4,
  Xor,
  abs: abs$3,
  acos: acos$1,
  acosh,
  add: add$4,
  all: all$1,
  and: and$1,
  any: any$1,
  arrayIndex,
  arrayLength,
  asin: asin$1,
  asinh,
  atan: atan$1,
  atan2: atan2$1,
  atanh,
  bool: bool$1,
  bvec2: bvec2$1,
  bvec3: bvec3$1,
  bvec4: bvec4$1,
  ceil: ceil$1,
  clamp: clamp$3,
  combine,
  combineGsplat,
  comment,
  compMult,
  compXor,
  cos: cos$2,
  cosh,
  cross: cross$2,
  defineGsplat,
  defineGsplatNormal,
  definePackedSplats,
  degrees: degrees$1,
  determinant: determinant$1,
  distance: distance$1,
  div: div$3,
  dot: dot$4,
  dyno: dyno$1,
  dynoBlock,
  dynoBool,
  dynoBvec2,
  dynoBvec3,
  dynoBvec4,
  dynoConst,
  dynoDeclare,
  dynoFloat,
  dynoFor,
  dynoIf,
  dynoInt,
  dynoIsampler2D,
  dynoIsampler2DArray,
  dynoIsampler3D,
  dynoIsamplerCube,
  dynoIvec2,
  dynoIvec3,
  dynoIvec4,
  dynoLiteral,
  dynoMat2,
  dynoMat2x2,
  dynoMat2x3,
  dynoMat2x4,
  dynoMat3,
  dynoMat3x2,
  dynoMat3x3,
  dynoMat3x4,
  dynoMat4,
  dynoMat4x2,
  dynoMat4x3,
  dynoMat4x4,
  dynoSampler2D,
  dynoSampler2DArray,
  dynoSampler2DArrayShadow,
  dynoSampler2DShadow,
  dynoSampler3D,
  dynoSamplerCube,
  dynoSamplerCubeShadow,
  dynoSwitch,
  dynoUint,
  dynoUsampler2D,
  dynoUsampler2DArray,
  dynoUsampler3D,
  dynoUsamplerCube,
  dynoUvec2,
  dynoUvec3,
  dynoUvec4,
  dynoVec2,
  dynoVec3,
  dynoVec4,
  equal: equal$1,
  exp: exp$3,
  exp2: exp2$1,
  extendVec,
  faceforward: faceforward$1,
  float: float$5,
  floatBitsToInt: floatBitsToInt$1,
  floatBitsToUint: floatBitsToUint$1,
  floor: floor$1,
  fract: fract$1,
  greaterThan: greaterThan$1,
  greaterThanEqual: greaterThanEqual$1,
  gsplatNormal,
  hash: hash$2,
  hash2,
  hash3,
  hash4,
  hashFloat,
  hashVec2,
  hashVec3,
  hashVec4,
  imod,
  int: int$4,
  intBitsToFloat: intBitsToFloat$1,
  inverse: inverse$1,
  inversesqrt: inversesqrt$1,
  isAllFloatType,
  isBoolType,
  isFloatType,
  isInf,
  isIntType,
  isMat2,
  isMat3,
  isMat4,
  isMatFloatType,
  isNan,
  isScalarType,
  isUintType,
  isVector2Type,
  isVector3Type,
  isVector4Type,
  isVectorType,
  ivec2: ivec2$3,
  ivec3: ivec3$4,
  ivec4: ivec4$1,
  length: length$1,
  lessThan: lessThan$1,
  lessThanEqual: lessThanEqual$1,
  literalNegOne,
  literalOne,
  literalZero,
  log: log$3,
  log2: log2$1,
  mat2: mat2$1,
  mat3: mat3$1,
  mat4: mat4$1,
  max: max$3,
  min: min$3,
  mix: mix$1,
  mod: mod$1,
  modf,
  mul: mul$4,
  neg,
  normalize: normalize$3,
  normalizedDepth,
  not: not$1,
  notEqual: notEqual$1,
  numPackedSplats,
  numberAsFloat,
  numberAsInt,
  numberAsUint,
  or: or$1,
  outer,
  outputPackedSplat,
  outputRgba8,
  packHalf2x16: packHalf2x16$1,
  packSnorm2x16: packSnorm2x16$1,
  packUnorm2x16: packUnorm2x16$1,
  pcgHash,
  pcgMix,
  pcgNext,
  pow: pow$1,
  projectH,
  radians: radians$1,
  readPackedSplat,
  readPackedSplatRange,
  reflectVec,
  refractVec,
  remapIndex,
  round: round$1,
  sameSizeIvec,
  sameSizeUvec,
  sameSizeVec,
  select: select$4,
  sign: sign$1,
  sin: sin$2,
  sinh,
  smoothstep: smoothstep$2,
  split: split$1,
  splitGsplat,
  sqr,
  sqrt: sqrt$4,
  step: step$1,
  sub: sub$4,
  swizzle,
  tan: tan$1,
  tanh,
  texelFetch,
  texture: texture$3,
  textureSize: textureSize$1,
  transformDir,
  transformGsplat,
  transformPos,
  transformQuat,
  transpose: transpose$1,
  trunc: trunc$1,
  typeLiteral,
  uint: uint$4,
  uintBitsToFloat: uintBitsToFloat$1,
  uintToRgba8,
  uniform: uniform$3,
  unindent,
  unindentLines,
  unpackHalf2x16: unpackHalf2x16$2,
  unpackSnorm2x16: unpackSnorm2x16$1,
  unpackUnorm2x16: unpackUnorm2x16$1,
  uvec2: uvec2$1,
  uvec3: uvec3$1,
  uvec4: uvec4$1,
  valType,
  vec2: vec2$3,
  vec3: vec3$3,
  vec4: vec4$4,
  vectorDim,
  vectorElementType,
  xor: xor$1
}, Symbol.toStringTag, { value: "Module" }));
var computeUvec4_default = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}";
var computeVec4_default = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}";
var splatDefines_default = "const float LN_SCALE_MIN = -12.0;\nconst float LN_SCALE_MAX = 9.0;\n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplatEncoding(\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\n) {\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\n    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvoid unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    rgba = (vec4(uRgba) / 255.0);\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\n        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\n        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}";
var splatFragment_default = "precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n#include <logdepthbuf_pars_fragment>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float time;\nuniform bool debugFlag;\nuniform float maxStdDev;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\nflat in uint vSplatIndex;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < minAlpha) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n\n    if (stochastic) {\n        const bool STEADY = false;\n        uint uTime = STEADY ? 0u : floatBitsToUint(time);\n        uvec2 coord = uvec2(gl_FragCoord.xy);\n        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\n        state = state * 747796405u + 2891336453u;\n        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n        hash = (hash >> 22u) ^ hash;\n        float rand = float(hash) / 4294967296.0;\n        if (rand < rgba.a) {\n            fragColor = vec4(rgba.rgb, 1.0);\n        } else {\n            discard;\n        }\n    } else {\n        #ifdef PREMULTIPLIED_ALPHA\n            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\n        #else\n            fragColor = rgba;\n        #endif\n    }\n    #include <logdepthbuf_fragment>\n}";
var splatVertex_default = "precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n#include <logdepthbuf_pars_vertex>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\nflat out uint vSplatIndex;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float minPixelRadius;\nuniform float maxPixelRadius;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float focalAdjustment;\n\nuniform usampler2DArray packedSplats;\nuniform vec4 rgbMinMaxLnScaleMinMax;\n\n#ifdef USE_LOGDEPTHBUF\n    bool isPerspectiveMatrix( mat4 m ) {\n      return m[ 2 ][ 3 ] == - 1.0;\n    }\n#endif\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n\n    ivec3 texCoord;\n    if (stochastic) {\n        texCoord = ivec3(\n            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\n        );\n    } else {\n        if (splatIndex == 0xffffffffu) {\n            \n            return;\n        }\n        texCoord = ivec3(\n            splatIndex & SPLAT_TEX_WIDTH_MASK,\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            splatIndex >> SPLAT_TEX_LAYER_BITS\n        );\n    }\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);\n\n    if (rgba.a < minAlpha) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vSplatIndex = splatIndex;\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * focalAdjustment;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n\n    mat3 J;\n    if(isOrthographic) {\n        J = mat3(\n            focal.x, 0.0, 0.0,\n            0.0, focal.y, 0.0,\n            0.0, 0.0, 0.0\n        );\n    } else {\n        float invZ = 1.0 / viewCenter.z;\n        vec2 J1 = focal * invZ;\n        vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n        J = mat3(\n            J1.x, 0.0, J2.x,\n            0.0, J1.y, J2.y,\n            0.0, 0.0, 0.0\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = maxPixelRadius;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < minAlpha) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));\n    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));\n    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {\n        return;\n    }\n\n    \n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n    #include <logdepthbuf_vertex>\n}";
let shaders = null;
function getShaders() {
  if (!shaders) {
    THREE.ShaderChunk.splatDefines = splatDefines_default;
    shaders = {
      splatVertex: splatVertex_default,
      splatFragment: splatFragment_default,
      computeVec4Template: computeVec4_default,
      computeUvec4Template: computeUvec4_default
    };
  }
  return shaders;
}
const _Readback = class _Readback {
  constructor({ renderer } = {}) {
    this.renderer = renderer;
    this.capacity = 0;
    this.count = 0;
  }
  dispose() {
    if (this.target) {
      this.target.dispose();
      this.target = void 0;
    }
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(count, buffer2) {
    const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
    const bytes = roundedCount * 4;
    if (buffer2.byteLength >= bytes) {
      return buffer2;
    }
    const newBuffer = new ArrayBuffer(bytes);
    if (buffer2 instanceof ArrayBuffer) {
      return newBuffer;
    }
    const ctor = buffer2.constructor;
    return new ctor(newBuffer);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(capacity) {
    const { width, height, depth: depth2, maxSplats } = getTextureSize(capacity);
    if (!this.target || maxSplats > this.capacity) {
      this.dispose();
      this.capacity = maxSplats;
      this.target = new THREE.WebGLArrayRenderTarget(width, height, depth2, {
        depthBuffer: false,
        stencilBuffer: false,
        generateMipmaps: false,
        magFilter: THREE.NearestFilter,
        minFilter: THREE.NearestFilter
      });
      this.target.texture.format = THREE.RGBAFormat;
      this.target.texture.type = THREE.UnsignedByteType;
      setTextureInternalFormat(this.target.texture, "RGBA8");
      this.target.scissorTest = true;
    }
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(reader) {
    let program = _Readback.readbackProgram.get(reader);
    if (!program) {
      const graph = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          reader.inputs.index = index;
          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });
          return { rgba8 };
        }
      );
      if (!_Readback.programTemplate) {
        _Readback.programTemplate = new DynoProgramTemplate(
          getShaders().computeVec4Template
        );
      }
      program = new DynoProgram({
        graph,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: _Readback.programTemplate
      });
      Object.assign(program.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      });
      _Readback.readbackProgram.set(reader, program);
    }
    const material = program.prepareMaterial();
    _Readback.fullScreenQuad.material = material;
    return { program, material };
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
  process({
    count,
    material
  }) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("No renderer");
    }
    if (!this.target) {
      throw new Error("No target");
    }
    const layerSize = SPLAT_TEX_WIDTH$1 * SPLAT_TEX_HEIGHT$1;
    material.uniforms.targetBase.value = 0;
    material.uniforms.targetCount.value = count;
    let baseIndex = 0;
    while (baseIndex < count) {
      const layer = Math.floor(baseIndex / layerSize);
      const layerBase = layer * layerSize;
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT$1,
        Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH$1)
      );
      material.uniforms.targetLayer.value = layer;
      this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH$1, layerYEnd);
      renderer.setRenderTarget(this.target, layer);
      renderer.xr.enabled = false;
      renderer.autoClear = false;
      _Readback.fullScreenQuad.render(renderer);
      baseIndex += SPLAT_TEX_WIDTH$1 * layerYEnd;
    }
    this.count = count;
  }
  async read({
    readback
  }) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("No renderer");
    }
    if (!this.target) {
      throw new Error("No target");
    }
    const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
    if (readback.byteLength < roundedCount * 4) {
      throw new Error(
        `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`
      );
    }
    const readbackUint8 = new Uint8Array(
      readback instanceof ArrayBuffer ? readback : readback.buffer
    );
    const layerSize = SPLAT_TEX_WIDTH$1 * SPLAT_TEX_HEIGHT$1;
    let baseIndex = 0;
    const promises = [];
    while (baseIndex < this.count) {
      const layer = Math.floor(baseIndex / layerSize);
      const layerBase = layer * layerSize;
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT$1,
        Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH$1)
      );
      renderer.setRenderTarget(this.target, layer);
      const readbackSize = SPLAT_TEX_WIDTH$1 * layerYEnd * 4;
      const subReadback = readbackUint8.subarray(
        layerBase * 4,
        layerBase * 4 + readbackSize
      );
      const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        SPLAT_TEX_WIDTH$1,
        layerYEnd,
        subReadback
      );
      promises.push(promise);
      baseIndex += SPLAT_TEX_WIDTH$1 * layerYEnd;
    }
    return Promise.all(promises).then(() => readback);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader,
    count,
    renderer
  }) {
    this.renderer = renderer || this.renderer;
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    this.ensureCapacity(count);
    const { program, material } = this.prepareProgramMaterial(reader);
    program.update();
    const renderState = this.saveRenderState(this.renderer);
    this.process({ count, material });
    this.resetRenderState(this.renderer, renderState);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback
  }) {
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    const renderState = this.saveRenderState(this.renderer);
    const promise = this.read({ readback });
    this.resetRenderState(this.renderer, renderState);
    return promise;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader,
    count,
    renderer,
    readback
  }) {
    this.renderer = renderer || this.renderer;
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    this.ensureCapacity(count);
    const { program, material } = this.prepareProgramMaterial(reader);
    program.update();
    const renderState = this.saveRenderState(this.renderer);
    this.process({ count, material });
    const promise = this.read({ readback });
    this.resetRenderState(this.renderer, renderState);
    return promise;
  }
  getTexture() {
    var _a2;
    return (_a2 = this.target) == null ? void 0 : _a2.texture;
  }
};
_Readback.programTemplate = null;
_Readback.readbackProgram = /* @__PURE__ */ new Map();
_Readback.fullScreenQuad = new FullScreenQuad(
  new THREE.RawShaderMaterial({ visible: false })
);
let Readback = _Readback;
const _RgbaArray = class _RgbaArray {
  constructor(options = {}) {
    this.capacity = 0;
    this.count = 0;
    this.array = null;
    this.readback = null;
    this.source = null;
    this.needsUpdate = true;
    this.dyno = new DynoUniform({
      key: "rgbaArray",
      type: TRgbaArray,
      globals: () => [defineRgbaArray],
      value: {
        texture: _RgbaArray.getEmpty(),
        count: 0
      },
      update: (value) => {
        var _a2;
        value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();
        value.count = this.count;
        return value;
      }
    });
    if (options.array) {
      this.array = options.array;
      this.capacity = Math.floor(this.array.length / 4);
      this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
      this.count = Math.min(
        this.capacity,
        options.count ?? Number.POSITIVE_INFINITY
      );
    } else {
      this.capacity = options.capacity ?? 0;
      this.count = 0;
    }
  }
  // Free up resources
  dispose() {
    if (this.readback) {
      this.readback.dispose();
      this.readback = null;
    }
    if (this.source) {
      this.source.dispose();
      this.source = null;
    }
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(capacity) {
    var _a2;
    if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {
      this.capacity = getTextureSize(capacity).maxSplats;
      const newArray2 = new Uint8Array(this.capacity * 4);
      if (this.array) {
        newArray2.set(this.array);
      }
      this.array = newArray2;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var _a2;
    let texture2 = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();
    if (this.source || this.array) {
      texture2 = this.maybeUpdateSource();
    }
    return texture2 ?? _RgbaArray.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array) {
      throw new Error("No array");
    }
    if (this.needsUpdate || !this.source) {
      this.needsUpdate = false;
      if (this.source) {
        const { width, height, depth: depth2 } = this.source.image;
        if (this.capacity !== width * height * depth2) {
          this.source.dispose();
          this.source = null;
        }
      }
      if (!this.source) {
        const { width, height, depth: depth2 } = getTextureSize(this.capacity);
        this.source = new THREE.DataArrayTexture(
          this.array,
          width,
          height,
          depth2
        );
        this.source.format = THREE.RGBAFormat;
        this.source.type = THREE.UnsignedByteType;
        setTextureInternalFormat(this.source, "RGBA8");
        this.source.needsUpdate = true;
      } else if (this.array.buffer !== this.source.image.data.buffer) {
        this.source.image.data = new Uint8Array(this.array.buffer);
      }
      this.source.needsUpdate = true;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader,
    count,
    renderer
  }) {
    if (!this.readback) {
      this.readback = new Readback({ renderer });
    }
    this.readback.render({ reader, count, renderer });
    this.capacity = this.readback.capacity;
    this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats,
    base,
    count,
    renderer
  }) {
    const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();
    dynoSplats.packedSplats = packedSplats;
    dynoBase.value = base;
    dynoCount.value = count;
    this.render({ reader, count, renderer });
    return this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback) {
      throw new Error("No readback");
    }
    if (!this.array || this.array.length < this.count * 4) {
      this.array = new Uint8Array(this.capacity * 4);
    }
    const result = await this.readback.readback({ readback: this.array });
    return result.subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!_RgbaArray.emptySource) {
      const emptyArray = new Uint8Array(1 * 4);
      _RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, 1, 1);
      _RgbaArray.emptySource.format = THREE.RGBAFormat;
      _RgbaArray.emptySource.type = THREE.UnsignedByteType;
      setTextureInternalFormat(_RgbaArray.emptySource, "RGBA8");
      _RgbaArray.emptySource.needsUpdate = true;
    }
    return _RgbaArray.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!_RgbaArray.dynos) {
      const dynoSplats = new DynoPackedSplats();
      const dynoBase = new DynoInt({ value: 0 });
      const dynoCount = new DynoInt({ value: 0 });
      const reader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("index is undefined");
          }
          index = add$4(index, dynoBase);
          const gsplat = readPackedSplatRange(
            dynoSplats,
            index,
            dynoBase,
            dynoCount
          );
          return { rgba8: splitGsplat(gsplat).outputs.rgba };
        }
      );
      _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };
    }
    return _RgbaArray.dynos;
  }
};
_RgbaArray.emptySource = null;
_RgbaArray.dynos = null;
let RgbaArray = _RgbaArray;
const TRgbaArray = { type: "RgbaArray" };
const defineRgbaArray = unindent(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function readRgbaArray(rgba, index) {
  const dyno2 = new Dyno({
    inTypes: { rgba: TRgbaArray, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba, index },
    globals: () => [defineRgbaArray],
    statements: ({ inputs, outputs }) => unindentLines(`
        if ((index >= 0) && (index < ${inputs.rgba}.count)) {
          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  });
  return dyno2.outputs.rgba;
}
var SplatEditSdfType = /* @__PURE__ */ ((SplatEditSdfType2) => {
  SplatEditSdfType2["ALL"] = "all";
  SplatEditSdfType2["PLANE"] = "plane";
  SplatEditSdfType2["SPHERE"] = "sphere";
  SplatEditSdfType2["BOX"] = "box";
  SplatEditSdfType2["ELLIPSOID"] = "ellipsoid";
  SplatEditSdfType2["CYLINDER"] = "cylinder";
  SplatEditSdfType2["CAPSULE"] = "capsule";
  SplatEditSdfType2["INFINITE_CONE"] = "infinite_cone";
  return SplatEditSdfType2;
})(SplatEditSdfType || {});
function sdfTypeToNumber(type) {
  switch (type) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${type}`);
  }
}
var SplatEditRgbaBlendMode = /* @__PURE__ */ ((SplatEditRgbaBlendMode2) => {
  SplatEditRgbaBlendMode2["MULTIPLY"] = "multiply";
  SplatEditRgbaBlendMode2["SET_RGB"] = "set_rgb";
  SplatEditRgbaBlendMode2["ADD_RGBA"] = "add_rgba";
  return SplatEditRgbaBlendMode2;
})(SplatEditRgbaBlendMode || {});
function rgbaBlendModeToNumber(mode) {
  switch (mode) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${mode}`);
  }
}
class SplatEditSdf extends THREE.Object3D {
  constructor(options = {}) {
    super();
    const { type, invert, opacity, color: color2, displace, radius } = options;
    this.type = type ?? "sphere";
    this.invert = invert ?? false;
    this.opacity = opacity ?? 1;
    this.color = color2 ?? new THREE.Color(1, 1, 1);
    this.displace = displace ?? new THREE.Vector3(0, 0, 0);
    this.radius = radius ?? 0;
  }
}
const _SplatEdit = class _SplatEdit extends THREE.Object3D {
  constructor(options = {}) {
    const {
      name,
      rgbaBlendMode = "multiply",
      sdfSmooth = 0,
      softEdge = 0,
      invert = false,
      sdfs = null
    } = options;
    super();
    this.rgbaBlendMode = rgbaBlendMode;
    this.sdfSmooth = sdfSmooth;
    this.softEdge = softEdge;
    this.invert = invert;
    this.sdfs = sdfs;
    this.ordering = _SplatEdit.nextOrdering++;
    this.name = name ?? `Edit ${this.ordering}`;
  }
  addSdf(sdf) {
    if (this.sdfs == null) {
      this.sdfs = [];
    }
    if (!this.sdfs.includes(sdf)) {
      this.sdfs.push(sdf);
    }
  }
  removeSdf(sdf) {
    if (this.sdfs == null) {
      return;
    }
    this.sdfs = this.sdfs.filter((s) => s !== sdf);
  }
};
_SplatEdit.nextOrdering = 1;
let SplatEdit = _SplatEdit;
class SplatEdits {
  constructor({ maxSdfs, maxEdits }) {
    this.maxSdfs = Math.max(16, maxSdfs ?? 0);
    this.numSdfs = 0;
    this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
    this.sdfFloatData = new Float32Array(this.sdfData.buffer);
    this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
    this.dynoSdfArray = new DynoUniform({
      key: "sdfArray",
      type: SdfArray,
      globals: () => [defineSdfArray],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (uniform2) => {
        uniform2.numSdfs = this.numSdfs;
        uniform2.sdfTexture = this.sdfTexture;
        return uniform2;
      }
    });
    this.maxEdits = Math.max(16, maxEdits ?? 0);
    this.numEdits = 0;
    this.editData = new Uint32Array(this.maxEdits * 4);
    this.editFloatData = new Float32Array(this.editData.buffer);
    this.dynoNumEdits = new DynoInt({ value: 0 });
    this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(data, maxSdfs) {
    const texture2 = new THREE.DataTexture(
      data,
      8,
      maxSdfs,
      THREE.RGBAIntegerFormat,
      THREE.UnsignedIntType
    );
    setTextureInternalFormat(texture2, "RGBA32UI");
    texture2.needsUpdate = true;
    return texture2;
  }
  newEdits(data, maxEdits) {
    return new DynoUniform({
      key: "edits",
      type: "uvec4",
      count: maxEdits,
      globals: () => [defineEdit],
      value: data
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs,
    maxEdits
  }) {
    let dynoUpdated = false;
    if (maxSdfs > this.sdfTexture.image.height) {
      this.sdfTexture.dispose();
      this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);
      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
      this.sdfFloatData = new Float32Array(this.sdfData.buffer);
      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
    }
    if (maxEdits > (this.dynoEdits.count ?? 0)) {
      this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);
      this.editData = new Uint32Array(this.maxEdits * 4);
      this.editFloatData = new Float32Array(this.editData.buffer);
      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
      dynoUpdated = true;
    }
    return dynoUpdated;
  }
  updateEditData(offset, value) {
    const updated = this.editData[offset] !== value;
    this.editData[offset] = value;
    return updated;
  }
  updateEditFloatData(offset, value) {
    tempFloat32[0] = value;
    const updated = this.editFloatData[offset] !== tempFloat32[0];
    if (updated) {
      this.editFloatData[offset] = tempFloat32[0];
    }
    return updated;
  }
  encodeEdit(editIndex, {
    sdfFirst,
    sdfCount,
    invert,
    rgbaBlendMode,
    softEdge,
    sdfSmooth
  }) {
    const base = editIndex * 4;
    let updated = false;
    updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;
    updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;
    updated = this.updateEditFloatData(base + 2, softEdge) || updated;
    updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;
    return updated;
  }
  updateSdfData(offset, value) {
    const updated = this.sdfData[offset] !== value;
    this.sdfData[offset] = value;
    return updated;
  }
  updateSdfFloatData(offset, value) {
    tempFloat32[0] = value;
    const updated = this.sdfFloatData[offset] !== tempFloat32[0];
    if (updated) {
      this.sdfFloatData[offset] = tempFloat32[0];
    }
    return updated;
  }
  encodeSdf(sdfIndex, {
    sdfType,
    invert,
    center,
    quaternion,
    scale,
    sizes
  }, values) {
    const base = sdfIndex * (8 * 4);
    const flags = sdfType | (invert ? 1 << 8 : 0);
    let updated = false;
    updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;
    updated = this.updateSdfData(base + 3, flags) || updated;
    updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;
    updated = this.updateSdfData(base + 11, 0) || updated;
    updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;
    const nValues = Math.min(4, values.length);
    for (let i = 0; i < nValues; ++i) {
      const vBase = base + 16 + i * 4;
      updated = this.updateSdfFloatData(vBase + 0, values[i].x) || updated;
      updated = this.updateSdfFloatData(vBase + 1, values[i].y) || updated;
      updated = this.updateSdfFloatData(vBase + 2, values[i].z) || updated;
      updated = this.updateSdfFloatData(vBase + 3, values[i].w) || updated;
    }
    return updated;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(edits) {
    const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);
    const dynoUpdated = this.ensureCapacity({
      maxEdits: edits.length,
      maxSdfs: sdfCount
    });
    const values = [new THREE.Vector4(), new THREE.Vector4()];
    const center = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    const sizes = new THREE.Vector4();
    let sdfIndex = 0;
    let updated = dynoUpdated;
    if (edits.length !== this.dynoNumEdits.value) {
      this.dynoNumEdits.value = edits.length;
      this.numEdits = edits.length;
      updated = true;
    }
    for (const [editIndex, { edit, sdfs }] of edits.entries()) {
      updated = this.encodeEdit(editIndex, {
        sdfFirst: sdfIndex,
        sdfCount: sdfs.length,
        invert: edit.invert,
        rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),
        softEdge: edit.softEdge,
        sdfSmooth: edit.sdfSmooth
      }) || updated;
      let sdfUpdated = false;
      for (const sdf of sdfs) {
        sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);
        sdf.scale.setScalar(1);
        sdf.updateMatrixWorld();
        const worldToSdf = sdf.matrixWorld.clone().invert();
        worldToSdf.decompose(center, quaternion, scale);
        sdf.scale.set(sizes.x, sizes.y, sizes.z);
        sdf.updateMatrixWorld();
        values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);
        values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);
        sdfUpdated = this.encodeSdf(
          sdfIndex,
          {
            sdfType: sdfTypeToNumber(sdf.type),
            invert: sdf.invert,
            center,
            quaternion,
            scale,
            sizes
          },
          values
        ) || sdfUpdated;
        sdfIndex += 1;
      }
      this.numSdfs = sdfIndex;
      if (sdfUpdated) {
        this.sdfTexture.needsUpdate = true;
      }
      updated || (updated = sdfUpdated);
    }
    return { updated, dynoUpdated };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(gsplat) {
    return applyGsplatRgbaDisplaceEdits(
      gsplat,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const SdfArray = { type: "SdfArray" };
const defineSdfArray = unindent(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`);
const defineEdit = unindent(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {
  const dyno2 = new Dyno({
    inTypes: {
      gsplat: Gsplat,
      sdfArray: SdfArray,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: Gsplat },
    globals: () => [defineSdfArray, defineEdit],
    inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },
    statements: ({ inputs, outputs }) => {
      const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;
      const { gsplat: gsplat2 } = outputs;
      return unindentLines(`
        ${gsplat2} = ${inputs.gsplat};
        if (isGsplatActive(${gsplat2}.flags)) {
          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,
              ${gsplat2}.center, ${gsplat2}.rgba
            );
          }
        }
      `);
    }
  });
  return dyno2.outputs.gsplat;
}
const tempFloat32 = new Float32Array(1);
class SplatModifier {
  constructor(modifier) {
    this.modifier = modifier;
    this.cache = /* @__PURE__ */ new Map();
  }
  apply(generator) {
    let modified = this.cache.get(generator);
    if (!modified) {
      modified = dynoBlock(
        { index: "int" },
        { gsplat: Gsplat },
        ({ index }) => {
          const { gsplat } = generator.apply({ index });
          return this.modifier.apply({ gsplat });
        }
      );
      this.cache.set(generator, modified);
    }
    return modified;
  }
}
class SplatTransformer {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });
    this.rotate = new DynoVec4({
      value: new THREE.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
    this.translate = new DynoVec3({
      value: new THREE.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(position) {
    return transformPos(position, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(dir) {
    return transformDir(dir, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(gsplat) {
    return transformGsplat(gsplat, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(transform) {
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const position = new THREE.Vector3();
    transform.decompose(position, quaternion, scale);
    const newScale = (scale.x + scale.y + scale.z) / 3;
    let updated = false;
    if (newScale !== this.scale.value) {
      this.scale.value = newScale;
      updated = true;
    }
    if (!position.equals(this.translate.value)) {
      this.translate.value.copy(position);
      updated = true;
    }
    if (!quaternion.equals(this.rotate.value)) {
      this.rotate.value.copy(quaternion);
      updated = true;
    }
    return updated;
  }
  // Update this transform to match the object's to-world transform.
  update(object) {
    object.updateMatrixWorld();
    return this.updateFromMatrix(object.matrixWorld);
  }
}
class SplatGenerator extends THREE.Object3D {
  constructor({
    numSplats,
    generator,
    construct,
    update
  }) {
    super();
    this.numSplats = numSplats ?? 0;
    this.generator = generator;
    this.frameUpdate = update;
    this.version = 0;
    if (construct) {
      const constructed = construct(this);
      Object.assign(this, constructed);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(value) {
    if (value) {
      this.updateVersion();
    }
  }
}
const _SplatMesh = class _SplatMesh extends SplatGenerator {
  constructor(options = {}) {
    const transform = new SplatTransformer();
    const viewToWorld = new SplatTransformer();
    const worldToView = new SplatTransformer();
    const viewToObject = new SplatTransformer();
    const recolor = new DynoVec4({
      value: new THREE.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    });
    const time2 = new DynoFloat({ value: 0 });
    const deltaTime2 = new DynoFloat({ value: 0 });
    const context2 = {
      transform,
      viewToWorld,
      worldToView,
      viewToObject,
      recolor,
      time: time2,
      deltaTime: deltaTime2
    };
    super({
      update: ({ time: time22, deltaTime: deltaTime22, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time22, deltaTime: deltaTime22, viewToWorld: viewToWorld2, globalEdits })
    });
    this.isInitialized = false;
    this.recolor = new THREE.Color(1, 1, 1);
    this.opacity = 1;
    this.enableViewToObject = false;
    this.enableViewToWorld = false;
    this.enableWorldToView = false;
    this.skinning = null;
    this.edits = null;
    this.rgbaDisplaceEdits = null;
    this.splatRgba = null;
    this.maxSh = 3;
    this.packedSplats = options.packedSplats ?? new PackedSplats();
    this.packedSplats.splatEncoding = options.splatEncoding ?? {
      ...DEFAULT_SPLAT_ENCODING
    };
    this.numSplats = this.packedSplats.numSplats;
    this.editable = options.editable ?? true;
    this.onFrame = options.onFrame;
    this.context = context2;
    this.objectModifier = options.objectModifier;
    this.worldModifier = options.worldModifier;
    this.updateGenerator();
    if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {
      this.initialized = this.asyncInitialize(options).then(async () => {
        this.updateGenerator();
        this.isInitialized = true;
        if (options.onLoad) {
          const maybePromise = options.onLoad(this);
          if (maybePromise instanceof Promise) {
            await maybePromise;
          }
        }
        return this;
      });
    } else {
      this.isInitialized = true;
      this.initialized = Promise.resolve(this);
      if (options.onLoad) {
        const maybePromise = options.onLoad(this);
        if (maybePromise instanceof Promise) {
          this.initialized = maybePromise.then(() => this);
        }
      }
    }
    this.add(createRendererDetectionMesh());
  }
  async asyncInitialize(options) {
    const {
      url,
      fileBytes,
      fileType,
      fileName,
      maxSplats,
      constructSplats,
      splatEncoding
    } = options;
    if (url || fileBytes || constructSplats) {
      const packedSplatsOptions = {
        url,
        fileBytes,
        fileType,
        fileName,
        maxSplats,
        construct: constructSplats,
        splatEncoding
      };
      this.packedSplats.reinitialize(packedSplatsOptions);
    }
    if (this.packedSplats) {
      await this.packedSplats.initialized;
      this.numSplats = this.packedSplats.numSplats;
      this.updateGenerator();
    }
  }
  static async staticInitialize() {
    await __wbg_init();
    _SplatMesh.isStaticInitialized = true;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(center, scales, quaternion, opacity, color2) {
    this.packedSplats.pushSplat(center, scales, quaternion, opacity, color2);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(callback) {
    this.packedSplats.forEachSplat(callback);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,
  // only the centers of the splats are used to compute the bounding box.
  // IMPORTANT: This should only be called after the SplatMesh is initialized.
  getBoundingBox(centers_only = true) {
    if (!this.initialized) {
      throw new Error(
        "Cannot get bounding box before SplatMesh is initialized"
      );
    }
    const minVec = new THREE.Vector3(
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY
    );
    const maxVec = new THREE.Vector3(
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY
    );
    const corners = new THREE.Vector3();
    const signs = [-1, 1];
    this.packedSplats.forEachSplat(
      (_index, center, scales, quaternion, _opacity, _color2) => {
        if (centers_only) {
          minVec.min(center);
          maxVec.max(center);
        } else {
          for (const x of signs) {
            for (const y of signs) {
              for (const z of signs) {
                corners.set(x * scales.x, y * scales.y, z * scales.z);
                corners.applyQuaternion(quaternion);
                corners.add(center);
                minVec.min(corners);
                maxVec.max(corners);
              }
            }
          }
        }
      }
    );
    const box = new THREE.Box3(minVec, maxVec);
    return box;
  }
  constructGenerator(context2) {
    const { transform, viewToObject, recolor } = context2;
    const generator = dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index is undefined");
        }
        let gsplat = readPackedSplat(this.packedSplats.dyno, index);
        if (this.maxSh >= 1) {
          const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();
          if (sh1Texture) {
            let rescaleSh = function(sNorm, minMax) {
              const { x: min2, y: max2 } = split$1(minMax).outputs;
              const mid = mul$4(add$4(min2, max2), dynoConst("float", 0.5));
              const scale = mul$4(sub$4(max2, min2), dynoConst("float", 0.5));
              return add$4(mid, mul$4(sNorm, scale));
            };
            const viewCenterInObject = viewToObject.translate;
            const { center } = splitGsplat(gsplat).outputs;
            const viewDir = normalize$3(sub$4(center, viewCenterInObject));
            const sh1Snorm = evaluateSH1(gsplat, sh1Texture, viewDir);
            let rgb = rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);
            if (this.maxSh >= 2 && sh2Texture) {
              const sh2Snorm = evaluateSH2(gsplat, sh2Texture, viewDir);
              rgb = add$4(
                rgb,
                rescaleSh(sh2Snorm, this.packedSplats.dynoSh2MinMax)
              );
            }
            if (this.maxSh >= 3 && sh3Texture) {
              const sh3Snorm = evaluateSH3(gsplat, sh3Texture, viewDir);
              rgb = add$4(
                rgb,
                rescaleSh(sh3Snorm, this.packedSplats.dynoSh3MinMax)
              );
            }
            let { rgba } = splitGsplat(gsplat).outputs;
            rgba = add$4(rgba, extendVec(rgb, dynoConst("float", 0)));
            gsplat = combineGsplat({ gsplat, rgba });
          }
        }
        if (this.splatRgba) {
          const rgba = readRgbaArray(this.splatRgba.dyno, index);
          gsplat = combineGsplat({ gsplat, rgba });
        }
        if (this.skinning) {
          gsplat = this.skinning.modify(gsplat);
        }
        if (this.objectModifier) {
          gsplat = this.objectModifier.apply({ gsplat }).gsplat;
        }
        gsplat = transform.applyGsplat(gsplat);
        const recolorRgba = mul$4(recolor, splitGsplat(gsplat).outputs.rgba);
        gsplat = combineGsplat({ gsplat, rgba: recolorRgba });
        if (this.rgbaDisplaceEdits) {
          gsplat = this.rgbaDisplaceEdits.modify(gsplat);
        }
        if (this.worldModifier) {
          gsplat = this.worldModifier.apply({ gsplat }).gsplat;
        }
        return { gsplat };
      }
    );
    this.generator = generator;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: time2,
    viewToWorld,
    deltaTime: deltaTime2,
    globalEdits
  }) {
    var _a2;
    this.numSplats = this.packedSplats.numSplats;
    this.context.time.value = time2;
    this.context.deltaTime.value = deltaTime2;
    _SplatMesh.dynoTime.value = time2;
    const { transform, viewToObject, recolor } = this.context;
    let updated = transform.update(this);
    if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {
      updated = true;
    }
    const worldToView = viewToWorld.clone().invert();
    if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {
      updated = true;
    }
    const objectToWorld = new THREE.Matrix4().compose(
      transform.translate.value,
      transform.rotate.value,
      new THREE.Vector3().setScalar(transform.scale.value)
    );
    const worldToObject = objectToWorld.invert();
    const viewToObjectMatrix = worldToObject.multiply(viewToWorld);
    if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {
      updated = true;
    }
    const newRecolor = new THREE.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    if (!newRecolor.equals(recolor.value)) {
      recolor.value.copy(newRecolor);
      updated = true;
    }
    const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];
    if (this.editable && !this.edits) {
      this.traverseVisible((node) => {
        if (node instanceof SplatEdit) {
          edits.push(node);
        }
      });
    }
    edits.sort((a, b) => a.ordering - b.ordering);
    const editsSdfs = edits.map((edit) => {
      if (edit.sdfs != null) {
        return { edit, sdfs: edit.sdfs };
      }
      const sdfs = [];
      edit.traverseVisible((node) => {
        if (node instanceof SplatEditSdf) {
          sdfs.push(node);
        }
      });
      return { edit, sdfs };
    });
    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {
      const edits2 = editsSdfs.length;
      const sdfs = editsSdfs.reduce(
        (total, edit) => total + edit.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new SplatEdits({
        maxEdits: edits2,
        maxSdfs: sdfs
      });
      this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const editResult = this.rgbaDisplaceEdits.update(editsSdfs);
      updated || (updated = editResult.updated);
      if (editResult.dynoUpdated) {
        this.updateGenerator();
      }
    }
    if (updated) {
      this.updateVersion();
    }
    (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time: time2, deltaTime: deltaTime2 });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(raycaster, intersects) {
    var _a2, _b2;
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {
      return;
    }
    const { near, far, ray } = raycaster;
    const worldToMesh = this.matrixWorld.clone().invert();
    const worldToMeshRot = new THREE.Matrix3().setFromMatrix4(worldToMesh);
    const origin = ray.origin.clone().applyMatrix4(worldToMesh);
    const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);
    const scales = new THREE.Vector3();
    worldToMesh.decompose(new THREE.Vector3(), new THREE.Quaternion(), scales);
    (scales.x * scales.y * scales.z) ** (1 / 3);
    const RAYCAST_ELLIPSOID = true;
    const distances = raycast_splats(
      origin.x,
      origin.y,
      origin.z,
      direction.x,
      direction.y,
      direction.z,
      near,
      far,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      RAYCAST_ELLIPSOID,
      ((_a2 = this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? LN_SCALE_MIN,
      ((_b2 = this.packedSplats.splatEncoding) == null ? void 0 : _b2.lnScaleMax) ?? LN_SCALE_MAX
    );
    for (const distance2 of distances) {
      const point = ray.direction.clone().multiplyScalar(distance2).add(ray.origin);
      intersects.push({
        distance: distance2,
        point,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1) {
      return {};
    }
    let sh1Texture = this.packedSplats.extra.sh1Texture;
    if (!sh1Texture) {
      let sh1 = this.packedSplats.extra.sh1;
      const { width, height, depth: depth2, maxSplats } = getTextureSize(
        sh1.length / 2
      );
      if (sh1.length < maxSplats * 2) {
        const newSh1 = new Uint32Array(maxSplats * 2);
        newSh1.set(sh1);
        this.packedSplats.extra.sh1 = newSh1;
        sh1 = newSh1;
      }
      const texture2 = new THREE.DataArrayTexture(sh1, width, height, depth2);
      texture2.format = THREE.RGIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      setTextureInternalFormat(texture2, "RG32UI");
      texture2.needsUpdate = true;
      sh1Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh1"
      });
      this.packedSplats.extra.sh1Texture = sh1Texture;
    }
    if (!this.packedSplats.extra.sh2) {
      return { sh1Texture };
    }
    let sh2Texture = this.packedSplats.extra.sh2Texture;
    if (!sh2Texture) {
      let sh2 = this.packedSplats.extra.sh2;
      const { width, height, depth: depth2, maxSplats } = getTextureSize(
        sh2.length / 4
      );
      if (sh2.length < maxSplats * 4) {
        const newSh2 = new Uint32Array(maxSplats * 4);
        newSh2.set(sh2);
        this.packedSplats.extra.sh2 = newSh2;
        sh2 = newSh2;
      }
      const texture2 = new THREE.DataArrayTexture(sh2, width, height, depth2);
      texture2.format = THREE.RGBAIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      setTextureInternalFormat(texture2, "RGBA32UI");
      texture2.needsUpdate = true;
      sh2Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh2"
      });
      this.packedSplats.extra.sh2Texture = sh2Texture;
    }
    if (!this.packedSplats.extra.sh3) {
      return { sh1Texture, sh2Texture };
    }
    let sh3Texture = this.packedSplats.extra.sh3Texture;
    if (!sh3Texture) {
      let sh3 = this.packedSplats.extra.sh3;
      const { width, height, depth: depth2, maxSplats } = getTextureSize(
        sh3.length / 4
      );
      if (sh3.length < maxSplats * 4) {
        const newSh3 = new Uint32Array(maxSplats * 4);
        newSh3.set(sh3);
        this.packedSplats.extra.sh3 = newSh3;
        sh3 = newSh3;
      }
      const texture2 = new THREE.DataArrayTexture(sh3, width, height, depth2);
      texture2.format = THREE.RGBAIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      setTextureInternalFormat(texture2, "RGBA32UI");
      texture2.needsUpdate = true;
      sh3Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh3"
      });
      this.packedSplats.extra.sh3Texture = sh3Texture;
    }
    return { sh1Texture, sh2Texture, sh3Texture };
  }
};
_SplatMesh.staticInitialized = _SplatMesh.staticInitialize();
_SplatMesh.isStaticInitialized = false;
_SplatMesh.dynoTime = new DynoFloat({ value: 0 });
let SplatMesh = _SplatMesh;
const defineEvaluateSH1 = unindent(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`);
const defineEvaluateSH2 = unindent(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`);
const defineEvaluateSH3 = unindent(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function evaluateSH1(gsplat, sh1, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh1, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH1],
    statements: ({ inputs, outputs }) => {
      const statements = unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `);
      return statements;
    }
  }).outputs.rgb;
}
function evaluateSH2(gsplat, sh2, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh2, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH2],
    statements: ({ inputs, outputs }) => unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function evaluateSH3(gsplat, sh3, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh3, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH3],
    statements: ({ inputs, outputs }) => unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const EMPTY_GEOMETRY$1 = new THREE.BufferGeometry();
EMPTY_GEOMETRY$1.setAttribute(
  "position",
  new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3)
);
let detectionMaterial = null;
function getDetectionMaterial() {
  if (!detectionMaterial) {
    detectionMaterial = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0,
      depthWrite: false
    });
  }
  return detectionMaterial;
}
function createRendererDetectionMesh() {
  const mesh = new THREE.Mesh(EMPTY_GEOMETRY$1, getDetectionMaterial());
  mesh.frustumCulled = false;
  mesh.onBeforeRender = function(renderer, scene) {
    if (!scene.isScene) {
      this.removeFromParent();
      return;
    }
    let hasSparkRenderer = false;
    scene.traverse((c) => {
      if (c instanceof SparkRenderer) {
        hasSparkRenderer = true;
      }
    });
    if (!hasSparkRenderer) {
      scene.add(new SparkRenderer({ renderer }));
    }
    this.removeFromParent();
  };
  return mesh;
}
const PLY_PROPERTY_TYPES = [
  "char",
  "uchar",
  "short",
  "ushort",
  "int",
  "uint",
  "float",
  "double"
];
const _PlyReader = class _PlyReader {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes }) {
    this.header = "";
    this.littleEndian = true;
    this.elements = {};
    this.comments = [];
    this.data = null;
    this.numSplats = 0;
    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const bufferStream = new ReadableStream({
      start: (controller) => {
        controller.enqueue(this.fileBytes.slice(0, 65536));
        controller.close();
      }
    });
    const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const headerTerminator = "end_header\n";
    while (true) {
      const { value, done } = await decoder.read();
      if (done) {
        throw new Error("Failed to read header");
      }
      this.header += value;
      const endHeader = this.header.indexOf(headerTerminator);
      if (endHeader >= 0) {
        this.header = this.header.slice(0, endHeader + headerTerminator.length);
        break;
      }
    }
    const headerLen = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, headerLen);
    this.elements = {};
    let curElement = null;
    this.comments = [];
    this.header.trim().split("\n").forEach((line, lineIndex) => {
      const trimmedLine = line.trim();
      if (lineIndex === 0) {
        if (trimmedLine !== "ply") {
          throw new Error("Invalid PLY header");
        }
        return;
      }
      if (trimmedLine.length === 0) {
        return;
      }
      const fields = trimmedLine.split(" ");
      switch (fields[0]) {
        case "format":
          if (fields[1] === "binary_little_endian") {
            this.littleEndian = true;
          } else if (fields[1] === "binary_big_endian") {
            this.littleEndian = false;
          } else {
            throw new Error(`Unsupported PLY format: ${fields[1]}`);
          }
          if (fields[2] !== "1.0") {
            throw new Error(`Unsupported PLY version: ${fields[2]}`);
          }
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(trimmedLine.slice("comment ".length));
          break;
        case "element": {
          const name = fields[1];
          curElement = {
            name,
            count: Number.parseInt(fields[2]),
            properties: {}
          };
          this.elements[name] = curElement;
          break;
        }
        case "property":
          if (curElement == null) {
            throw new Error("Property must be inside an element");
          }
          if (fields[1] === "list") {
            curElement.properties[fields[4]] = {
              isList: true,
              type: fields[3],
              countType: fields[2]
            };
          } else {
            curElement.properties[fields[2]] = {
              isList: false,
              type: fields[1]
            };
          }
          break;
      }
    });
    if (this.elements.vertex) {
      this.numSplats = this.elements.vertex.count;
    }
  }
  parseData(elementCallback) {
    let offset = 0;
    const data = this.data;
    if (data == null) {
      throw new Error("No data to parse");
    }
    for (const elementName in this.elements) {
      const element2 = this.elements[elementName];
      const { count, properties } = element2;
      const item = createEmptyItem(properties);
      const parseFn = createParseFn(properties, this.littleEndian);
      const callback = elementCallback(element2) ?? (() => {
      });
      for (let index = 0; index < count; index++) {
        offset = parseFn(data, offset, item);
        callback(index, item);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(splatCallback, shCallback) {
    if (this.elements.vertex == null) {
      throw new Error("No vertex element found");
    }
    let isSuperSplat = false;
    const ssChunks = [];
    let numSh = 0;
    let sh1Props = [];
    let sh2Props = [];
    let sh3Props = [];
    let sh1 = void 0;
    let sh2 = void 0;
    let sh3 = void 0;
    function prepareSh() {
      const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];
      sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));
      sh2Props = new Array(5).fill(null).flatMap(
        (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)
      );
      sh3Props = new Array(7).fill(null).flatMap(
        (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)
      );
      sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;
      sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;
      sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function ssShCallback(index, item) {
      if (!sh1) {
        throw new Error("Missing sh1");
      }
      const sh = item.f_rest;
      for (let i = 0; i < sh1Props.length; i++) {
        sh1[i] = sh[sh1Props[i]] * 8 / 255 - 4;
      }
      if (sh2) {
        for (let i = 0; i < sh2Props.length; i++) {
          sh2[i] = sh[sh2Props[i]] * 8 / 255 - 4;
        }
      }
      if (sh3) {
        for (let i = 0; i < sh3Props.length; i++) {
          sh3[i] = sh[sh3Props[i]] * 8 / 255 - 4;
        }
      }
      shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);
    }
    function initSuperSplat(element2) {
      const {
        min_x,
        min_y,
        min_z,
        max_x,
        max_y,
        max_z,
        min_scale_x,
        min_scale_y,
        min_scale_z,
        max_scale_x,
        max_scale_y,
        max_scale_z
      } = element2.properties;
      if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {
        throw new Error("Missing PLY chunk properties");
      }
      isSuperSplat = true;
      return (index, item) => {
        const {
          min_x: min_x2,
          min_y: min_y2,
          min_z: min_z2,
          max_x: max_x2,
          max_y: max_y2,
          max_z: max_z2,
          min_scale_x: min_scale_x2,
          min_scale_y: min_scale_y2,
          min_scale_z: min_scale_z2,
          max_scale_x: max_scale_x2,
          max_scale_y: max_scale_y2,
          max_scale_z: max_scale_z2,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        } = item;
        ssChunks.push({
          min_x: min_x2,
          min_y: min_y2,
          min_z: min_z2,
          max_x: max_x2,
          max_y: max_y2,
          max_z: max_z2,
          min_scale_x: min_scale_x2,
          min_scale_y: min_scale_y2,
          min_scale_z: min_scale_z2,
          max_scale_x: max_scale_x2,
          max_scale_y: max_scale_y2,
          max_scale_z: max_scale_z2,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        });
      };
    }
    function decodeSuperSplat(element2) {
      if (shCallback && element2.name === "sh") {
        numSh = getNumSh(element2.properties);
        prepareSh();
        return ssShCallback;
      }
      if (element2.name !== "vertex") {
        return null;
      }
      const { packed_position, packed_rotation, packed_scale, packed_color } = element2.properties;
      if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      }
      const SQRT2 = Math.sqrt(2);
      return (index, item) => {
        const chunk = ssChunks[index >>> 8];
        if (chunk == null) {
          throw new Error("Missing PLY chunk");
        }
        const {
          min_x,
          min_y,
          min_z,
          max_x,
          max_y,
          max_z,
          min_scale_x,
          min_scale_y,
          min_scale_z,
          max_scale_x,
          max_scale_y,
          max_scale_z,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        } = chunk;
        const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;
        const x = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;
        const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;
        const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;
        const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;
        const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;
        const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;
        const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
        const rOrder = packed_rotation2 >>> 30;
        const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
        const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
        const quatZ = rOrder <= 2 ? r2 : rr;
        const quatW = rOrder === 0 ? rr : r0;
        const scaleX = Math.exp(
          (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x
        );
        const scaleY = Math.exp(
          (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y
        );
        const scaleZ = Math.exp(
          (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z
        );
        const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);
        const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);
        const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);
        const opacity = (packed_color2 & 255) / 255;
        splatCallback(
          index,
          x,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
      };
    }
    const elementCallback = (element2) => {
      if (element2.name === "chunk") {
        return initSuperSplat(element2);
      }
      if (isSuperSplat) {
        return decodeSuperSplat(element2);
      }
      if (element2.name !== "vertex") {
        return null;
      }
      const {
        x,
        y,
        z,
        scale_0,
        scale_1,
        scale_2,
        rot_0,
        rot_1,
        rot_2,
        rot_3,
        opacity,
        f_dc_0,
        f_dc_1,
        f_dc_2,
        red,
        green,
        blue,
        alpha
      } = element2.properties;
      if (!x || !y || !z) {
        throw new Error("Missing PLY properties: x, y, z");
      }
      const hasScales = scale_0 && scale_1 && scale_2;
      const hasRots = rot_0 && rot_1 && rot_2 && rot_3;
      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;
      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;
      const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;
      const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;
      numSh = getNumSh(element2.properties);
      prepareSh();
      return (index, item) => {
        const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;
        const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;
        const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;
        const quatX = hasRots ? item.rot_1 : 0;
        const quatY = hasRots ? item.rot_2 : 0;
        const quatZ = hasRots ? item.rot_3 : 0;
        const quatW = hasRots ? item.rot_0 : 1;
        const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;
        const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;
        const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;
        const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;
        splatCallback(
          index,
          item.x,
          item.y,
          item.z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          op,
          r,
          g,
          b
        );
        if (shCallback && sh1) {
          const sh = item.f_rest;
          if (sh1) {
            for (let i = 0; i < sh1Props.length; i++) {
              sh1[i] = sh[sh1Props[i]];
            }
          }
          if (sh2) {
            for (let i = 0; i < sh2Props.length; i++) {
              sh2[i] = sh[sh2Props[i]];
            }
          }
          if (sh3) {
            for (let i = 0; i < sh3Props.length; i++) {
              sh3[i] = sh[sh3Props[i]];
            }
          }
          shCallback(index, sh1, sh2, sh3);
        }
      };
    };
    this.parseData(elementCallback);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(rgba) {
    let offset = 0;
    const data = this.data;
    if (data == null) {
      throw new Error("No parsed data");
    }
    if (rgba.length !== this.numSplats * 4) {
      throw new Error("Invalid RGBA array length");
    }
    for (const elementName in this.elements) {
      const element2 = this.elements[elementName];
      const { count, properties } = element2;
      const parsers = [];
      let rgbaOffset = 0;
      const isVertex = elementName === "vertex";
      if (isVertex) {
        for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {
          if (!properties[name] || properties[name].type !== "float") {
            throw new Error(`Can't injectRgba due to property: ${name}`);
          }
        }
      }
      for (const [propertyName, property2] of Object.entries(properties)) {
        if (!property2.isList) {
          if (isVertex) {
            if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {
              const component = Number.parseInt(
                propertyName.slice("f_dc_".length)
              );
              parsers.push(() => {
                const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;
                SET_FIELD[property2.type](
                  data,
                  offset,
                  this.littleEndian,
                  value
                );
              });
            } else if (propertyName === "opacity") {
              parsers.push(() => {
                const value = Math.max(
                  -100,
                  Math.min(
                    100,
                    -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)
                  )
                );
                SET_FIELD[property2.type](
                  data,
                  offset,
                  this.littleEndian,
                  value
                );
              });
            }
          }
          parsers.push(() => {
            offset += FIELD_BYTES[property2.type];
          });
        } else {
          parsers.push(() => {
            const length2 = PARSE_FIELD[property2.countType](
              data,
              offset,
              this.littleEndian
            );
            offset += FIELD_BYTES[property2.countType];
            offset += length2 * FIELD_BYTES[property2.type];
          });
        }
      }
      for (let index = 0; index < count; index++) {
        for (const parser of parsers) {
          parser();
        }
        if (isVertex) {
          rgbaOffset += 4;
        }
      }
    }
  }
};
_PlyReader.defaultPointScale = 1e-3;
let PlyReader = _PlyReader;
const SH_C0$1 = 0.28209479177387814;
const PARSE_FIELD = {
  char: (data, offset, littleEndian) => {
    return data.getInt8(offset);
  },
  uchar: (data, offset, littleEndian) => {
    return data.getUint8(offset);
  },
  short: (data, offset, littleEndian) => {
    return data.getInt16(offset, littleEndian);
  },
  ushort: (data, offset, littleEndian) => {
    return data.getUint16(offset, littleEndian);
  },
  int: (data, offset, littleEndian) => {
    return data.getInt32(offset, littleEndian);
  },
  uint: (data, offset, littleEndian) => {
    return data.getUint32(offset, littleEndian);
  },
  float: (data, offset, littleEndian) => {
    return data.getFloat32(offset, littleEndian);
  },
  double: (data, offset, littleEndian) => {
    return data.getFloat64(offset, littleEndian);
  }
};
const SET_FIELD = {
  char: (data, offset, littleEndian, value) => {
    data.setInt8(offset, value);
  },
  uchar: (data, offset, littleEndian, value) => {
    data.setUint8(offset, value);
  },
  short: (data, offset, littleEndian, value) => {
    data.setInt16(offset, value, littleEndian);
  },
  ushort: (data, offset, littleEndian, value) => {
    data.setUint16(offset, value, littleEndian);
  },
  int: (data, offset, littleEndian, value) => {
    data.setInt32(offset, value, littleEndian);
  },
  uint: (data, offset, littleEndian, value) => {
    data.setUint32(offset, value, littleEndian);
  },
  float: (data, offset, littleEndian, value) => {
    data.setFloat32(offset, value, littleEndian);
  },
  double: (data, offset, littleEndian, value) => {
    data.setFloat64(offset, value, littleEndian);
  }
};
const FIELD_BYTES = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
};
const FIELD_SCALE = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
};
const NUM_F_REST_TO_NUM_SH = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
};
const NUM_SH_TO_NUM_F_REST = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;
function createEmptyItem(properties) {
  const item = {};
  for (const [propertyName, property2] of Object.entries(properties)) {
    if (F_REST_REGEX.test(propertyName)) {
      item.f_rest = new Array(getNumSh(properties));
    } else {
      item[propertyName] = property2.isList ? [] : 0;
    }
  }
  return item;
}
function createParseFn(properties, littleEndian) {
  if (safeToCompile(properties)) {
    return createCompiledParserFn(properties, littleEndian);
  }
  return createDynamicParserFn(properties, littleEndian);
}
const UNSAFE_EVAL_ALLOWED = (() => {
  try {
    new Function("return 42;");
  } catch (e) {
    return false;
  }
  return true;
})();
const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;
function safeToCompile(properties) {
  if (!UNSAFE_EVAL_ALLOWED) {
    return false;
  }
  for (const [propertyName, property2] of Object.entries(properties)) {
    if (!PROPERTY_NAME_REGEX.test(propertyName)) {
      return false;
    }
    if (property2.isList && !PLY_PROPERTY_TYPES.includes(property2.countType)) {
      return false;
    }
    if (!PLY_PROPERTY_TYPES.includes(property2.type)) {
      return false;
    }
  }
  return true;
}
function createCompiledParserFn(properties, littleEndian) {
  const parserSrc = ["let list;"];
  for (const [propertyName, property2] of Object.entries(properties)) {
    const fRestMatch = propertyName.match(F_REST_REGEX);
    if (fRestMatch) {
      const fRestIndex = +fRestMatch[1];
      parserSrc.push(
        /*js*/
        `
        item.f_rest[${fRestIndex}] = PARSE_FIELD['${property2.type}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property2.type]};
      `
      );
    } else if (!property2.isList) {
      parserSrc.push(
        /*js*/
        `
        item['${propertyName}'] = PARSE_FIELD['${property2.type}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property2.type]};
      `
      );
    } else {
      parserSrc.push(
        /*js*/
        `
        list = item['${propertyName}'];
        list.length = PARSE_FIELD['${property2.countType}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property2.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['${property2.type}'](data, offset, ${littleEndian});
          offset += ${FIELD_BYTES[property2.type]};
        }
      `
      );
    }
  }
  parserSrc.push("return offset;");
  const fn = new Function(
    "data",
    "offset",
    "item",
    "PARSE_FIELD",
    parserSrc.join("\n")
  );
  return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);
}
function createDynamicParserFn(properties, littleEndian) {
  const parsers = [];
  for (const [propertyName, property2] of Object.entries(properties)) {
    const fRestMatch = propertyName.match(F_REST_REGEX);
    if (fRestMatch) {
      const fRestIndex = +fRestMatch[1];
      parsers.push(
        (data, offset, item) => {
          item.f_rest[fRestIndex] = PARSE_FIELD[property2.type](
            data,
            offset,
            littleEndian
          );
          return offset + FIELD_BYTES[property2.type];
        }
      );
    } else if (!property2.isList) {
      parsers.push(
        (data, offset, item) => {
          item[propertyName] = PARSE_FIELD[property2.type](
            data,
            offset,
            littleEndian
          );
          return offset + FIELD_BYTES[property2.type];
        }
      );
    } else {
      parsers.push(
        (data, offset, item) => {
          const list = item[propertyName];
          list.length = PARSE_FIELD[property2.countType](
            data,
            offset,
            littleEndian
          );
          let currentOffset = offset + FIELD_BYTES[property2.countType];
          for (let i = 0; i < list.length; i++) {
            list[i] = PARSE_FIELD[property2.type](
              data,
              currentOffset,
              littleEndian
            );
            currentOffset += FIELD_BYTES[property2.type];
          }
          return currentOffset;
        }
      );
    }
  }
  return (data, offset, item) => {
    let currentOffset = offset;
    for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {
      currentOffset = parsers[parserIndex](data, currentOffset, item);
    }
    return currentOffset;
  };
}
function getNumSh(properties) {
  let num_f_rest = 0;
  while (properties[`f_rest_${num_f_rest}`]) {
    num_f_rest += 1;
  }
  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];
  if (numSh == null) {
    throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);
  }
  return numSh;
}
const jsContent = '(function() {\n  "use strict";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function sort32_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAN/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gAW8Bf2ADb29/AGAAAGAEf39/fwF/YAABf2AGf39/f39/AGAEf39/fwBgA39vbwF/YAF/AW9gAAFvYAF9AX1gDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAKA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAGA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEgN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAGA3diZxFfX3diaW5kZ2VuX21lbW9yeQATA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADANeXQQAAQcFAwINDgAUAQMAAQEDAAABCA8IDwMDAQMBBQMDAgIAAQMFAAEHABUMDAUWCAcXGRsFEAIREQUdAQEBBAQEBQEABAIADgANAQAAAwECAgIAAQEBAAAAAQEEBAQJAnABLi5vAIABBQMBABEGCQF/AUGAgMAACwdiBgZtZW1vcnkCAA5yYXljYXN0X3NwbGF0cwA7DXNvcnQzMl9zcGxhdHMASAtzb3J0X3NwbGF0cwBJE19fd2JpbmRnZW5fZXhwb3J0XzABARBfX3diaW5kZ2VuX3N0YXJ0ABAJMwEAQQELLU9RUFkzQShAQ0RAQkBGQT9HUmo6SjEiYVw0W2VFNyQra01MSjIjYmdXVF1oaQwBAwqQ2AFdySUCCX8BfiMAQRBrIggkAAJAAkACQAJAAkAgAEH1AU8EQCAAQcz/e0sEQEEAIQAMBgsgAEELaiICQXhxIQVB2JnAACgCACIJRQ0EQR8hBkEAIAVrIQMgAEH0//8HTQRAIAVBJiACQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBgsgBkECdEG8lsAAaigCACICRQRAQQAhAAwCCyAFQRkgBkEBdmtBACAGQR9HG3QhBEEAIQADQAJAIAIoAgRBeHEiByAFSQ0AIAcgBWsiByADTw0AIAIhASAHIgMNAEEAIQMgASEADAQLIAIoAhQiByAAIAcgAiAEQR12QQRxaigCECICRxsgACAHGyEAIARBAXQhBCACDQALDAELAkACQAJAAkACQEHUmcAAKAIAIgRBECAAQQtqQfgDcSAAQQtJGyIFQQN2IgB2IgFBA3EEQCABQX9zQQFxIABqIgdBA3QiAUHMl8AAaiIAIAFB1JfAAGooAgAiAigCCCIDRg0BIAMgADYCDCAAIAM2AggMAgsgBUHcmcAAKAIATQ0IIAENAkHYmcAAKAIAIgBFDQggAGhBAnRBvJbAAGooAgAiAigCBEF4cSAFayEDIAIhAQNAAkAgASgCECIADQAgASgCFCIADQAgAigCGCEGAkACQCACIAIoAgwiAEYEQCACQRRBECACKAIUIgAbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyACQRRqIAJBEGogABshBANAIAQhByABIgBBFGogAEEQaiAAKAIUIgEbIQQgAEEUQRAgARtqKAIAIgENAAsgB0EANgIACyAGRQ0GAkAgAigCHEECdEG8lsAAaiIBKAIAIAJHBEAgAiAGKAIQRwRAIAYgADYCFCAADQIMCQsgBiAANgIQIAANAQwICyABIAA2AgAgAEUNBgsgACAGNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNBiAAIAE2AhQgASAANgIYDAYLIAAoAgRBeHEgBWsiASADIAEgA0kiARshAyAAIAIgARshAiAAIQEMAAsAC0HUmcAAIARBfiAHd3E2AgALIAJBCGohACACIAFBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMBwsCQEECIAB0IgJBACACa3IgASAAdHFoIgdBA3QiAUHMl8AAaiICIAFB1JfAAGooAgAiACgCCCIDRwRAIAMgAjYCDCACIAM2AggMAQtB1JnAACAEQX4gB3dxNgIACyAAIAVBA3I2AgQgACAFaiIGIAEgBWsiB0EBcjYCBCAAIAFqIAc2AgBB3JnAACgCACICBEBB5JnAACgCACEBAkBB1JnAACgCACIEQQEgAkEDdnQiA3FFBEBB1JnAACADIARyNgIAIAJBeHFBzJfAAGoiAyEEDAELIAJBeHEiAkHMl8AAaiEEIAJB1JfAAGooAgAhAwsgBCABNgIIIAMgATYCDCABIAQ2AgwgASADNgIICyAAQQhqIQBB5JnAACAGNgIAQdyZwAAgBzYCAAwGC0HYmcAAQdiZwAAoAgBBfiACKAIcd3E2AgALAkACQCADQRBPBEAgAiAFQQNyNgIEIAIgBWoiByADQQFyNgIEIAMgB2ogAzYCAEHcmcAAKAIAIgFFDQFB5JnAACgCACEAAkBB1JnAACgCACIEQQEgAUEDdnQiBnFFBEBB1JnAACAEIAZyNgIAIAFBeHFBzJfAAGoiBCEBDAELIAFBeHEiBEHMl8AAaiEBIARB1JfAAGooAgAhBAsgASAANgIIIAQgADYCDCAAIAE2AgwgACAENgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELQeSZwAAgBzYCAEHcmcAAIAM2AgALIAJBCGoiAEUNAwwECyAAIAFyRQRAQQAhAUECIAZ0IgBBACAAa3IgCXEiAEUNAyAAaEECdEG8lsAAaigCACEACyAARQ0BCwNAIAMgACgCBEF4cSICIAVrIgQgAyADIARLIgQbIAIgBUkiAhshAyABIAAgASAEGyACGyEBIAAoAhAiAgR/IAIFIAAoAhQLIgANAAsLIAFFDQAgBUHcmcAAKAIAIgBNIAMgACAFa09xDQAgASgCGCEGAkACQCABIAEoAgwiAEYEQCABQRRBECABKAIUIgAbaigCACICDQFBACEADAILIAEoAggiAiAANgIMIAAgAjYCCAwBCyABQRRqIAFBEGogABshBANAIAQhByACIgBBFGogAEEQaiAAKAIUIgIbIQQgAEEUQRAgAhtqKAIAIgINAAsgB0EANgIACwJAIAZFDQACQAJAIAEoAhxBAnRBvJbAAGoiAigCACABRwRAIAEgBigCEEcEQCAGIAA2AhQgAA0CDAQLIAYgADYCECAADQEMAwsgAiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABKAIUIgJFDQEgACACNgIUIAIgADYCGAwBC0HYmcAAQdiZwAAoAgBBfiABKAIcd3E2AgALAkAgA0EQTwRAIAEgBUEDcjYCBCABIAVqIgAgA0EBcjYCBCAAIANqIAM2AgAgA0GAAk8EQCAAIAMQIAwCCwJAQdSZwAAoAgAiAkEBIANBA3Z0IgRxRQRAQdSZwAAgAiAEcjYCACADQfgBcUHMl8AAaiIDIQIMAQsgA0H4AXEiBEHMl8AAaiECIARB1JfAAGooAgAhAwsgAiAANgIIIAMgADYCDCAAIAI2AgwgACADNgIIDAELIAEgAyAFaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECyABQQhqIgANAQsCQAJAAkACQAJAIAVB3JnAACgCACIBSwRAIAVB4JnAACgCACIATwRAIAhBBGohAAJ/IAVBr4AEakGAgHxxIgFBEHYgAUH//wNxQQBHaiIBQAAiBEF/RgRAQQAhAUEADAELIAFBEHQiAkEQayACIARBEHQiAUEAIAJrRhsLIQIgAEEANgIIIAAgAjYCBCAAIAE2AgAgCCgCBCIBRQRAQQAhAAwICyAIKAIMIQdB7JnAACAIKAIIIgRB7JnAACgCAGoiADYCAEHwmcAAIABB8JnAACgCACICIAAgAksbNgIAAkACQEHomcAAKAIAIgIEQEG8l8AAIQADQCABIAAoAgAiAyAAKAIEIgZqRg0CIAAoAggiAA0ACwwCC0H4mcAAKAIAIgBBACAAIAFNG0UEQEH4mcAAIAE2AgALQfyZwABB/x82AgBByJfAACAHNgIAQcCXwAAgBDYCAEG8l8AAIAE2AgBB2JfAAEHMl8AANgIAQeCXwABB1JfAADYCAEHUl8AAQcyXwAA2AgBB6JfAAEHcl8AANgIAQdyXwABB1JfAADYCAEHwl8AAQeSXwAA2AgBB5JfAAEHcl8AANgIAQfiXwABB7JfAADYCAEHsl8AAQeSXwAA2AgBBgJjAAEH0l8AANgIAQfSXwABB7JfAADYCAEGImMAAQfyXwAA2AgBB/JfAAEH0l8AANgIAQZCYwABBhJjAADYCAEGEmMAAQfyXwAA2AgBBmJjAAEGMmMAANgIAQYyYwABBhJjAADYCAEGUmMAAQYyYwAA2AgBBoJjAAEGUmMAANgIAQZyYwABBlJjAADYCAEGomMAAQZyYwAA2AgBBpJjAAEGcmMAANgIAQbCYwABBpJjAADYCAEGsmMAAQaSYwAA2AgBBuJjAAEGsmMAANgIAQbSYwABBrJjAADYCAEHAmMAAQbSYwAA2AgBBvJjAAEG0mMAANgIAQciYwABBvJjAADYCAEHEmMAAQbyYwAA2AgBB0JjAAEHEmMAANgIAQcyYwABBxJjAADYCAEHYmMAAQcyYwAA2AgBB4JjAAEHUmMAANgIAQdSYwABBzJjAADYCAEHomMAAQdyYwAA2AgBB3JjAAEHUmMAANgIAQfCYwABB5JjAADYCAEHkmMAAQdyYwAA2AgBB+JjAAEHsmMAANgIAQeyYwABB5JjAADYCAEGAmcAAQfSYwAA2AgBB9JjAAEHsmMAANgIAQYiZwABB/JjAADYCAEH8mMAAQfSYwAA2AgBBkJnAAEGEmcAANgIAQYSZwABB/JjAADYCAEGYmcAAQYyZwAA2AgBBjJnAAEGEmcAANgIAQaCZwABBlJnAADYCAEGUmcAAQYyZwAA2AgBBqJnAAEGcmcAANgIAQZyZwABBlJnAADYCAEGwmcAAQaSZwAA2AgBBpJnAAEGcmcAANgIAQbiZwABBrJnAADYCAEGsmcAAQaSZwAA2AgBBwJnAAEG0mcAANgIAQbSZwABBrJnAADYCAEHImcAAQbyZwAA2AgBBvJnAAEG0mcAANgIAQdCZwABBxJnAADYCAEHEmcAAQbyZwAA2AgBB6JnAACABQQ9qQXhxIgBBCGsiAjYCAEHMmcAAQcSZwAA2AgBB4JnAACAEQShrIgQgASAAa2pBCGoiADYCACACIABBAXI2AgQgASAEakEoNgIEQfSZwABBgICAATYCAAwICyACIANJIAEgAk1yDQAgACgCDCIDQQFxDQAgA0EBdiAHRg0DC0H4mcAAQfiZwAAoAgAiACABIAAgAUkbNgIAIAEgBGohA0G8l8AAIQACQAJAA0AgAyAAKAIAIgZHBEAgACgCCCIADQEMAgsLIAAoAgwiA0EBcQ0AIANBAXYgB0YNAQtBvJfAACEAA0ACQCACIAAoAgAiA08EQCACIAMgACgCBGoiBkkNAQsgACgCCCEADAELC0HomcAAIAFBD2pBeHEiAEEIayIDNgIAQeCZwAAgBEEoayIJIAEgAGtqQQhqIgA2AgAgAyAAQQFyNgIEIAEgCWpBKDYCBEH0mcAAQYCAgAE2AgAgAiAGQSBrQXhxQQhrIgAgACACQRBqSRsiA0EbNgIEQbyXwAApAgAhCiADQRBqQcSXwAApAgA3AgAgA0EIaiIAIAo3AgBByJfAACAHNgIAQcCXwAAgBDYCAEG8l8AAIAE2AgBBxJfAACAANgIAIANBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgAiADRg0HIAMgAygCBEF+cTYCBCACIAMgAmsiAEEBcjYCBCADIAA2AgAgAEGAAk8EQCACIAAQIAwICwJAQdSZwAAoAgAiAUEBIABBA3Z0IgRxRQRAQdSZwAAgASAEcjYCACAAQfgBcUHMl8AAaiIAIQEMAQsgAEH4AXEiAEHMl8AAaiEBIABB1JfAAGooAgAhAAsgASACNgIIIAAgAjYCDCACIAE2AgwgAiAANgIIDAcLIAAgATYCACAAIAAoAgQgBGo2AgQgAUEPakF4cUEIayIEIAVBA3I2AgQgBkEPakF4cUEIayIDIAQgBWoiAGshBSADQeiZwAAoAgBGDQMgA0HkmcAAKAIARg0EIAMoAgQiAkEDcUEBRgRAIAMgAkF4cSIBEB8gASAFaiEFIAEgA2oiAygCBCECCyADIAJBfnE2AgQgACAFQQFyNgIEIAAgBWogBTYCACAFQYACTwRAIAAgBRAgDAYLAkBB1JnAACgCACIBQQEgBUEDdnQiAnFFBEBB1JnAACABIAJyNgIAIAVB+AFxQcyXwABqIgUhAwwBCyAFQfgBcSIBQcyXwABqIQMgAUHUl8AAaigCACEFCyADIAA2AgggBSAANgIMIAAgAzYCDCAAIAU2AggMBQtB4JnAACAAIAVrIgE2AgBB6JnAAEHomcAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwGC0HkmcAAKAIAIQACQCABIAVrIgJBD00EQEHkmcAAQQA2AgBB3JnAAEEANgIAIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBC0HcmcAAIAI2AgBB5JnAACAAIAVqIgQ2AgAgBCACQQFyNgIEIAAgAWogAjYCACAAIAVBA3I2AgQLIABBCGohAAwFCyAAIAQgBmo2AgRB6JnAAEHomcAAKAIAIgBBD2pBeHEiAUEIayICNgIAQeCZwABB4JnAACgCACAEaiIEIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgBGpBKDYCBEH0mcAAQYCAgAE2AgAMAwtB6JnAACAANgIAQeCZwABB4JnAACgCACAFaiIBNgIAIAAgAUEBcjYCBAwBC0HkmcAAIAA2AgBB3JnAAEHcmcAAKAIAIAVqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsgBEEIaiEADAELQQAhAEHgmcAAKAIAIgEgBU0NAEHgmcAAIAEgBWsiATYCAEHomcAAQeiZwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEACyAIQRBqJAAgAAvGBgEHfwJAAkAgASAAQQNqQXxxIgQgAGsiB0kNACABIAdrIgZBBEkNAEEAIQEgACAERwRAIAAgBGsiBEF8TQRAA0AgASAAIANqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEBIANBBGoiAw0ACwsgACADaiECA0AgASACLAAAQb9/SmohASACQQFqIQIgBEEBaiIEDQALCyAAIAdqIQQCQCAGQQNxIgBFDQAgBCAGQfz///8HcWoiAywAAEG/f0ohBSAAQQFGDQAgBSADLAABQb9/SmohBSAAQQJGDQAgBSADLAACQb9/SmohBQsgBkECdiEGIAEgBWohAwNAIAQhACAGRQ0CQcABIAYgBkHAAU8bIgVBA3EhBwJAIAVBAnQiBEHwB3EiAUUEQEEAIQIMAQsgACABaiEIQQAhAiAAIQEDQCACIAEoAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAUEEaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiABQQhqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIAFBDGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWohAiABQRBqIgEgCEcNAAsLIAYgBWshBiAAIARqIQQgAkEIdkH/gfwHcSACQf+B/AdxakGBgARsQRB2IANqIQMgB0UNAAsCfyAAIAVB/AFxQQJ0aiIAKAIAIgFBf3NBB3YgAUEGdnJBgYKECHEiASAHQQFGDQAaIAEgACgCBCIBQX9zQQd2IAFBBnZyQYGChAhxaiIBIAdBAkYNABogACgCCCIAQX9zQQd2IABBBnZyQYGChAhxIAFqCyIBQQh2Qf+BHHEgAUH/gfwHcWpBgYAEbEEQdiADaiEDDAELIAFFBEBBAA8LIAFBA3EhBAJAIAFBBEkEQAwBCyABQXxxIQUDQCADIAAgAmoiASwAAEG/f0pqIAFBAWosAABBv39KaiABQQJqLAAAQb9/SmogAUEDaiwAAEG/f0pqIQMgBSACQQRqIgJHDQALCyAERQ0AIAAgAmohAQNAIAMgASwAAEG/f0pqIQMgAUEBaiEBIARBAWsiBA0ACwsgAwuKBgEGfyAAKAIIIgMgAUkEQCABIAMiAmsiBCAAKAIAIAJrSwRAIAAgAiAEQQRBBBAnIAAoAgghAgsgACgCBCIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgIICyAAKAIUIgMgAUkEQCABIAMiAmsiBCAAKAIMIAJrSwRAIABBDGogAiAEQQRBBBAnIAAoAhQhAgsgACgCECIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgIUCyAAKAI4IgMgAUkEQCABIAMiAmsiBCAAKAIwIAJrSwRAIABBMGogAiAEQQRBBBAnIAAoAjghAgsgACgCNCIGIAJBAnRqIQUgBEECTwRAIAEgA0F/c2pBAnQiBwRAIAVBACAH/AsACyABIAJqQQJ0IANBAnRrIAZqQQRrIQUgAiAEakEBayECCyAFQQA2AgAgACACQQFqNgI4CyAAKAIgIgNB//8DTQRAIAMhAUGAgAQgA2siAiAAKAIYIANrSwRAIABBGGogAyACQQRBBBAnIAAoAiAhAQsgACgCHCIFIAFBAnQiBGohAiADQf//A0cEQEH8/w8gA0ECdCIGayIHBEAgAkEAIAf8CwALIAQgBmsgBWpB/P8PaiECIAEgA2tB//8DaiEBCyACQQA2AgAgACABQQFqNgIgCyAAKAIsIgNB//8DTQRAIAMhAUGAgAQgA2siAiAAKAIkIANrSwRAIABBJGogAyACQQRBBBAnIAAoAiwhAQsgACgCKCIFIAFBAnQiBGohAiADQf//A0cEQEH8/w8gA0ECdCIGayIHBEAgAkEAIAf8CwALIAQgBmsgBWpB/P8PaiECIAEgA2tB//8DaiEBCyACQQA2AgAgACABQQFqNgIsCwuwBQIIfwF+QStBgIDEACAAKAIIIghBgICAAXEiBhshCyAGQRV2IARqIQYCQCAIQYCAgARxRQRAQQAhAQwBCwJAIAJBEE8EQCABIAIQEiEFDAELIAJFBEAMAQsgAkEDcSEJAkAgAkEESQRADAELIAJBDHEhDANAIAUgASAHaiIKLAAAQb9/SmogCkEBaiwAAEG/f0pqIApBAmosAABBv39KaiAKQQNqLAAAQb9/SmohBSAMIAdBBGoiB0cNAAsLIAlFDQAgASAHaiEHA0AgBSAHLAAAQb9/SmohBSAHQQFqIQcgCUEBayIJDQALCyAFIAZqIQYLAkAgAC8BDCIJIAZLBEACQAJAIAhBgICACHFFBEAgCSAGayEJQQAhBUEAIQYCQAJAAkAgCEEddkEDcUEBaw4DAAEAAgsgCSEGDAELIAlB/v8DcUEBdiEGCyAIQf///wBxIQogACgCBCEIIAAoAgAhAANAIAVB//8DcSAGQf//A3FPDQJBASEHIAVBAWohBSAAIAogCCgCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEHIAAoAgAiCCAAKAIEIgogCyABIAIQOQ0DQQAhBSAJIAZrQf//A3EhAQNAIAVB//8DcSABTw0CIAVBAWohBSAIQTAgCigCEBEAAEUNAAsMAwtBASEHIAAgCCALIAEgAhA5DQIgACADIAQgCCgCDBECAA0CQQAhBSAJIAZrQf//A3EhAQNAIAVB//8DcSICIAFJIQcgASACTQ0DIAVBAWohBSAAIAogCCgCEBEAAEUNAAsMAgsgCCADIAQgCigCDBECAA0BIAAgDTcCCEEADwtBASEHIAAoAgAiBiAAKAIEIgAgCyABIAIQOQ0AIAYgAyAEIAAoAgwRAgAhBwsgBwuUBgEFfyAAQQhrIgEgAEEEaygCACIDQXhxIgBqIQICQAJAIANBAXENACADQQJxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUHkmcAAKAIARgRAIAIoAgRBA3FBA0cNAUHcmcAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQHwsCQAJAAkACQAJAIAIoAgQiA0ECcUUEQCACQeiZwAAoAgBGDQIgAkHkmcAAKAIARg0DIAIgA0F4cSICEB8gASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB5JnAACgCAEcNAUHcmcAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQIEEAIQFB/JnAAEH8mcAAKAIAQQFrIgA2AgAgAA0EQcSXwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtB/JnAAEH/HyABIAFB/x9NGzYCAA8LQeiZwAAgATYCAEHgmcAAQeCZwAAoAgAgAGoiADYCACABIABBAXI2AgRB5JnAACgCACABRgRAQdyZwABBADYCAEHkmcAAQQA2AgALIABB9JnAACgCACIDTQ0DQeiZwAAoAgAiAkUNA0EAIQBB4JnAACgCACIEQSlJDQJBvJfAACEBA0AgAiABKAIAIgVPBEAgAiAFIAEoAgRqSQ0ECyABKAIIIQEMAAsAC0HkmcAAIAE2AgBB3JnAAEHcmcAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAA8LAkBB1JnAACgCACICQQEgAEEDdnQiA3FFBEBB1JnAACACIANyNgIAIABB+AFxQcyXwABqIgAhAgwBCyAAQfgBcSIAQcyXwABqIQIgAEHUl8AAaigCACEACyACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0HEl8AAKAIAIgEEQANAIABBAWohACABKAIIIgENAAsLQfyZwABB/x8gACAAQf8fTRs2AgAgAyAETw0AQfSZwABBfzYCAAsL6QQBBX8CfwJAIAJBAk8EQCABKAIEIgRB//8BcUUEQCAEQRB0DAMLIARB/wdxIQUgBEGAgAJxIQMgBEGA+AFxIgZBgPgBRgRAIANBEHQhAyADQYCAgPwHciAFRQ0DGiADIAVBDXRyQYCAgP4HcgwDCyADQRB0IQMgBkUNASAGQQ10QYCAgPwAcSAFQQ10ckGAgIDAA2ogA3IMAgtBAUEBQdCKwAAQMAALIAUgBWdBEGsiBUH//wNxQQhqdEH///8DcSADQYCAgNgDciAFQRd0a3ILIQUCfyAEQYCAfHEgBEEQdiIDQf//AXFFDQAaIANB/wdxIQQgA0GAgAJxIQYgA0GA+AFxIgdBgPgBRgRAIAZBEHQhBiAGQYCAgPwHciAERQ0BGiAGIANBDXRyQYCAgP4HcgwBCyAGQRB0IQMgB0ENdEGAgID8AHEgBEENdHJBgICAwANqIANyIAcNABogBCAEZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgshBCAAAn8CQCACQQJHBEAgASgCCCICQf//AXFFBEAgAkEQdAwDCyACQf8HcSEBIAJBgIACcSEDIAJBgPgBcSICQYD4AUYEQCADQRB0IQIgAkGAgID8B3IgAUUNAxogAiABQQ10ckGAgID+B3IMAwsgA0EQdCEDIAJFDQEgAkENdEGAgID8AHEgAUENdHJBgICAwANqIANyDAILQQJBAkHgisAAEDAACyABIAFnQRBrIgFB//8DcUEIanRB////A3EgA0GAgIDYA3IgAUEXdGtyCzYCCCAAIAQ2AgQgACAFNgIAC9sEAQZ/AkACQCAAKAIIIgdBgICAwAFxRQ0AAkACQAJAAkAgB0GAgICAAXEEQCAALwEOIgMNAUEAIQIMAgsgAkEQTwRAIAEgAhASIQMMBAsgAkUEQAwECyACQQNxIQYCQCACQQRJBEAMAQsgAkEMcSEIA0AgAyABIAVqIgQsAABBv39KaiAEQQFqLAAAQb9/SmogBEECaiwAAEG/f0pqIARBA2osAABBv39KaiEDIAggBUEEaiIFRw0ACwsgBkUNAyABIAVqIQQDQCADIAQsAABBv39KaiEDIARBAWohBCAGQQFrIgYNAAsMAwsgASACaiEIQQAhAiABIQQgAyEFA0AgBCIGIAhGDQICfyAGQQFqIAYsAAAiBEEATg0AGiAGQQJqIARBYEkNABogBkEDaiAEQXBJDQAaIAZBBGoLIgQgBmsgAmohAiAFQQFrIgUNAAsLQQAhBQsgAyAFayEDCyADIAAvAQwiBE8NACAEIANrIQZBACEDQQAhBQJAAkACQCAHQR12QQNxQQFrDgIAAQILIAYhBQwBCyAGQf7/A3FBAXYhBQsgB0H///8AcSEIIAAoAgQhByAAKAIAIQADQCADQf//A3EgBUH//wNxSQRAQQEhBCADQQFqIQMgACAIIAcoAhARAABFDQEMAwsLQQEhBCAAIAEgAiAHKAIMEQIADQFBACEDIAYgBWtB//8DcSEBA0AgA0H//wNxIgIgAUkhBCABIAJNDQIgA0EBaiEDIAAgCCAHKAIQEQAARQ0ACwwBCyAAKAIAIAEgAiAAKAIEKAIMEQIAIQQLIAQL+wMBCH8jAEEQayIGJAACfwJAIANBAXFFBEAgAi0AACIFDQFBAAwCCyAAIAIgA0EBdiABKAIMEQIADAELIAEoAgwhCgNAIAJBAWohBAJAAkACQAJAIAXAQQBIBEAgBUH/AXEiCEGAAUYNASAIQcABRw0DIAYgATYCBCAGIAA2AgAgBkKggICABjcCCCADIAdBA3RqIgIoAgAgBiACKAIEEQAARQ0CQQEMBgsgACAEIAVB/wFxIgIgChECAEUEQCACIARqIQIMBAtBAQwFCyAAIAJBA2oiBCACLwABIgIgChECAEUEQCACIARqIQIMAwtBAQwECyAHQQFqIQcgBCECDAELQaCAgIAGIQsgBUEBcQRAIAIoAAEhCyACQQVqIQQLQQAhCAJ/IAVBAnFFBEBBACEJIAQMAQsgBC8AACEJIARBAmoLIQIgBUEEcQR/IAIvAAAhCCACQQJqBSACCyEEIAVBCHEEfyAELwAAIQcgBEECagUgBAshAiAFQRBxBEAgAyAJQQN0ai8BBCEJCyAGIAVBIHEEfyADIAhBA3RqLwEEBSAICzsBDiAGIAk7AQwgBiALNgIIIAYgATYCBCAGIAA2AgBBASADIAdBA3RqIgQoAgAgBiAEKAIEEQAADQIaIAdBAWohBwsgAi0AACIFDQALQQALIAZBEGokAAv/BQILfwF+IwBBMGsiACQAAkACQAJAAkBB+JTAACgCAEEBRgRAQfyUwAAoAgAhAQwBC0GQlcAAKAIAIQFBkJXAAEEANgIAIAFFDQEgAEEYaiABEQUAIABBEGoiAyAAQSRqKQIANwMAIAAgACkCHDcDCCAAKAIYIQFB+JTAACgCAEEBRg0CQfiUwABBATYCAEGAlcAAIAApAwg3AgBBiJXAACADKQMANwIAC0GMlcAAKAIAIQNBiJXAACgCACEHQYiVwABCADcCAEGElcAAKAIAIQRBhJXAAEEANgIAQYCVwAAoAgAhBkH8lMAAQoCAgIDAADcCAAJAAkACQAJAIAQgB0YEQCABIARHDQLQb0GAASABIAFBgAFNGyIF/A8BIgJBf0cNAQwHCyAEIAdNDQYgBiAHQQJ0aigCACECQYyVwAAgAzYCAEGIlcAAIAI2AgBBhJXAACAENgIAQYCVwAAgBjYCAEH8lMAAIAE2AgAMAwsCQCADRQRAIAIhAwwBCyABIANqIAJHDQYLIABBGGohCCABIQJBASEKQQQhCQJAIAEgBWoiAa1CAoYiC0IgiFBFBEBBACEFDAELIAunIgVB/P///wdLBEBBACEFDAELAkACQAJ/IAIEQCAGIAJBAnRBBCAFEFoMAQsgBUUNASAFQQQQYwsiCQ0AIAhBBDYCBAwBCyAIIAk2AgRBACEKC0EIIQkLIAggCWogBTYCACAIIAo2AgAgACgCGEEBRg0FIAAoAhwhBgwBCyABIARNDQQLIAYgBEECdGogBEEBaiICNgIAQYyVwAAgAzYCAEGIlcAAIAI2AgBBhJXAACACNgIAQYCVwAAoAgBBgJXAACAGNgIAQfyUwAAoAgAhAkH8lMAAIAE2AgAgAkUNACACQQJ0EF8LIABBMGokACADIAdqDwtBkI7AAEHVAEG8jsAAEDUACyAAQShqIAMpAwA3AgAgACAAKQMINwIgIAAgATYCHCAAQQE2AhggAEEYahA+QfKNwABBHUGAjsAAEDUACwAL9wMBCn9BCiECIAAiBEHoB08EQCABQQRrIQYgBCEDAkACQANAIAMgA0GQzgBuIgRBkM4AbGsiCUH//wNxQeQAbiEHAkAgBUEKaiICQQRrQQpJBEAgBkEKaiIIIAdBAXQiCi0A5ZJAOgAAIAJBA2siC0EKSQ0BIAtBCkHIksAAEDAACyACQQRrQQpByJLAABAwAAsgCEEBaiAKQeaSwABqLQAAOgAAIAJBAmtBCkkEQCAIQQJqIAkgB0HkAGxrQQF0Qf7/B3EiBy0A5ZJAOgAAIAJBAWtBCk8NAiAIQQNqIAdB5pLAAGotAAA6AAAgBkEEayEGIAVBBGshBSADQf+s4gRLIAQhA0UNAwwBCwsgAkECa0EKQciSwAAQMAALIAJBAWtBCkHIksAAEDAACyAFQQpqIQILAkAgBEEJTQRAIAQhBSACIQMMAQsgBEH//wNxQeQAbiEFAkAgAkECayIDQQpJBEAgASADaiAEIAVB5ABsa0H//wNxQQF0IgYtAOWSQDoAACACQQFrIgRBCk8NASABIARqIAZB5pLAAGotAAA6AAAMAgsgA0EKQciSwAAQMAALIARBCkHIksAAEDAAC0EAIAAgBRtFBEAgA0EBayIDQQpPBEAgA0EKQciSwAAQMAALIAEgA2ogBUEBdC0A5pJAOgAACyADC4cEAgR/An0jAEEQayEBIAC8IgNBH3YhBAJAAn0gAAJ/AkACQAJAIANB/////wdxIgJB0Ni6lQRPBEAgAkGAgID8B0sEQCAADwsgAkGX5MWVBE0EQCADQQBODQIgAUMAAICAIACVOAIIIAEqAggaDAILIANBAEgEQCABQwAAgIAgAJU4AgggASoCCBogAkG047+WBE0NAgwHCyAAQwAAAH+UDwsgAkGY5MX1A00EQCACQYCAgMgDTQ0CQQAhASAADAULIAJBkquU/ANNDQILIABDO6q4P5QgBEECdCoC8JRAkvwADAILIAEgAEMAAAB/kjgCDCABKgIMGiAAQwAAgD+SDwsgBEUgBGsLIgGyIgVDAHIxv5SSIgAgBUOOvr81lCIGkwshBSAAIAUgBSAFIAWUIgAgAEMVUjW7lEOPqio+kpSTIgCUQwAAAEAgAJOVIAaTkkMAAIA/kiEFIAFFDQACQAJAAkAgAUH/AEwEQCABQYJ/Tg0DIAVDAACADJQhBSABQZt+TQ0BIAFB5gBqIQEMAwsgBUMAAAB/lCEFIAFB/gFLDQEgAUH/AGshAQwCCyAFQwAAgAyUIQVBtn0gASABQbZ9TRtBzAFqIQEMAQsgBUMAAAB/lCEFQf0CIAEgAUH9Ak8bQf4BayEBCyAFIAFBF3RBgICA/ANqQYCAgPwHcb6UIQULIAULjwQBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEHkmcAAKAIARgRAIAIoAgRBA3FBA0cNAUHcmcAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEB8LAkACQAJAIAIoAgQiA0ECcUUEQCACQeiZwAAoAgBGDQIgAkHkmcAAKAIARg0DIAIgA0F4cSICEB8gACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB5JnAACgCAEcNAUHcmcAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQIA8LAkBB1JnAACgCACICQQEgAUEDdnQiA3FFBEBB1JnAACACIANyNgIAIAFB+AFxQcyXwABqIgEhAgwBCyABQfgBcSIBQcyXwABqIQIgAUHUl8AAaigCACEBCyACIAA2AgggASAANgIMIAAgAjYCDCAAIAE2AggPC0HomcAAIAA2AgBB4JnAAEHgmcAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABB5JnAACgCAEcNAUHcmcAAQQA2AgBB5JnAAEEANgIADwtB5JnAACAANgIAQdyZwABB3JnAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgALC9ADAQZ/IwBBEGsiBSQAAkACQAJAAkACQAJAIAJBAXEEQCACQQF2IQMMAQsgAS0AACIDRQ0BIAEhBANAIARBAWohBAJAIAPAQQBIBEAgA0H/AXFBgAFGBEAgBiAELwAAIgNqIQYgAyAEakECaiEEDAILIAQgA0EDcUEYdyIIQQV0QYCAgIAEcSAIQYCAgIACcSAIQYCAgAhxQQd0cnJBHXZqIANBAXZBAnFqIANBAnZBAnFqIQQgBkUgB3IhBwwBCyAEIANB/wFxIgNqIQQgAyAGaiEGCyAELQAAIgMNAAtBACEDIAcgBkEQSXENAEEAIQcgBkEBdCIDQQBIDQQLIAMNAQtBASEEQQAhAwwBC0EBIQcgA0EBEGMiBEUNAQsgBUEANgIIIAUgBDYCBCAFIAM2AgAgBUGMkcAAIAEgAhAYRQ0BIwBBIGsiACQAIABB1gA2AgQgAEG0kcAANgIAIABBpJHAADYCDCAAIAVBD2o2AgggACAAQQhqrUKAgICAkAWENwMYIAAgAK1CgICAgLAFhDcDEEHvg8AAIABBEGpBjJLAABA1AAsgByADEE4ACyAAIAUpAgA3AgAgAEEIaiAFQQhqKAIANgIAIAVBEGokAAvnAgEFfwJAIAFBzf97QRAgACAAQRBNGyIAa08NACAAQRAgAUELakF4cSABQQtJGyIEakEMahARIgJFDQAgAkEIayEBAkAgAEEBayIDIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSACIANqQQAgAGtxQQhrIgIgAEEAIAIgAWtBEE0baiIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgASACaiIDIAMoAgRBAXI2AgQgASACEBwMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgACgCBCIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIAAgBCABQQFxckECcjYCBCAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBAcCyAAQQhqIQMLIAMLggMBBH8gACgCDCECAkACQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAgJAIAAoAhxBAnRBvJbAAGoiASgCACAARwRAIAMoAhAgAEYNASADIAI2AhQgAg0DDAQLIAEgAjYCACACRQ0EDAILIAMgAjYCECACDQEMAgsgACgCCCIAIAJHBEAgACACNgIMIAIgADYCCA8LQdSZwABB1JnAACgCAEF+IAFBA3Z3cTYCAA8LIAIgAzYCGCAAKAIQIgEEQCACIAE2AhAgASACNgIYCyAAKAIUIgBFDQAgAiAANgIUIAAgAjYCGA8LDwtB2JnAAEHYmcAAKAIAQX4gACgCHHdxNgIAC8QCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEmIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiAjYCHCACQQJ0QbyWwABqIQRBASACdCIDQdiZwAAoAgBxRQRAIAQgADYCACAAIAQ2AhggACAANgIMIAAgADYCCEHYmcAAQdiZwAAoAgAgA3I2AgAPCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEFA0AgAyAFQR12QQRxaiIEKAIQIgJFDQIgBUEBdCEFIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAEQRBqIAA2AgAgACADNgIYIAAgADYCDCAAIAA2AggLgwEBAX8jAEEgayIDJAACQAJAIAAgAU0EQAwBCyADIAA2AgggAyABNgIMIAMgA0EMaq1CgICAgNAAhDcDGAwBCyADIAA2AgggAyABNgIMIAMgA0EMaq1CgICAgNAAhDcDGAsgAyADQQhqrUKAgICA0ACENwMQQfuBwAAgA0EQaiACEDUAC4gCAQZ/IAAoAggiBCECAn9BASABQYABSQ0AGkECIAFBgBBJDQAaQQNBBCABQYCABEkbCyIGIAAoAgAgBGtLBH8gACAEIAYQKSAAKAIIBSACCyAAKAIEaiECAkAgAUGAAU8EQCABQT9xQYB/ciEFIAFBBnYhAyABQYAQSQRAIAIgBToAASACIANBwAFyOgAADAILIAFBDHYhByADQT9xQYB/ciEDIAFB//8DTQRAIAIgBToAAiACIAM6AAEgAiAHQeABcjoAAAwCCyACIAU6AAMgAiADOgACIAIgB0E/cUGAf3I6AAEgAiABQRJ2QXByOgAADAELIAIgAToAAAsgACAEIAZqNgIIQQALiAIBBn8gACgCCCIEIQICf0EBIAFBgAFJDQAaQQIgAUGAEEkNABpBA0EEIAFBgIAESRsLIgYgACgCACAEa0sEfyAAIAQgBhAsIAAoAggFIAILIAAoAgRqIQICQCABQYABTwRAIAFBP3FBgH9yIQUgAUEGdiEDIAFBgBBJBEAgAiAFOgABIAIgA0HAAXI6AAAMAgsgAUEMdiEHIANBP3FBgH9yIQMgAUH//wNNBEAgAiAFOgACIAIgAzoAASACIAdB4AFyOgAADAILIAIgBToAAyACIAM6AAIgAiAHQT9xQYB/cjoAASACIAFBEnZBcHI6AAAMAQsgAiABOgAACyAAIAQgBmo2AghBAAv6AQIDfwF+IwBBMGsiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBLGoiBEEANgIAIAJCgICAgBA3AiQgAkEkakHMjsAAIAMoAgAiAygCACADKAIEEBgaIAJBIGogBCgCACIDNgIAIAIgAikCJCIFNwMYIAFBCGogAzYCACABIAU3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBEGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDCEEMQQQQYyIBRQRAQQRBDBBmAAsgASACKQMINwIAIAFBCGogAygCADYCACAAQdiQwAA2AgQgACABNgIAIAJBMGokAAuUAgECfyMAQSBrIgUkAEG4lsAAQbiWwAAoAgAiBkEBajYCAAJAAn9BACAGQQBIDQAaQQFBpJbAAC0AAA0AGkGklsAAQQE6AABBoJbAAEGglsAAKAIAQQFqNgIAQQILQf8BcSIGQQJHBEAgBkEBcUUNASAFQQhqIAAgASgCGBEBAAwBC0GslsAAKAIAIgZBAEgNAEGslsAAIAZBAWo2AgBBsJbAACgCAARAIAUgACABKAIUEQEAIAUgBDoAHSAFIAM6ABwgBSACNgIYIAUgBSkDADcCEEGwlsAAKAIAIAVBEGpBtJbAACgCACgCFBEBAAtBrJbAAEGslsAAKAIAQQFrNgIAQaSWwABBADoAACADRQ0AAAsAC6gBAgJ/AX5BASEHQQQhBgJAIAQgBWpBAWtBACAEa3GtIAOtfiIIQiCIUEUEQEEAIQMMAQsgCKciA0GAgICAeCAEa0sEQEEAIQMMAQsCQAJAAn8gAQRAIAIgASAFbCAEIAMQWgwBCyADRQRAIAQhBgwCCyADIAQQYwsiBg0AIAAgBDYCBAwBCyAAIAY2AgRBACEHC0EIIQYLIAAgBmogAzYCACAAIAc2AgALpwEBAX8jAEEQayIFJAAgBEUEQEEAQQAQTgALIAIgASACaiIBSwRAQQBBABBOAAsgBUEEaiAAKAIAIgIgACgCBCABIAJBAXQiAiABIAJLGyIBQQhBBEEBIARBgQhJGyAEQQFGGyICIAEgAksbIgEgAyAEECYgBSgCBEEBRgRAIAUoAgggBSgCDBBOAAsgBSgCCCECIAAgATYCACAAIAI2AgQgBUEQaiQAC6MBAQF/IwBBEGsiBiQAAkAgAQRAIAZBBGogASADIAQgBSACKAIQEQgAAkAgBigCBCICIAYoAgwiAU0EQCAGKAIIIQUMAQsgAkECdCECIAYoAgghAyABRQRAQQQhBSADIAIQXwwBCyADIAJBBCABQQJ0IgIQWiIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQcCNwABBMhBkAAtBBCACEE4AC4cBAQF/IwBBEGsiAyQAIAIgASACaiIBSwRAQQBBABBOAAsgA0EEaiAAKAIAIgIgACgCBEEIIAEgAkEBdCICIAEgAksbIgEgAUEITRsiAUEBQQEQJiADKAIEQQFGBEAgAygCCCADKAIMEE4ACyADKAIIIQIgACABNgIAIAAgAjYCBCADQRBqJAALjgECA38BbyMAQRBrIgMkACAAKAIAIgAQbSEEIAMgAjYCDCADIAQ2AgggAiAERgRAEFgiBRBVIgQlASABIAIQBCEGEBkiASAGJgEgBUGEAU8EQCAFEDYLIARBhAFPBEAgBBA2CyAAIAFBABBeIAFBhAFPBEAgARA2CyADQRBqJAAPCyADQQhqIANBDGoQOAALnAECA38BfiMAQSBrIgIkACABKAIAQYCAgIB4RgRAIAEoAgwhAyACQRxqIgRBADYCACACQoCAgIAQNwIUIAJBFGpBzI7AACADKAIAIgMoAgAgAygCBBAYGiACQRBqIAQoAgAiAzYCACACIAIpAhQiBTcDCCABQQhqIAM2AgAgASAFNwIACyAAQdiQwAA2AgQgACABNgIAIAJBIGokAAvxAQEEfyMAQRBrIgMkACACIAEgAmoiAUsEQEEAQQAQTgALIANBBGohBCAAKAIEIQYCf0EIIAEgACgCACICQQF0IgUgASAFSxsiASABQQhNGyIFIgFBAEgEQEEBIQJBACEBQQQMAQsCfwJAAn8gAgRAIAYgAkEBIAEQWgwBCyABRQRAQQEhAgwCCyABQQEQYwsiAg0AIARBATYCBEEBDAELIAQgAjYCBEEACyECQQgLIARqIAE2AgAgBCACNgIAIAMoAgRBAUYEQCADKAIIIAMoAgwQTgALIAMoAgghASAAIAU2AgAgACABNgIEIANBEGokAAtoAQJ/QQEhAwJAIAFBAXEEQCABQQF2IQIgAUECTwRAIAJBARBjIgNFDQILIAIEQCADQfODwAAgAvwKAAALIAAgAjYCCCAAIAM2AgQgACACNgIADwsgAEHzg8AAIAEQHQ8LQQEgAhBOAAtpAQN/IwBBEGsiASQAIAFBBGogACgCACICIAAoAgRBBCACQQF0IgIgAkEETRsiAkEEQQQQJiABKAIEQQFGBEAgASgCCCABKAIMEE4ACyABKAIIIQMgACACNgIAIAAgAzYCBCABQRBqJAALiwECA38BbyMAQRBrIgMkACADIAAoAgAQbSIENgIIIAMgAjYCDCACIARHBEAgA0EIaiADQQxqEDgACxBYIgQQVSIFJQEQBiEGEBkiAiAGJgEgBUGEAU8EQCAFEDYLIAIgACgCACABQQJ2EF4gAkGEAU8EQCACEDYLIARBhAFPBEAgBBA2CyADQRBqJAALTwIBfwF+IwBBIGsiAyQAIAMgATYCDCADIAA2AgggA0KAgICA0AAiBCADQQhqrYQ3AxggAyAEIANBDGqthDcDEEGLgcAAIANBEGogAhA1AAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACECkgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACECwgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAs0AQF/IwBBEGsiAiQAIAFBAUEAIAAoAgAgAkEGaiIBEBoiACABakEKIABrEBQgAkEQaiQAC0QBAn8gASgCBCECIAEoAgAhA0EIQQQQYyIBRQRAQQRBCBBmAAsgASACNgIEIAEgAzYCACAAQbyQwAA2AgQgACABNgIAC94BAgF/AX4jAEEgayIDJAAgAyABNgIQIAMgADYCDCADQQE7ARwgAyACNgIYIAMgA0EMajYCFCMAQRBrIgEkACADQRRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIEIgNBAXEEQCACKAIAIQIgACADQQF2NgIEIAAgAjYCACAAQeSOwAAgASgCBCABKAIIIgAtAAggAC0ACRAlAAsgAEGAgICAeDYCACAAIAE2AgwgAEGAj8AAIAEoAgQgASgCCCIALQAIIAAtAAkQJQAL1gMBBn8jAEEQayIFJAAgBSAANgIMIABBhAFPBEAgANBvJgEgBUEMaiECIwBBMGsiACQAAkACQAJAAkACQEH4lMAAKAIAQQFGBEBB/JTAACgCACEDDAELQZCVwAAoAgAhA0GQlcAAQQA2AgAgA0UNASAAQRhqIAMRBQAgAEEQaiIBIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghA0H4lMAAKAIAQQFGDQJB+JTAAEEBNgIAQYCVwAAgACkDCDcCAEGIlcAAIAEpAwA3AgALQYCVwAAoAgAhAUH8lMAAQoCAgIDAADcCACACKAIAIgRBjJXAACgCACICSQ0CIAQgAmsiBEGElcAAKAIAIgZPDQIgASAEQQJ0akGIlcAAKAIANgIAQYyVwAAgAjYCAEGIlcAAIAQ2AgBBhJXAACAGNgIAQYCVwAAoAgAhAkGAlcAAIAE2AgBB/JTAACgCACEBQfyUwAAgAzYCACABBEAgAiABQQJ0EF8LIABBMGokAAwDC0GQjsAAQdUAQbyOwAAQNQALIABBKGogASkDADcCACAAIAApAwg3AiAgACADNgIcIABBATYCGCAAQRhqED5B8o3AAEEdQYCOwAAQNQsACwsgBUEQaiQACz4AIAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQVg8LIAEoAgAgASgCBCAAKAIMKAIAIgAoAgAgACgCBBAYC64BAQF/IwBBEGsiAiQAIAIgATYCDCACIAA2AggjAEFAaiIAJAAgAEG0ksAANgIEIAAgAkEIajYCACAAQbSSwAA2AgwgACACQQxqNgIIIABB5JTAACgCADYCFCAAQdiUwAAoAgA2AhAgACAAQQhqrUKAgICAkAWENwMwIAAgAK1CgICAgJAFhDcDKCAAIABBEGqtQoCAgICwBYQ3AyBBsoLAACAAQSBqQbCNwAAQNQALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgALswEBAn8jAEEQayIAJAAgASgCAEHMkMAAQQsgASgCBCgCDBECACEDIABBCGoiAkEAOgAFIAIgAzoABCACIAE2AgAgAiIBLQAEIQIgAS0ABQRAIAECf0EBIAJBAXENABogASgCACIBLQAKQYABcUUEQCABKAIAQdiSwABBAiABKAIEKAIMEQIADAELIAEoAgBBxJLAAEEBIAEoAgQoAgwRAgALIgI6AAQLIAJBAXEgAEEQaiQAC4sUAhp/EH0QGSIOIAkmASMAQYABayINJAAgDSAONgIsIA0gCDYCKCANIAc4AiQgDSAGOAIgIA0gBTgCHCANIAQ4AhggDSADOAIUIA0gAjgCECANIAE4AgwgDSAAOAIIIA0gCkEARzoAMyANIAs4AjQgDSAMOAI4IA1BADYCRCANQoCAgIDAADcCPCANIA1BOGo2AnwgDSANQTRqNgJ4IA0gDUEkajYCdCANIA1BIGo2AnAgDSANQRxqNgJsIA0gDUEYajYCaCANIA1BFGo2AmQgDSANQRBqNgJgIA0gDUEMajYCXCANIA1BCGo2AlggDSANQTxqNgJUIA0gDUEzajYCUCANIA1BLGo2AkwgDSANQShqNgJIIA1ByABqIiQhCCMAQSBrIg4kAAJAQQBBvIrAACgCABEEACIUBEACQCAUKAIARQRAIAgoAjQhFyAIKAIwIRggCCgCLCEZIAgoAighGiAIKAIkIRsgCCgCICEcIAgoAhwhHSAIKAIYIR4gCCgCFCEfIAgoAhAhICAIKAIMIRIgCCgCCCElIAgoAgQhJiAIKAIAISEgFEF/NgIAIBQgISgCACIPBH8gFEEMaigCACEiIBRBCGooAgAhCgNAIA4gJiAVQQJ0IBVBgIAEIA8gFWsiCCAIQYCABE8bIghqIhVBAnQQYCIjNgIEIAhBAnQiDyAiSw0DIA5BBGogCiAPEC8CQCAlLQAARQRAIA4gHioCADgCECAOIB8qAgA4AgwgDiAgKgIAOAIIIA4gGyoCADgCHCAOIBwqAgA4AhggDiAdKgIAOAIUIAohCCAaKgIAISggGSoCACEnIBgqAgAhACAXKgIAIQEjAEEQayITJAAgDwRAIA5BFGoiECoCACICIAKUIBAqAgQiAyADlJIgECoCCCIEIASUkiEFIAEgAJNDAAB+Q5UhASAOQQhqIhAqAgghKSAQKgIEISogECoCACErA0AgD0EEIA9BBEkiERshEAJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgE0EEaiAIIBAQFiARRQRAIAIgKyATKgIEkyIGlCADICogEyoCCJMiB5SSIAQgKSATKgIMkyILlJIiDCAMlCAFIAYgBpQgByAHlJIgCyALlJIgCCgCDCIRQf8BcQR9IAAgASARQQFrQf8BcbOUkhAbBUMAAAAACyARQQh2IhZB/wFxBH0gACABIBZBAWtB/wFxs5SSEBsFQwAAAAALkiARQRB2IhFB/wFxBH0gACABIBFBAWtB/wFxs5SSEBsFQwAAAAALkkMAAEBAlSIGIAaUk5STIgZDAAAAAF0NASAMjCAGkZMgBZUiBiAoYEUgBiAnX0VyDQEgEigCCCIRIBIoAgBGBEAgEhAuCyASKAIEIBFBAnRqIAY4AgAgEiARQQFqNgIIDAELQQMgEEHAisAAEDAACyAIIBBBAnRqIQggDyAQayIPDQALCwwBCyAOIB4qAgA4AhAgDiAfKgIAOAIMIA4gICoCADgCCCAOIBsqAgA4AhwgDiAcKgIAOAIYIA4gHSoCADgCFCAKIQggGioCACEyIBkqAgAhMyAYKgIAISggFyoCACEAIwBBEGsiEyQAIA8EQCAAICiTQwAAfkOVISkgDkEUaiIQKgIAISogECoCBCErIBAqAgghLiAOQQhqIhAqAgghNCAQKgIEITUgECoCACE2A0AgD0EEIA9BBEkiERshEAJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgE0EEaiAIIBAQFgJAIBFFBEAgEyoCDCEAIBMqAgghASATKgIEIQJDAAAAACEDQwAAAAAhBCAIKAIMIhFB/wFxBEAgKCApIBFBAWtB/wFxs5SSEBshBAsgEUEIdiIWQf8BcQRAICggKSAWQQFrQf8BcbOUkhAbIQMLIDQgAJMhJyA1IAGTIS8gNiACkyEwIBFBEHYiFkH/AXEEfSAoICkgFkEBa0H/AXGzlJIQGwVDAAAAAAshBSAuIAgoAggiFkEYdbJDAAD+QpUiACArIBFBGHWyQwAA/kKVIgGUIC4gAJSTIgyUIBZBEHbAskMAAP5ClSICIC4gApQgKiABlJMiLJSTICogAJQgKyAClJMiLUMAAIA/IAIgApSTIAAgAJSTIAEgAZSTQwAAAAAQS5EiBpSSIgcgB5KSIQcgKyACIC2UIAEgDJSTICwgBpSSIgsgC5KSIQsgKiABICyUIAAgLZSTIAwgBpSSIgwgDJKSIQwgJyAAIC8gAZQgJyAAlJMiLJQgAiAnIAKUIDAgAZSTIi2UkyAwIACUIC8gApSTIjEgBpSSIicgJ5KSIScgLyACIDGUIAEgLJSTIC0gBpSSIgIgApKSIQIgMCABIC2UIAAgMZSTICwgBpSSIgAgAJKSIQAgBSAEIAMQSyAFEEtDCtcjPJQiAV1FBEAgASADXkUEQCABIAReRQRAQwAAgD8gBZUiBSAnlCIBIAUgB5QiBZRDAACAPyAElSIEIACUIgAgBCAMlCIElEMAAIA/IAOVIgMgApQiAiADIAuUIgOUkpIiBiAGlCAFIAWUIAQgBJQgAyADlJKSIgMgASABlCAAIACUIAIgApSSkkMAAIC/kpSTIgBDAAAAAF0NBSAGjCAAkZMgA5UhAAwECyAMi0O9N4Y1XQ0EIAIgCyAAjCAMlSIAlJIgA5UiASABlCAnIAcgAJSSIAWVIgEgAZSSQwAAgD9eRQ0DDAQLIAuLQ703hjVdDQMgACAMIAKMIAuVIgCUkiAElSIBIAGUICcgByAAlJIgBZUiASABlJJDAACAP14NAwwCCyAHi0O9N4Y1XQ0CIAAgDCAnjCAHlSIAlJIgBJUiASABlCACIAsgAJSSIAOVIgEgAZSSQwAAgD9eRQ0BDAILQQMgEEHAisAAEDAACyAAIDJgRSAAIDNfRXINACASKAIIIhEgEigCAEYEQCASEC4LIBIoAgQgEUECdGogADgCACASIBFBAWo2AggLIAggEEECdGohCCAPIBBrIg8NAAsLCyATQRBqJAAgI0GEAU8EQCAjEDYLIBUgISgCACIPSQ0ACyAUKAIAQQFqBUEACzYCACAOQSBqJAAMAwsQPQALIA8gIkHQi8AAECEACxA8AAsgDSgCRBAMIQkQGSIIIAkmASANIAg2AkggDSgCQCEUIA0oAkQhDiMAQRBrIgokACAkKAIAIhUlARAJIQ8gCiAONgIMIAogDzYCCAJAIA4gD0YEQBBYIg8QVSISJQEgFCAOEAghCRAZIg4gCSYBIA9BhAFPBEAgDxA2CyASQYQBTwRAIBIQNgsgFSUBIA4lAUEAEAogDkGEAU8EQCAOEDYLIApBEGokAAwBCyAKQQhqIApBDGoQOAALIA0oAjwiCgRAIA0oAkAgCkECdBBfCyANKAIsIgpBhAFPBEAgChA2CyANQYABaiQAIAglASAIEDYLLwEBfyMAQRBrIgAkACAAIABBD2qtQoCAgIDAAoQ3AwBBpIPAACAAQfCKwAAQNQALLwEBfyMAQRBrIgAkACAAIABBD2qtQoCAgIDABYQ3AwBB84PAACAAQYCLwAAQNQALJQEBfwJAIAAoAgBFDQAgACgCBCIBRQ0AIAAoAgggAUECdBBfCwskACAARQRAQcCNwABBMhBkAAsgACACIAMgBCAFIAEoAhARBwALIgAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAQgASgCEBEQAAsiACAARQRAQcCNwABBMhBkAAsgACACIAMgBCABKAIQEQ0ACyIAIABFBEBBwI3AAEEyEGQACyAAIAIgAyAEIAEoAhARGAALIgAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAQgASgCEBEaAAsiACAARQRAQcCNwABBMhBkAAsgACACIAMgBCABKAIQERwACyUBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAEQXwsLIAAgAEUEQEHAjcAAQTIQZAALIAAgAiADIAEoAhARAwALHgAgAEUEQEHAjcAAQTIQZAALIAAgAiABKAIQEQAAC4wPARZ/EBkiBCABJgEQGSIOIAImASMAQSBrIgokACAKIA42AgggCiAENgIEIAogADYCACAKIApBBGoiACgCABBtNgIMIAogCkEIajYCHCAKIAo2AhggCiAANgIUIAogCkEMajYCECAKQRBqIQAjAEEwayIJJAACQAJAAkACQAJAQQBBuIrAACgCABEEACIPBEAgDygCAA0BIAAoAgwhGCAAKAIIIQUgACgCACEEIA9BfzYCACAAKAIEIQAgD0EEaiILIAQoAgAQEyAJIABBACAFKAIAEGAiFjYCACAFKAIAIg4gDygCDCIASw0CIAkgDygCCCAOEC8gCUEEaiEVIAQoAgAhACAFKAIAIRAjAEEgayISJAAgCyAAEBMCQCALKAIIIgAgEE8EQCALKAIEIQ4gCygCHCEEIAsoAiAiFEECdCIGBEAgBEEAIAb8CwALIAsoAighEyALKAIsIhFBAnQiFwRAIBNBACAX/AsACyAQQQJ0IQwgEARAIAwhBSAOIQADQAJAIAAoAgAiA0GAgID8B08NACAUIANBf3MiB0H//wNxIgNLBEAgBCADQQJ0aiIDIAMoAgBBAWo2AgAgESAHQRB2IgNLBEAgEyADQQJ0aiIDIAMoAgBBAWo2AgAMAgsgAyARQbCMwAAQMAALIAMgFEGgjMAAEDAACyAAQQRqIQAgBUEEayIFDQALCwJAIBRFBEBBACEFDAELIAZBBGsiBUECdkEBaiIAQQdxIQ0CQCAFQRxJBEBBACEFIAQhAAwBCyAAQfj///8HcSEIQQAhBSAEIQADQCAAKAIAIQYgACAFNgIAIABBBGoiAygCACEHIAMgBSAGaiIDNgIAIABBCGoiBSgCACEGIAUgAyAHaiIDNgIAIABBDGoiBSgCACEHIAUgAyAGaiIDNgIAIABBEGoiBSgCACEGIAUgAyAHaiIDNgIAIABBFGoiBSgCACEHIAUgAyAGaiIDNgIAIABBGGoiBSgCACEGIAUgAyAHaiIHNgIAIABBHGoiBSgCACAFIAYgB2oiBTYCACAFaiEFIABBIGohACAIQQhrIggNAAsLIA1FDQAgDUECdCEIA0AgACgCACAAIAU2AgAgAEEEaiEAIAVqIQUgCEEEayIIDQALCyASIAU2AgwgEARAIAsoAjQhByALKAI4IQ1BACEIIA4hAANAAkAgACgCACIDQYCAgPwHTw0AAkAgFCADQX9zQf//A3EiA0sEQCAEIANBAnRqIgYoAgAiAyANTw0BIAcgA0ECdGogCDYCACAGIAYoAgBBAWo2AgAMAgsgAyAUQcCMwAAQMAALIAMgDUHQjMAAEDAACyAAQQRqIQAgCEEBaiEIIAxBBGsiDA0ACwsCQCARRQ0AIBdBBGsiDEECdkEBaiIEQQdxIQ1BACEIIBMhACAMQRxPBEAgBEH4////B3EhDANAIAAoAgAhAyAAIAg2AgAgAEEEaiIEKAIAIQcgBCADIAhqIgM2AgAgAEEIaiIEKAIAIQYgBCADIAdqIgM2AgAgAEEMaiIEKAIAIQcgBCADIAZqIgM2AgAgAEEQaiIEKAIAIQYgBCADIAdqIgM2AgAgAEEUaiIEKAIAIQcgBCADIAZqIgM2AgAgAEEYaiIEKAIAIQYgBCADIAdqIgc2AgAgAEEcaiIEKAIAIAQgBiAHaiIENgIAIARqIQggAEEgaiEAIAxBCGsiDA0ACwsgDUUNACANQQJ0IQwDQCAAKAIAIAAgCDYCACAAQQRqIQAgCGohCCAMQQRrIgwNAAsLIAVFDQEgCygCNCEIIAsoAjhBAnQhACALKAIQIQwgCygCFCEGIAUhBAJAAkADQCAARQ0EIBAgCCgCACINSwRAIA4gDUECdGooAgBBf3NBEHYiAyARTw0CIBMgA0ECdGoiBygCACIDIAZPDQMgCEEEaiEIIAwgA0ECdGogDTYCACAHIAcoAgBBAWo2AgAgAEEEayEAIARBAWsiBA0BDAULCyANIBBB4IzAABAwAAsgAyARQfCMwAAQMAALIAMgBkGAjcAAEDAACyAQIABBoI3AABAhAAsCQAJAIBFB//8DSwRAIBMoAvz/DyAFRw0BIBVBgICAgHg2AgAgFSAFNgIEDAILQf//AyARQZCNwAAQMAALIBIgE0H8/w9qrUKAgICA0ACENwMYIBIgEkEMaq1CgICAgNAAhDcDECAVQb6AwAAgEkEQahAdCyASQSBqJAAgCSgCBEGAgICAeEcNAyAJKAIIIgRFDQUgBCAPKAIYIgBLDQQgDygCFCEAIAkgGEEAIAQQYCIONgIcIAlBHGogACAEECogDkGEAUkNBSAOEDYMBQsQPAALED0ACyAOIABBwIvAABAhAAsgCUEYaiAJQQxqKAIANgIAIAkgCSkCBDcDECAJIAlBEGqtQoCAgIDAAIQ3AyggCUEcaiAJQShqEC0gCSgCICAJKAIkEGQACyAEIABBsIvAABAhAAsgFkGEAU8EQCAWEDYLIA8gDygCAEEBajYCACAJQTBqJAAgCigCCCIAQYQBTwRAIAAQNgsgCigCBCIAQYQBTwRAIAAQNgsgCkEgaiQAIAQLpQ4BEH8QGSIDIAEmARAZIgYgAiYBIwBBIGsiCSQAIAkgBjYCCCAJIAM2AgQgCSAANgIAIAkgCUEEaiIAKAIAEGw2AgwgCSAJQQhqNgIcIAkgCTYCGCAJIAA2AhQgCSAJQQxqNgIQIAlBEGohACMAQTBrIgckAAJAAkACQAJAAkBBAEG0isAAKAIAEQQAIg4EQCAOKAIADQEgACgCDCESIAAoAgghCyAOQX82AgAgACgCBCAAKAIAKAIAIgggDkEEaiIEKAIIIgNLBEAgCCADIgBrIgUgBCgCACAAa0sEQCAEIAAgBUECQQIQJyAEKAIIIQALIAQoAgQiDCAAQQF0aiEGIAVBAk8EQCAIIANBf3NqQQF0Ig0EQCAGQQAgDfwLAAsgACAIakEBdCADQQF0ayAMakECayEGIAAgBWpBAWshAAsgBkEAOwEAIAQgAEEBajYCCAsgBCgCFCIDIAhJBEAgCCADIgBrIgUgBCgCDCAAa0sEQCAEQQxqIAAgBUEEQQQQJyAEKAIUIQALIAQoAhAiDCAAQQJ0aiEGIAVBAk8EQCAIIANBf3NqQQJ0Ig0EQCAGQQAgDfwLAAsgACAIakECdCADQQJ0ayAMakEEayEGIAAgBWpBAWshAAsgBkEANgIAIAQgAEEBajYCFAsgBCgCICIAQYD4AU0EQEGB+AEgACIDayIGIAQoAhggAGtLBEAgBEEYaiAAIAZBBEEEECcgBCgCICEDCyAEKAIcIgggA0ECdCIFaiEGIABBgPgBRwR/QYDgByAAQQJ0IgxrIg0EQCAGQQAgDfwLAAsgAyAAa0GA+AFqIQMgBSAMayAIakGA4AdqBSAGC0EANgIAIAQgA0EBajYCIAsoAgAlAUEAIAsoAgAQCyEBEBkiECABJgEgByAQNgIAIAsoAgAiAyAOKAIMIgBLDQIgDigCCCEFIwBBEGsiACQAIAAgBygCABBsIgY2AgggACADNgIMIAMgBkcEQCAAQQhqIABBDGoQOAALEFgiBhBVIgglARACIQEQGSIDIAEmASAIQYQBTwRAIAgQNgsgAyUBIAcoAgAlASAFQQF2EAMgA0GEAU8EQCADEDYLIAZBhAFPBEAgBhA2CyAAQRBqJAAgB0EEaiERIAsoAgAhDEEAIQUjAEEgayILJAACQAJAAkACQCAEKAIIIgAgDE8EQCAEKAIEIQggBEEANgIgIAQoAhhBgPgBTQRAIARBGGpBAEGB+AFBBEEEECcgBCgCICEFCyAEKAIcIg8gBUECdGoiAEEAQYDgB/wLACAEIAVBgfgBaiINNgIgIABBgOAHakEANgIAIAxBAXQhBiAMBEAgBiEDIAghAANAIAAvAQAiCkGA+AFJBEAgCiANTw0EIA8gCkECdGoiCiAKKAIAQQFqNgIACyAAQQJqIQAgA0ECayIDDQALCyAPIA1BAnRqQQhrIgAoAgAhAyAAQQA2AgAgBUEDcUEBRwRAIAVBAWtBA3EhBQNAIABBBGsiACgCACEKIAAgAzYCACALIAMgCmoiAzYCDCAFQQFrIgUNAAsLIABBEGshAANAIABBDGoiBSgCACEKIAUgAzYCACALIAMgCmoiAzYCDCAAQQhqIgUoAgAhCiAFIAM2AgAgCyADIApqIgM2AgwgAEEEaiIFKAIAIQogBSADNgIAIAsgAyAKaiIDNgIMIAAoAgAhBSAAIAM2AgAgCyADIAVqIgM2AgwgACAPRyAAQRBrIQANAAsgDARAIAQoAhAhCiAEKAIUIQVBACEAA0AgCC8BACIEQf/3AU0EQCAEIA1PDQUgDyAEQQJ0aiIEKAIAIgwgBU8NBiAKIAxBAnRqIAA2AgAgBCAEKAIAQQFqNgIACyAIQQJqIQggAEEBaiEAIAZBAmsiBg0ACwsgAyAPKAIARgRAIBFBgICAgHg2AgAgESADNgIEDAULIAsgD61CgICAgNAAhDcDGCALIAtBDGqtQoCAgIDQAIQ3AxAgEUG+gMAAIAtBEGoQHQwECyAMIABBkIzAABAhAAsgCiANQeCLwAAQMAALIAQgDUHwi8AAEDAACyAMIAVBgIzAABAwAAsgC0EgaiQAIAcoAgRBgICAgHhHDQMgBygCCCIARQ0FIAAgDigCGCIDSw0EIA4oAhQhBiAHIBJBACAAEGAiAzYCHCAHQRxqIAYgABAqIANBhAFJDQUgAxA2DAULEDwACxA9AAsgAyAAQaCLwAAQIQALIAdBGGogB0EMaigCADYCACAHIAcpAgQ3AxAgByAHQRBqrUKAgICAwACENwMoIAdBHGogB0EoahAtIAcoAiAgBygCJBBkAAsgACADQZCLwAAQIQALIBBBhAFPBEAgEBA2CyAOIA4oAgBBAWo2AgAgB0EwaiQAIAkoAggiA0GEAU8EQCADEDYLIAkoAgQiA0GEAU8EQCADEDYLIAlBIGokACAACxcBAX8gACgCACIBBEAgACgCBCABEF8LCxQAIAEgASAAIAAgAV0bIAAgAFwbCx8AIABBCGpBtI/AACkCADcCACAAQayPwAApAgA3AgALHwAgAEEIakGkj8AAKQIANwIAIABBnI/AACkCADcCAAsdACAABEAgACABEGYAC0HokMAAQSNB/JDAABA1AAuIAwEKf0G8lcAALQAAQQFHBEACQAJ/AkAgAEUNACAAKAIAIABBADYCAEEBcUUNACAAKAIoIQIgACgCJCEIIAAoAiAhAyAAKAIcIQQgACgCGCEJIAAoAhQhBSAAKAIQIQYgACgCDCEKIAAoAgghByAAKAIEDAELQQIhCkEEIQhBACECQQQhCUEACyEAAkACQAJAQbyVwAAtAABBAWsOAgACAQtBvJXAAEECOgAAQZiVwAAoAgAiAQRAQZyVwAAoAgAgAUEBdBBfC0GklcAAKAIAIgEEQEGolcAAKAIAIAFBAnQQXwtBsJXAACgCACIBRQ0AQbSVwAAoAgAgAUECdBBfC0G8lcAAQQE6AABBuJXAACACNgIAQbSVwAAgCDYCAEGwlcAAIAM2AgBBrJXAACAENgIAQaiVwAAgCTYCAEGklcAAIAU2AgBBoJXAACAGNgIAQZyVwAAgCjYCAEGYlcAAIAc2AgBBlJXAACAANgIADAELQYCAwABB/QBBpIrAABA1AAsLQZSVwAALowIBBH9B0JXAAC0AAEEBRwRAAkACQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQMAQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBgIAQIQNBAAshAAJAAkBB0JXAAC0AAEEBaw4CAAMBC0HQlcAAQQI6AABBxJXAACgCACIERQ0AQciVwAAoAgAgBEECdBBfC0HQlcAAQQE6AABBzJXAACACNgIAQciVwAAgATYCAEHElcAAIAM2AgBBwJXAACAANgIADAILQQRBgIDAABBOAAtBgIDAAEH9AEGkisAAEDUACwtBwJXAAAvOBAERf0GUlsAALQAAQQFHBEACQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjghAyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELIAAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQAhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACEQCwJAAkACQEGUlsAALQAAQQFrDgIAAgELQZSWwABBAjoAAEHYlcAAKAIAIgAEQEHclcAAKAIAIABBAnQQXwtB5JXAACgCACIABEBB6JXAACgCACAAQQJ0EF8LQfCVwAAoAgAiAARAQfSVwAAoAgAgAEECdBBfC0H8lcAAKAIAIgAEQEGAlsAAKAIAIABBAnQQXwtBiJbAACgCACIARQ0AQYyWwAAoAgAgAEECdBBfC0GUlsAAQQE6AABBkJbAACABNgIAQYyWwAAgAjYCAEGIlsAAIAM2AgBBhJbAACAENgIAQYCWwAAgBTYCAEH8lcAAIAY2AgBB+JXAACAHNgIAQfSVwAAgCDYCAEHwlcAAIAk2AgBB7JXAACAKNgIAQeiVwAAgCzYCAEHklcAAIAw2AgBB4JXAACANNgIAQdyVwAAgDjYCAEHYlcAAIA82AgBB1JXAACAQNgIADAELQYCAwABB/QBBpIrAABA1AAsLQdSVwAALHAAgAEEANgIQIABCADcCCCAAQoCAgIDAADcCAAsMACAAQd0AIAEQNQALGAAgASgCACABKAIEIAAoAgAgACgCBBAYCxYBAW8gACUBEAAhARAZIgAgASYBIAALFgAgACgCACABIAIgACgCBCgCDBECAAsUACAAKAIAIAEgACgCBCgCDBEAAAsUAgFvAX8QDiEAEBkiASAAJgEgAQsQACABIAAoAgQgACgCCBAXC98GAQV/An8CQAJAAkACQAJAAkACQCAAQQRrIgcoAgAiCEF4cSIEQQRBCCAIQQNxIgUbIAFqTwRAIAVBACABQSdqIgYgBEkbDQECQCACQQlPBEAgAiADEB4iAg0BQQAMCgtBACECIANBzP97Sw0IQRAgA0ELakF4cSADQQtJGyEBIABBCGshBiAFRQRAIAZFIAFBgAJJciAEIAFrQYCACEsgASAET3JyDQcgAAwKCyAEIAZqIQUCQCABIARLBEAgBUHomcAAKAIARg0BQeSZwAAoAgAgBUcEQCAFKAIEIghBAnENCSAIQXhxIgggBGoiBCABSQ0JIAUgCBAfIAQgAWsiBUEQTwRAIAcgASAHKAIAQQFxckECcjYCACABIAZqIgEgBUEDcjYCBCAEIAZqIgQgBCgCBEEBcjYCBCABIAUQHAwJCyAHIAQgBygCAEEBcXJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgQMCAtB3JnAACgCACAEaiIEIAFJDQgCQCAEIAFrIgVBD00EQCAHIAhBAXEgBHJBAnI2AgAgBCAGaiIBIAEoAgRBAXI2AgRBACEFQQAhAQwBCyAHIAEgCEEBcXJBAnI2AgAgASAGaiIBIAVBAXI2AgQgBCAGaiIEIAU2AgAgBCAEKAIEQX5xNgIEC0HkmcAAIAE2AgBB3JnAACAFNgIADAcLIAQgAWsiBEEPTQ0GIAcgASAIQQFxckECcjYCACABIAZqIgEgBEEDcjYCBCAFIAUoAgRBAXI2AgQgASAEEBwMBgtB4JnAACgCACAEaiIEIAFLDQQMBgsgAyABIAEgA0sbIgMEQCACIAAgA/wKAAALIAcoAgAiA0F4cSIHIAFBBEEIIANBA3EiAxtqSQ0CIANFIAYgB09yDQZB/I/AAEGskMAAEFMAC0G8j8AAQeyPwAAQUwALQfyPwABBrJDAABBTAAtBvI/AAEHsj8AAEFMACyAHIAEgCEEBcXJBAnI2AgAgASAGaiIFIAQgAWsiAUEBcjYCBEHgmcAAIAE2AgBB6JnAACAFNgIACyAGRQ0AIAAMAwsgAxARIgFFDQEgA0F8QXggBygCACICQQNxGyACQXhxaiICIAIgA0sbIgIEQCABIAAgAvwKAAALIAEhAgsgABAVCyACCwsTACAAQbyQwAA2AgQgACABNgIACxAAIAEgACgCACAAKAIEEFYLEAAgASAAKAIAIAAoAgQQFwsOACAAJQEgASUBIAIQBwtbAQJ/AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMAgtBvI/AAEHsj8AAEFMAC0H8j8AAQayQwAAQUwALCx0BAW8gACgCACUBIAEgAhANIQMQGSIAIAMmASAACw8AIABBzI7AACABIAIQGAsPACAAQYyRwAAgASACEBgLGQACfyABQQlPBEAgASAAEB4MAQsgABARCwsJACAAIAEQDwALDAAgACABKQIANwMACz0BAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQQhqIgAoAgAgACgCBEGolsAAKAIAIgBBEyAAGxEBAAALDQAgAUGcksAAQQUQVgsNACABQb+UwABBGBAXC4ACAQN/IAAoAgAhACMAQRBrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASABQQFBACAAKAIAIANBBmoiABAaIgEgAGpBCiABaxAUDAILIAAoAgAhAkEAIQADQCAAIANqQQ1qIAJBD3EtAKGSQDoAACAAQQFrIQAgAkEPSyACQQR2IQINAAsgAUGtlMAAQQIgACADakEOakEAIABrEBQMAQsgACgCACECQQAhAANAIAAgA2pBDWogAkEPcS0Ar5RAOgAAIABBAWshACACQQ9LIAJBBHYhAg0ACyABQa2UwABBAiAAIANqQQ5qQQAgAGsQFAsgA0EQaiQACwwAQYCawABBAToAAAsJACAAQQA2AgALCAAgACUBEAELCAAgACUBEAULC4kVAwBBgIDAAAuhEUF0dGVtcHRlZCB0byBpbml0aWFsaXplIHRocmVhZC1sb2NhbCB3aGlsZSBpdCBpcyBiZWluZyBkcm9wcGVkCUV4cGVjdGVkIMAXIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCDAABZzbGljZSBpbmRleCBzdGFydHMgYXQgwA0gYnV0IGVuZHMgYXQgwAAgaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyDAEiBidXQgdGhlIGluZGV4IGlzIMAAEnJhbmdlIHN0YXJ0IGluZGV4IMAiIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIMAAEHJhbmdlIGVuZCBpbmRleCDAIiBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCDAABBhc3NlcnRpb24gYGxlZnQgwBcgcmlnaHRgIGZhaWxlZAogIGxlZnQ6IMAJCiByaWdodDogwAAQYXNzZXJ0aW9uIGBsZWZ0IMAQIHJpZ2h0YCBmYWlsZWQ6IMAJCiAgbGVmdDogwAkKIHJpZ2h0OiDAAEhjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiDAAMACOiDAAHNwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAvVXNlcnMvYWFkaWtoYW5uYS8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3RocmVhZF9sb2NhbC9ub190aHJlYWRzLnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvY29yZS9zcmMvZm10L251bS5ycwAvVXNlcnMvYWFkaWtoYW5uYS8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL2xvY2FsLnJzAC9ydXN0Yy8yODUwY2E4Mjk1YmMyNTMxODZiMjkxMzE0ZGRjMjM5NjMyNzU1NDc1L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjExL3NyYy9kbG1hbGxvYy5ycwBzcGFyay1pbnRlcm5hbC1ycy9zcmMvbGliLnJzAC9Vc2Vycy9hYWRpa2hhbm5hLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9Vc2Vycy9hYWRpa2hhbm5hLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAfQIQAIUAAABrAAAADQAAAAEAAAACAAAAAwAAAPUBEAAgAAAAhQAAACAAAAD1ARAAIAAAAH4AAAAcAAAA9QEQACAAAACAAAAAHAAAAE8DEAB2AAAA3wEAABkAAABPAxAAdgAAAPUCAAAmAAAAQgQQABwAAAAoAAAALQAAAEIEEAAcAAAAHQAAADMAAABCBBAAHAAAAEUAAAAtAAAAQgQQABwAAAA6AAAAMwAAAEIEEAAcAAAAXgAAACgAAAAWAhAAHQAAACQAAAAUAAAAFgIQAB0AAAAzAAAAHQAAABYCEAAdAAAAMwAAABUAAAAWAhAAHQAAABsAAAAdAAAAFgIQAB0AAAB8AAAAGAAAABYCEAAdAAAAfQAAABgAAAAWAhAAHQAAAJAAAAAgAAAAFgIQAB0AAACQAAAAFAAAABYCEAAdAAAAnwAAABMAAAAWAhAAHQAAAKIAAAAdAAAAFgIQAB0AAACiAAAAEQAAABYCEAAdAAAApwAAABMAAAAWAhAAHQAAAHQAAAAZAAAAXwQQAF8AAAD7GAAAAQAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkcmVlbnRyYW50IGluaXS/BBAAYgAAAHoCAAANAAAATGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAC/BBAAYgAAAAgDAAAZAAAAFQAAAAwAAAAEAAAAFgAAABcAAAAYAAAAAAAAAAgAAAAEAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAQAAAABAAAAB4AAAAfAAAAIAAAACEAAABtXcvWLFDrY3hBpldxG4u5ow9nhBrchVEDQO3/txrs6mFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQAABcEEAAqAAAAsQQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAAAXBBAAKgAAALcEAAANAAAAAAAAAAgAAAAEAAAAIgAAAEFjY2Vzc0Vycm9yABUAAAAMAAAABAAAACMAAABjYXBhY2l0eSBvdmVyZmxvdwAAAMYDEABQAAAAHAAAAAUAAAAkAAAADAAAAAQAAAAlAAAAJgAAACcAQayRwAALzAMBAAAAKAAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90AAA0AhAASAAAAIoCAAAOAAAARXJyb3IwMTIzNDU2Nzg5YWJjZGVmAAAAAAAAAAQAAAAEAAAALQAAAH0AAAADAxAASwAAAFcCAAAFAAAAIH09PSE9bWF0Y2hlczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5MHgwMTIzNDU2Nzg5QUJDREVGUmVmQ2VsbCBhbHJlYWR5IGJvcnJvd2VkAFoJEABcCRAAXgkQAAIAAAACAAAABwAAAAAAAD8AAAC/AEGQlcAACwESAHgJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0YyUxLjk0LjAtbmlnaHRseSAoMjg1MGNhODI5IDIwMjYtMDEtMTMpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuBzAuMi4xMDAAaw90YXJnZXRfZmVhdHVyZXMGKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrC2J1bGstbWVtb3J5KwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var ch2 = {};\n  var wk = (function(c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n      c + \';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'\n    ], { type: "text/javascript" }))));\n    w.onmessage = function(e) {\n      var d = e.data, ed = d.$e$;\n      if (ed) {\n        var err2 = new Error(ed[0]);\n        err2["code"] = ed[1];\n        err2.stack = ed[2];\n        cb(err2, null);\n      } else\n        cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n  });\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = (function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  });\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var mrg = function(a, b) {\n    var o = {};\n    for (var k in a)\n      o[k] = a[k];\n    for (var k in b)\n      o[k] = b[k];\n    return o;\n  };\n  var wcln = function(fn, fnStr, td2) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");\n    for (var i2 = 0; i2 < dt.length; ++i2) {\n      var v = dt[i2], k = ks[i2];\n      if (typeof v == "function") {\n        fnStr += ";" + k + "=";\n        var st_1 = v.toString();\n        if (v.prototype) {\n          if (st_1.indexOf("[native code]") != -1) {\n            var spInd = st_1.indexOf(" ", 8) + 1;\n            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));\n          } else {\n            fnStr += st_1;\n            for (var t in v.prototype)\n              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();\n          }\n        } else\n          fnStr += st_1;\n      } else\n        td2[k] = v;\n    }\n    return fnStr;\n  };\n  var ch = [];\n  var cbfs = function(v) {\n    var tl = [];\n    for (var k in v) {\n      if (v[k].buffer) {\n        tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n      }\n    }\n    return tl;\n  };\n  var wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n      var fnStr = "", td_1 = {}, m = fns.length - 1;\n      for (var i2 = 0; i2 < m; ++i2)\n        fnStr = wcln(fns[i2], fnStr, td_1);\n      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td2 = mrg({}, ch[id].e);\n    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);\n  };\n  var bInflt = function() {\n    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];\n  };\n  var pbf = function(msg) {\n    return postMessage(msg, [msg.buffer]);\n  };\n  var gopt = function(o) {\n    return o && {\n      out: o.size && new u8(o.size),\n      dictionary: o.dictionary\n    };\n  };\n  var cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err2, dat2) {\n      w.terminate();\n      cb(err2, dat2);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function() {\n      w.terminate();\n    };\n  };\n  var b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n  };\n  var b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n  };\n  var b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n  };\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ (function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  })();\n  function inflate(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    return cbify(data, opts, [\n      bInflt\n    ], function(ev) {\n      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n  }\n  function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n  }\n  var Gunzip = /* @__PURE__ */ (function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  })();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  try {\n    td.decode(et, { stream: true });\n  } catch (e) {\n  }\n  var dutf8 = function(d) {\n    for (var r = "", i2 = 0; ; ) {\n      var c = d[i2++];\n      var eb = (c > 127) + (c > 223) + (c > 239);\n      if (i2 + eb > d.length)\n        return { s: r, r: slc(d, i2 - 1) };\n      if (!eb)\n        r += String.fromCharCode(c);\n      else if (eb == 3) {\n        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n      } else if (eb & 1)\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\n      else\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);\n    }\n  };\n  function strFromU8(dat, latin1) {\n    if (latin1) {\n      var r = "";\n      for (var i2 = 0; i2 < dat.length; i2 += 16384)\n        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));\n      return r;\n    } else if (td) {\n      return td.decode(dat);\n    } else {\n      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\n      if (r.length)\n        err(8);\n      return s;\n    }\n  }\n  var slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n  };\n  var zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n  };\n  var z64e = function(d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n      ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n  };\n  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {\n    fn();\n  };\n  function unzip(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    var term = [];\n    var tAll = function() {\n      for (var i3 = 0; i3 < term.length; ++i3)\n        term[i3]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n      mt(function() {\n        cb(a, b);\n      });\n    };\n    mt(function() {\n      cbd = cb;\n    });\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n    }\n    var lft = b2(data, e + 8);\n    if (lft) {\n      var c = lft;\n      var o = b4(data, e + 16);\n      var z = o == 4294967295 || c == 65535;\n      if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 101075792;\n        if (z) {\n          c = lft = b4(data, ze + 32);\n          o = b4(data, ze + 48);\n        }\n      }\n      var fltr = opts && opts.filter;\n      var _loop_3 = function(i3) {\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e2, d) {\n          if (e2) {\n            tAll();\n            cbd(e2, null);\n          } else {\n            if (d)\n              files[fn] = d;\n            if (!--lft)\n              cbd(null, files);\n          }\n        };\n        if (!fltr || fltr({\n          name: fn,\n          size: sc,\n          originalSize: su,\n          compression: c_1\n        })) {\n          if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n          else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (su < 524288 || sc > 0.8 * su) {\n              try {\n                cbl(null, inflateSync(infl, { out: new u8(su) }));\n              } catch (e2) {\n                cbl(e2, null);\n              }\n            } else\n              term.push(inflate(infl, { size: su }, cbl));\n          } else\n            cbl(err(14, "unknown compression type " + c_1, 1), null);\n        } else\n          cbl(null, null);\n      };\n      for (var i2 = 0; i2 < c; ++i2) {\n        _loop_3(i2);\n      }\n    } else\n      cbd(null, {});\n    return tAll;\n  }\n  function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558)\n        err(13);\n    }\n    var c = b2(data, e + 8);\n    if (!c)\n      return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n      var ze = b4(data, e - 12);\n      z = b4(data, ze) == 101075792;\n      if (z) {\n        c = b4(data, ze + 32);\n        o = b4(data, ze + 48);\n      }\n    }\n    var fltr = opts && opts.filter;\n    for (var i2 = 0; i2 < c; ++i2) {\n      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n      o = no;\n      if (!fltr || fltr({\n        name: fn,\n        size: sc,\n        originalSize: su,\n        compression: c_2\n      })) {\n        if (!c_2)\n          files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n        else\n          err(14, "unknown compression type " + c_2);\n      }\n    }\n    return files;\n  }\n  /**\n   * @license\n   * Copyright 2010-2025 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "182";\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  const _cache = {};\n  function warn(...params) {\n    const message = "THREE." + params.shift();\n    {\n      console.warn(message, ...params);\n    }\n  }\n  function warnOnce(...params) {\n    const message = params.join(" ");\n    if (message in _cache) return;\n    _cache[message] = true;\n    warn(...params);\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  class Quaternion {\n    /**\n     * Constructs a new quaternion.\n     *\n     * @param {number} [x=0] - The x value of this quaternion.\n     * @param {number} [y=0] - The y value of this quaternion.\n     * @param {number} [z=0] - The z value of this quaternion.\n     * @param {number} [w=1] - The w value of this quaternion.\n     */\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    /**\n     * Interpolates between two quaternions via SLERP. This implementation assumes the\n     * quaternion data are managed in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @param {number} t - The interpolation factor in the range `[0,1]`.\n     * @see {@link Quaternion#slerp}\n     */\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      let x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t <= 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t >= 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let dot = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;\n        if (dot < 0) {\n          x1 = -x1;\n          y1 = -y1;\n          z1 = -z1;\n          w1 = -w1;\n          dot = -dot;\n        }\n        let s = 1 - t;\n        if (dot < 0.9995) {\n          const theta = Math.acos(dot);\n          const sin = Math.sin(theta);\n          s = Math.sin(s * theta) / sin;\n          t = Math.sin(t * theta) / sin;\n          x0 = x0 * s + x1 * t;\n          y0 = y0 * s + y1 * t;\n          z0 = z0 * s + z1 * t;\n          w0 = w0 * s + w1 * t;\n        } else {\n          x0 = x0 * s + x1 * t;\n          y0 = y0 * s + y1 * t;\n          z0 = z0 * s + z1 * t;\n          w0 = w0 * s + w1 * t;\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    /**\n     * Multiplies two quaternions. This implementation assumes the quaternion data are managed\n     * in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @return {Array<number>} The destination array.\n     * @see {@link Quaternion#multiplyQuaternions}.\n     */\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    /**\n     * The x value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The y value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The z value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The w value of this quaternion.\n     *\n     * @type {number}\n     * @default 1\n     */\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    /**\n     * Sets the quaternion components.\n     *\n     * @param {number} x - The x value of this quaternion.\n     * @param {number} y - The y value of this quaternion.\n     * @param {number} z - The z value of this quaternion.\n     * @param {number} w - The w value of this quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Returns a new quaternion with copied values from this instance.\n     *\n     * @return {Quaternion} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    /**\n     * Copies the values of the given quaternion to this instance.\n     *\n     * @param {Quaternion} quaternion - The quaternion to copy.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the rotation specified by the given\n     * Euler angles.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given axis and angle.\n     *\n     * @param {Vector3} axis - The normalized axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given rotation matrix.\n     *\n     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion to the rotation required to rotate the direction vector\n     * `vFrom` to the direction vector `vTo`.\n     *\n     * @param {Vector3} vFrom - The first (normalized) direction vector.\n     * @param {Vector3} vTo - The second (normalized) direction vector.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < 1e-8) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    /**\n     * Returns the angle between this quaternion and the given one in radians.\n     *\n     * @param {Quaternion} q - The quaternion to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    /**\n     * Rotates this quaternion by a given angular step to the given quaternion.\n     * The method ensures that the final quaternion will not overshoot `q`.\n     *\n     * @param {Quaternion} q - The target quaternion.\n     * @param {number} step - The angular step in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    /**\n     * Sets this quaternion to the identity quaternion; that is, to the\n     * quaternion that represents "no rotation".\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    /**\n     * Inverts this quaternion via {@link Quaternion#conjugate}. The\n     * quaternion is assumed to have unit length.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    invert() {\n      return this.conjugate();\n    }\n    /**\n     * Returns the rotational conjugate of this quaternion. The conjugate of a\n     * quaternion represents the same rotation in the opposite direction about\n     * the rotational axis.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Calculates the dot product of this quaternion and the given one.\n     *\n     * @param {Quaternion} v - The quaternion to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    /**\n     * Computes the squared Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector. This can be useful if you are comparing the\n     * lengths of two quaternions, as this is a slightly more efficient calculation than\n     * {@link Quaternion#length}.\n     *\n     * @return {number} The squared Euclidean length.\n     */\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    /**\n     * Computes the Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector.\n     *\n     * @return {number} The Euclidean length.\n     */\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    /**\n     * Normalizes this quaternion - that is, calculated the quaternion that performs\n     * the same rotation as this one, but has a length equal to `1`.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    /**\n     * Pre-multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    /**\n     * Multiplies the given quaternions and stores the result in this instance.\n     *\n     * @param {Quaternion} a - The first quaternion.\n     * @param {Quaternion} b - The second quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between quaternions.\n     *\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerp(qb, t) {\n      if (t <= 0) return this;\n      if (t >= 1) return this.copy(qb);\n      let x2 = qb._x, y = qb._y, z = qb._z, w = qb._w;\n      let dot = this.dot(qb);\n      if (dot < 0) {\n        x2 = -x2;\n        y = -y;\n        z = -z;\n        w = -w;\n        dot = -dot;\n      }\n      let s = 1 - t;\n      if (dot < 0.9995) {\n        const theta = Math.acos(dot);\n        const sin = Math.sin(theta);\n        s = Math.sin(s * theta) / sin;\n        t = Math.sin(t * theta) / sin;\n        this._x = this._x * s + x2 * t;\n        this._y = this._y * s + y * t;\n        this._z = this._z * s + z * t;\n        this._w = this._w * s + w * t;\n        this._onChangeCallback();\n      } else {\n        this._x = this._x * s + x2 * t;\n        this._y = this._y * s + y * t;\n        this._z = this._z * s + z * t;\n        this._w = this._w * s + w * t;\n        this.normalize();\n      }\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between the given quaternions\n     * and stores the result in this quaternion.\n     *\n     * @param {Quaternion} qa - The source quaternion.\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    /**\n     * Sets this quaternion to a uniformly random, normalized quaternion.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    /**\n     * Returns `true` if this quaternion is equal with the given one.\n     *\n     * @param {Quaternion} quaternion - The quaternion to test for equality.\n     * @return {boolean} Whether this quaternion is equal with the given one.\n     */\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    /**\n     * Sets this quaternion\'s components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the quaternion component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Writes the components of this quaternion to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the quaternion components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The quaternion components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    /**\n     * Sets the components of this quaternion from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.\n     * @param {number} index - The index into the attribute.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the\n     * numerical elements of this quaternion in an array of format `[x, y, z, w]`.\n     *\n     * @return {Array<number>} The serialized quaternion.\n     */\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    /**\n     * Constructs a new 3D vector.\n     *\n     * @param {number} [x=0] - The x value of this vector.\n     * @param {number} [y=0] - The y value of this vector.\n     * @param {number} [z=0] - The z value of this vector.\n     */\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    /**\n     * Sets the vector components.\n     *\n     * @param {number} x - The value of the x component.\n     * @param {number} y - The value of the y component.\n     * @param {number} z - The value of the z component.\n     * @return {Vector3} A reference to this vector.\n     */\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\n     * Sets the vector components to the same value.\n     *\n     * @param {number} scalar - The value to set for all vector components.\n     * @return {Vector3} A reference to this vector.\n     */\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    /**\n     * Sets the vector\'s x component to the given value\n     *\n     * @param {number} x - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    /**\n     * Sets the vector\'s y component to the given value\n     *\n     * @param {number} y - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    /**\n     * Sets the vector\'s z component to the given value\n     *\n     * @param {number} z - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    /**\n     * Allows to set a vector component with an index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @param {number} value - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    /**\n     * Returns the value of the vector component which matches the given index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @return {number} A vector component value.\n     */\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    /**\n     * Returns a new vector with copied values from this instance.\n     *\n     * @return {Vector3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    /**\n     * Copies the values of the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to copy.\n     * @return {Vector3} A reference to this vector.\n     */\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    /**\n     * Adds the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to all components of this instance.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    /**\n     * Adds the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    /**\n     * Adds the given vector scaled by the given factor to this instance.\n     *\n     * @param {Vector3|Vector4} v - The vector.\n     * @param {number} s - The factor that scales `v`.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    /**\n     * Subtracts the given vector from this instance.\n     *\n     * @param {Vector3} v - The vector to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    /**\n     * Subtracts the given scalar value from all components of this instance.\n     *\n     * @param {number} s - The scalar to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    /**\n     * Subtracts the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    /**\n     * Multiplies the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with all components of this instance.\n     *\n     * @param {number} scalar - The scalar to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    /**\n     * Multiplies the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    /**\n     * Applies the given Euler rotation to this vector.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    /**\n     * Applies a rotation specified by an axis and an angle to this vector.\n     *\n     * @param {Vector3} axis - A normalized vector representing the rotation axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    /**\n     * Multiplies this vector with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    /**\n     * Multiplies this vector by the given normal matrix and normalizes\n     * the result.\n     *\n     * @param {Matrix3} m - The normal matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and\n     * divides by perspective.\n     *\n     * @param {Matrix4} m - The matrix to apply.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    /**\n     * Applies the given Quaternion to this vector.\n     *\n     * @param {Quaternion} q - The Quaternion.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    /**\n     * Projects this vector from world space into the camera\'s normalized\n     * device coordinate (NDC) space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    /**\n     * Unprojects this vector from the camera\'s normalized device coordinate (NDC)\n     * space into world space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    /**\n     * Transforms the direction of this vector by a matrix (the upper left 3 x 3\n     * subset of the given 4x4 matrix and then normalizes the result.\n     *\n     * @param {Matrix4} m - The matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    /**\n     * Divides this instance by the given vector.\n     *\n     * @param {Vector3} v - The vector to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    /**\n     * Divides this vector by the given scalar.\n     *\n     * @param {number} scalar - The scalar to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the given vector\'s x, y or z\n     * value, replace that value with the corresponding min value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is less than the given vector\'s x, y or z\n     * value, replace that value with the corresponding max value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the max vector\'s x, y or z\n     * value, it is replaced by the corresponding value.\n     * If this vector\'s x, y or z value is less than the min vector\'s x, y or z value,\n     * it is replaced by the corresponding value.\n     *\n     * @param {Vector3} min - The minimum x, y and z values.\n     * @param {Vector3} max - The maximum x, y and z values in the desired range.\n     * @return {Vector3} A reference to this vector.\n     */\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z values are greater than the max value, they are\n     * replaced by the max value.\n     * If this vector\'s x, y or z values are less than the min value, they are\n     * replaced by the min value.\n     *\n     * @param {number} minVal - The minimum value the components will be clamped to.\n     * @param {number} maxVal - The maximum value the components will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    /**\n     * If this vector\'s length is greater than the max value, it is replaced by\n     * the max value.\n     * If this vector\'s length is less than the min value, it is replaced by the\n     * min value.\n     *\n     * @param {number} min - The minimum value the vector length will be clamped to.\n     * @param {number} max - The maximum value the vector length will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    /**\n     * The components of this vector are rounded down to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded up to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded to the nearest integer value\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded towards zero (up if negative,\n     * down if positive) to an integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    /**\n     * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    /**\n     * Calculates the dot product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    /**\n     * Computes the square of the Euclidean length (straight-line length) from\n     * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should\n     * compare the length squared instead as it is slightly more efficient to calculate.\n     *\n     * @return {number} The square length of this vector.\n     */\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).\n     *\n     * @return {number} The length of this vector.\n     */\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Computes the Manhattan length of this vector.\n     *\n     * @return {number} The length of this vector.\n     */\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    /**\n     * Converts this vector to a unit vector - that is, sets it equal to a vector\n     * with the same direction as this one, but with a vector length of `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\n     * Sets this vector to a vector with the same direction as this one, but\n     * with the specified length.\n     *\n     * @param {number} length - The new length of this vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    /**\n     * Linearly interpolates between the given vector and this instance, where\n     * alpha is the percent distance along the line - alpha = 0 will be this\n     * vector, and alpha = 1 will be the given one.\n     *\n     * @param {Vector3} v - The vector to interpolate towards.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given vectors, where alpha is the percent\n     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n     * be the second one. The result is stored in this instance.\n     *\n     * @param {Vector3} v1 - The first vector.\n     * @param {Vector3} v2 - The second vector.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    /**\n     * Calculates the cross product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the cross product with.\n     * @return {Vector3} The result of the cross product.\n     */\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    /**\n     * Calculates the cross product of the given vectors and stores the result\n     * in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    /**\n     * Projects this vector onto the given one.\n     *\n     * @param {Vector3} v - The vector to project to.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    /**\n     * Projects this vector onto a plane by subtracting this\n     * vector projected onto the plane\'s normal from this vector.\n     *\n     * @param {Vector3} planeNormal - The plane normal.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    /**\n     * Reflects this vector off a plane orthogonal to the given normal vector.\n     *\n     * @param {Vector3} normal - The (normalized) normal vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    /**\n     * Returns the angle between the given vector and this instance in radians.\n     *\n     * @param {Vector3} v - The vector to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    /**\n     * Computes the distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the distance to.\n     * @return {number} The distance.\n     */\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    /**\n     * Computes the squared distance from the given vector to this instance.\n     * If you are just comparing the distance with another distance, you should compare\n     * the distance squared instead as it is slightly more efficient to calculate.\n     *\n     * @param {Vector3} v - The vector to compute the squared distance to.\n     * @return {number} The squared distance.\n     */\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the Manhattan distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the Manhattan distance to.\n     * @return {number} The Manhattan distance.\n     */\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {Spherical} s - The spherical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} phi - The phi angle in radians.\n     * @param {number} theta - The theta angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {Cylindrical} c - The cylindrical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} theta - The theta angle in radians.\n     * @param {number} y - The y value.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components to the position elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    /**\n     * Sets the vector components to the scale elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    /**\n     * Sets the vector components from the given Euler angles.\n     *\n     * @param {Euler} e - The Euler angles to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    /**\n     * Sets the vector components from the RGB components of the\n     * given color.\n     *\n     * @param {Color} c - The color to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    /**\n     * Returns `true` if this vector is equal with the given one.\n     *\n     * @param {Vector3} v - The vector to test for equality.\n     * @return {boolean} Whether this vector is equal with the given one.\n     */\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    /**\n     * Sets this vector\'s x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\n     * and z value to be `array[ offset + 2 ]`.\n     *\n     * @param {Array<number>} array - An array holding the vector component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the components of this vector to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the vector components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The vector components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    /**\n     * Sets the components of this vector from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n     * @param {number} index - The index into the attribute.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * Sets each component of this vector to a pseudo-random value between `0` and\n     * `1`, excluding `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    /**\n     * Sets this vector to a uniformly random point on a unit sphere.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Matrix3 {\n    /**\n     * Constructs a new 3x3 matrix. The arguments are supposed to be\n     * in row-major order. If no arguments are provided, the constructor\n     * initializes the matrix as an identity matrix.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     */\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    /**\n     * Sets the elements of the matrix.The arguments are supposed to be\n     * in row-major order.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    /**\n     * Sets this matrix to the 3x3 identity matrix.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Copies the values of the given matrix to this instance.\n     *\n     * @param {Matrix3} m - The matrix to copy.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    /**\n     * Extracts the basis of this matrix into the three axis vectors provided.\n     *\n     * @param {Vector3} xAxis - The basis\'s x axis.\n     * @param {Vector3} yAxis - The basis\'s y axis.\n     * @param {Vector3} zAxis - The basis\'s z axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    /**\n     * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    /**\n     * Post-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\n     * Pre-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\n     * Multiples the given 3x3 matrices and stores the result\n     * in this matrix.\n     *\n     * @param {Matrix3} a - The first matrix.\n     * @param {Matrix3} b - The second matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    /**\n     * Multiplies every component of the matrix by the given scalar.\n     *\n     * @param {number} s - The scalar.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    /**\n     * Computes and returns the determinant of this matrix.\n     *\n     * @return {number} The determinant.\n     */\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    /**\n     * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).\n     * You can not invert with a determinant of zero. If you attempt this, the method produces\n     * a zero matrix instead.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    /**\n     * Transposes this matrix in place.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    /**\n     * Computes the normal matrix which is the inverse transpose of the upper\n     * left 3x3 portion of the given 4x4 matrix.\n     *\n     * @param {Matrix4} matrix4 - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    /**\n     * Transposes this matrix into the supplied array, and returns itself unchanged.\n     *\n     * @param {Array<number>} r - An array to store the transposed matrix elements.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    /**\n     * Sets the UV transform matrix from offset, repeat, rotation, and center.\n     *\n     * @param {number} tx - Offset x.\n     * @param {number} ty - Offset y.\n     * @param {number} sx - Repeat x.\n     * @param {number} sy - Repeat y.\n     * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.\n     * @param {number} cx - Center x of rotation.\n     * @param {number} cy - Center y of rotation\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Scales this matrix with the given scalar values.\n     *\n     * @param {number} sx - The amount to scale in the X axis.\n     * @param {number} sy - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    /**\n     * Rotates this matrix by the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    /**\n     * Translates this matrix by the given scalar values.\n     *\n     * @param {number} tx - The amount to translate in the X axis.\n     * @param {number} ty - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    /**\n     * Sets this matrix as a 2D translation transform.\n     *\n     * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.\n     * @param {number} y - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D rotational transformation.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D scale transform.\n     *\n     * @param {number} x - The amount to scale in the X axis.\n     * @param {number} y - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Returns `true` if this matrix is equal with the given one.\n     *\n     * @param {Matrix3} matrix - The matrix to test for equality.\n     * @return {boolean} Whether this matrix is equal with the given one.\n     */\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    /**\n     * Sets the elements of the matrix from the given array.\n     *\n     * @param {Array<number>} array - The matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    /**\n     * Writes the elements of this matrix to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The matrix elements in column-major order.\n     */\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    /**\n     * Returns a matrix with copied values from this instance.\n     *\n     * @return {Matrix3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *	- whitePoint: reference white [ x y ]\n       *	- transfer: transfer function (pre-defined)\n       *	- toXYZ: Matrix3 RGB to XYZ transform\n       *	- fromXYZ: Matrix3 XYZ to RGB transform\n       *	- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: \'extended\' | \'standard\' }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      workingToColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      colorSpaceToWorking: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getToneMappingMode: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode || "standard";\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      },\n      // Deprecated\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");\n        return ColorManagement2.workingToColorSpace(color, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");\n        return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  class Box3 {\n    /**\n     * Constructs a new bounding box.\n     *\n     * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.\n     * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.\n     */\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    /**\n     * Sets the lower and upper boundaries of this box.\n     * Please note that this method only copies the values from the given objects.\n     *\n     * @param {Vector3} min - The lower boundary of the box.\n     * @param {Vector3} max - The upper boundary of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<number>} array - An array holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    /**\n     * Centers this box on the given center vector and sets this box\'s width, height and\n     * depth to the given size values.\n     *\n     * @param {Vector3} center - The center of the box.\n     * @param {Vector3} size - The x, y and z dimensions of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    /**\n     * Computes the world-axis-aligned bounding box for the given 3D object\n     * (including its children), accounting for the object\'s, and children\'s,\n     * world transforms. The function may result in a larger box than strictly necessary.\n     *\n     * @param {Object3D} object - The 3D object to compute the bounding box for.\n     * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest\n     * world-axis-aligned bounding box at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    /**\n     * Returns a new box with copied values from this instance.\n     *\n     * @return {Box3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given box to this instance.\n     *\n     * @param {Box3} box - The box to copy.\n     * @return {Box3} A reference to this bounding box.\n     */\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    /**\n     * Makes this box empty which means in encloses a zero space in 3D.\n     *\n     * @return {Box3} A reference to this bounding box.\n     */\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    /**\n     * Returns true if this box includes zero points within its bounds.\n     * Note that a box with equal lower and upper bounds still includes one\n     * point, the one both bounds share.\n     *\n     * @return {boolean} Whether this box is empty or not.\n     */\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    /**\n     * Returns the center point of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The center point.\n     */\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    /**\n     * Returns the dimensions of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The size.\n     */\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    /**\n     * Expands the boundaries of this box to include the given point.\n     *\n     * @param {Vector3} point - The point that should be included by the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    /**\n     * Expands this box equilaterally by the given vector. The width of this\n     * box will be expanded by the x component of the vector in both\n     * directions. The height of this box will be expanded by the y component of\n     * the vector in both directions. The depth of this box will be\n     * expanded by the z component of the vector in both directions.\n     *\n     * @param {Vector3} vector - The vector that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    /**\n     * Expands each dimension of the box by the given scalar. If negative, the\n     * dimensions of the box will be contracted.\n     *\n     * @param {number} scalar - The scalar value that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    /**\n     * Expands the boundaries of this box to include the given 3D object and\n     * its children, accounting for the object\'s, and children\'s, world\n     * transforms. The function may result in a larger box than strictly\n     * necessary (unless the precise parameter is set to true).\n     *\n     * @param {Object3D} object - The 3D object that should expand the bounding box.\n     * @param {boolean} precise - If set to `true`, the method expands the bounding box\n     * as little as necessary at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    /**\n     * Returns `true` if the given point lies within or on the boundaries of this box.\n     *\n     * @param {Vector3} point - The point to test.\n     * @return {boolean} Whether the bounding box contains the given point or not.\n     */\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if this bounding box includes the entirety of the given bounding box.\n     * If this box and the given one are identical, this function also returns `true`.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the bounding box contains the given bounding box or not.\n     */\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    /**\n     * Returns a point as a proportion of this box\'s width, height and depth.\n     *\n     * @param {Vector3} point - A point in 3D space.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} A point as a proportion of this box\'s width, height and depth.\n     */\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    /**\n     * Returns `true` if the given bounding box intersects with this bounding box.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the given bounding box intersects with this bounding box.\n     */\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if the given bounding sphere intersects with this bounding box.\n     *\n     * @param {Sphere} sphere - The bounding sphere to test.\n     * @return {boolean} Whether the given bounding sphere intersects with this bounding box.\n     */\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\n     * Returns `true` if the given plane intersects with this bounding box.\n     *\n     * @param {Plane} plane - The plane to test.\n     * @return {boolean} Whether the given plane intersects with this bounding box.\n     */\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    /**\n     * Returns `true` if the given triangle intersects with this bounding box.\n     *\n     * @param {Triangle} triangle - The triangle to test.\n     * @return {boolean} Whether the given triangle intersects with this bounding box.\n     */\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    /**\n     * Clamps the given point within the bounds of this box.\n     *\n     * @param {Vector3} point - The point to clamp.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The clamped point.\n     */\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    /**\n     * Returns the euclidean distance from any edge of this box to the specified point. If\n     * the given point lies inside of this box, the distance will be `0`.\n     *\n     * @param {Vector3} point - The point to compute the distance to.\n     * @return {number} The euclidean distance.\n     */\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    /**\n     * Returns a bounding sphere that encloses this bounding box.\n     *\n     * @param {Sphere} target - The target sphere that is used to store the method\'s result.\n     * @return {Sphere} The bounding sphere that encloses this bounding box.\n     */\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    /**\n     * Computes the intersection of this bounding box and the given one, setting the upper\n     * bound of this box to the lesser of the two boxes\' upper bounds and the\n     * lower bound of this box to the greater of the two boxes\' lower bounds. If\n     * there\'s no overlap, makes this box empty.\n     *\n     * @param {Box3} box - The bounding box to intersect with.\n     * @return {Box3} A reference to this bounding box.\n     */\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    /**\n     * Computes the union of this box and another and the given one, setting the upper\n     * bound of this box to the greater of the two boxes\' upper bounds and the\n     * lower bound of this box to the lesser of the two boxes\' lower bounds.\n     *\n     * @param {Box3} box - The bounding box that will be unioned with this instance.\n     * @return {Box3} A reference to this bounding box.\n     */\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    /**\n     * Transforms this bounding box by the given 4x4 transformation matrix.\n     *\n     * @param {Matrix4} matrix - The transformation matrix.\n     * @return {Box3} A reference to this bounding box.\n     */\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    /**\n     * Adds the given offset to both the upper and lower bounds of this bounding box,\n     * effectively moving it in 3D space.\n     *\n     * @param {Vector3} offset - The offset that should be used to translate the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    /**\n     * Returns `true` if this bounding box is equal with the given one.\n     *\n     * @param {Box3} box - The box to test for equality.\n     * @return {boolean} Whether this bounding box is equal with the given one.\n     */\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @return {Object} Serialized structure with fields representing the object state.\n     */\n    toJSON() {\n      return {\n        min: this.min.toArray(),\n        max: this.max.toArray()\n      };\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @param {Object} json - The serialized json to set the box from.\n     * @return {Box3} A reference to this bounding box.\n     */\n    fromJSON(json) {\n      this.min.fromArray(json.min);\n      this.max.fromArray(json.max);\n      return this;\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    /**\n     * Constructs a new color.\n     *\n     * Note that standard method of specifying color in three.js is with a hexadecimal triplet,\n     * and that method is used throughout the rest of the documentation.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     */\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    /**\n     * Sets the colors\'s components from the given values.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     * @return {Color} A reference to this color.\n     */\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    /**\n     * Sets the colors\'s components to the given scalar value.\n     *\n     * @param {number} scalar - The scalar value.\n     * @return {Color} A reference to this color.\n     */\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    /**\n     * Sets this color from a hexadecimal value.\n     *\n     * @param {number} hex - The hexadecimal value.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} r - Red channel value between `0.0` and `1.0`.\n     * @param {number} g - Green channel value between `0.0` and `1.0`.\n     * @param {number} b - Blue channel value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,\n     * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\n     * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -\n     * all 140 color names are supported).\n     *\n     * @param {string} style - Color as a CSS-style string.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          warn("Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            warn("Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          warn("Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    /**\n     * Sets this color from a color name. Faster than {@link Color#setStyle} if\n     * you don\'t need the other CSS-style formats.\n     *\n     * For convenience, the list of names is exposed in `Color.NAMES` as a hash.\n     * ```js\n     * Color.NAMES.aliceblue // returns 0xF0F8FF\n     * ```\n     *\n     * @param {string} style - The color name.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        warn("Color: Unknown color " + style);\n      }\n      return this;\n    }\n    /**\n     * Returns a new color with copied values from this instance.\n     *\n     * @return {Color} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the values of the given color to this instance.\n     *\n     * @param {Color} color - The color to copy.\n     * @return {Color} A reference to this color.\n     */\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    /**\n     * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    /**\n     * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    /**\n     * Returns the hexadecimal value of this color.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {number} The hexadecimal value.\n     */\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    /**\n     * Returns the hexadecimal value of this color as a string (for example, \'FFFFFF\').\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The hexadecimal value as a string.\n     */\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    /**\n     * Converts the colors RGB values into the HSL format and stores them into the\n     * given target object.\n     *\n     * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {{h:number,s:number,l:number}} The HSL representation of this color.\n     */\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    /**\n     * Returns the RGB values of this color and stores them into the given target object.\n     *\n     * @param {Color} target - The target color that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} The RGB representation of this color.\n     */\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    /**\n     * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The CSS representation of this color.\n     */\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    /**\n     * Adds the given HSL values to this color\'s values.\n     * Internally, this converts the color\'s RGB values to HSL, adds HSL\n     * and then converts the color back to RGB.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @return {Color} A reference to this color.\n     */\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    /**\n     * Adds the RGB values of the given color to the RGB values of this color.\n     *\n     * @param {Color} color - The color to add.\n     * @return {Color} A reference to this color.\n     */\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    /**\n     * Adds the RGB values of the given colors and stores the result in this instance.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @return {Color} A reference to this color.\n     */\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to the RGB values of this color.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Color} A reference to this color.\n     */\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    /**\n     * Subtracts the RGB values of the given color from the RGB values of this color.\n     *\n     * @param {Color} color - The color to subtract.\n     * @return {Color} A reference to this color.\n     */\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    /**\n     * Multiplies the RGB values of the given color with the RGB values of this color.\n     *\n     * @param {Color} color - The color to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with the RGB values of this color.\n     *\n     * @param {number} s - The scalar to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s RGB values toward the RGB values of the\n     * given color. The alpha argument can be thought of as the ratio between\n     * the two colors, where `0.0` is this color and `1.0` is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given colors and stores the result in this instance.\n     * The alpha argument can be thought of as the ratio between the two colors, where `0.0`\n     * is the first and `1.0` is the second color.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s HSL values toward the HSL values of the\n     * given color. It differs from {@link Color#lerp} by not interpolating straight\n     * from one color to the other, but instead going through all the hues in between\n     * those two colors. The alpha argument can be thought of as the ratio between\n     * the two colors, where 0.0 is this color and 1.0 is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    /**\n     * Sets the color\'s RGB components from the given 3D vector.\n     *\n     * @param {Vector3} v - The vector to set.\n     * @return {Color} A reference to this color.\n     */\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    /**\n     * Transforms this color with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix.\n     * @return {Color} A reference to this color.\n     */\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    /**\n     * Returns `true` if this color is equal with the given one.\n     *\n     * @param {Color} c - The color to test for equality.\n     * @return {boolean} Whether this bounding color is equal with the given one.\n     */\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    /**\n     * Sets this color\'s RGB components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the RGB values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Color} A reference to this color.\n     */\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the RGB components of this color to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the color components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The color components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    /**\n     * Sets the components of this color from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding color data.\n     * @param {number} index - The index into the attribute.\n     * @return {Color} A reference to this color.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the color\n     * as a hexadecimal value.\n     *\n     * @return {number} The hexadecimal value.\n     */\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -12;\n  const LN_SCALE_MAX = 9;\n  const LN_SCALE_ZERO = -30;\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  const supportsFloat16Array = "Float16Array" in globalThis;\n  const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;\n  const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\n  function normalize(vec) {\n    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));\n    return vec.map((v) => v / norm);\n  }\n  const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\n  const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;\n  function toHalfNative(f) {\n    f16buffer[0] = f;\n    return u16buffer[0];\n  }\n  function toHalfJS(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalfNative(u) {\n    u16buffer[0] = u;\n    return f16buffer[0];\n  }\n  function fromHalfJS(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  const tempQuaternion = new Quaternion();\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8(a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  new Vector3();\n  new Vector3();\n  new Color();\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  const tempNormalizedQuaternion = new Quaternion();\n  const tempAxis = new Vector3();\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = tempNormalizedQuaternion.copy(q).normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function packSint8Bytes(b0, b1, b22, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\n    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\n    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\n    const sh1Mid = 0.5 * (sh1Min + sh1Max);\n    const sh1Scale = 126 / (sh1Max - sh1Min);\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\n      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\n    const sh2Scale = 2 / (sh2Max - sh2Min);\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      (sh2Rgb[0] - sh2Mid) * sh2Scale,\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\n      (sh2Rgb[2] - sh2Mid) * sh2Scale,\n      (sh2Rgb[3] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      (sh2Rgb[4] - sh2Mid) * sh2Scale,\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\n      (sh2Rgb[6] - sh2Mid) * sh2Scale,\n      (sh2Rgb[7] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      (sh2Rgb[8] - sh2Mid) * sh2Scale,\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\n      (sh2Rgb[10] - sh2Mid) * sh2Scale,\n      (sh2Rgb[11] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      (sh2Rgb[12] - sh2Mid) * sh2Scale,\n      (sh2Rgb[13] - sh2Mid) * sh2Scale,\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n    const sh3Mid = 0.5 * (sh3Min + sh3Max);\n    const sh3Scale = 62 / (sh3Max - sh3Min);\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\n      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.chunks = [];\n      this.totalBytes = 0;\n      const ds = new DecompressionStream("gzip");\n      const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);\n      this.reader = decompressionStream.getReader();\n    }\n    async read(numBytes) {\n      while (this.totalBytes < numBytes) {\n        const { value: chunk, done: readerDone } = await this.reader.read();\n        if (readerDone) {\n          break;\n        }\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes, splatEncoding) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes, splatEncoding) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const PLY_PROPERTY_TYPES = [\n    "char",\n    "uchar",\n    "short",\n    "ushort",\n    "int",\n    "uint",\n    "float",\n    "double"\n  ];\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = createEmptyItem(properties);\n        const parseFn = createParseFn(properties, this.littleEndian);\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          offset = parseFn(data, offset, item);\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        const sh = item.f_rest;\n        for (let i2 = 0; i2 < sh1Props.length; i2++) {\n          sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (let i2 = 0; i2 < sh2Props.length; i2++) {\n            sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (let i2 = 0; i2 < sh3Props.length; i2++) {\n            sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            const sh = item.f_rest;\n            if (sh1) {\n              for (let i2 = 0; i2 < sh1Props.length; i2++) {\n                sh1[i2] = sh[sh1Props[i2]];\n              }\n            }\n            if (sh2) {\n              for (let i2 = 0; i2 < sh2Props.length; i2++) {\n                sh2[i2] = sh[sh2Props[i2]];\n              }\n            }\n            if (sh3) {\n              for (let i2 = 0; i2 < sh3Props.length; i2++) {\n                sh3[i2] = sh[sh3Props[i2]];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\n  function createEmptyItem(properties) {\n    const item = {};\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (F_REST_REGEX.test(propertyName)) {\n        item.f_rest = new Array(getNumSh(properties));\n      } else {\n        item[propertyName] = property.isList ? [] : 0;\n      }\n    }\n    return item;\n  }\n  function createParseFn(properties, littleEndian) {\n    if (safeToCompile(properties)) {\n      return createCompiledParserFn(properties, littleEndian);\n    }\n    return createDynamicParserFn(properties, littleEndian);\n  }\n  const UNSAFE_EVAL_ALLOWED = (() => {\n    try {\n      new Function("return 42;");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  })();\n  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\n  function safeToCompile(properties) {\n    if (!UNSAFE_EVAL_ALLOWED) {\n      return false;\n    }\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (!PROPERTY_NAME_REGEX.test(propertyName)) {\n        return false;\n      }\n      if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {\n        return false;\n      }\n      if (!PLY_PROPERTY_TYPES.includes(property.type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function createCompiledParserFn(properties, littleEndian) {\n    const parserSrc = ["let list;"];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parserSrc.push(\n          /*js*/\n          `\n        item.f_rest[${fRestIndex}] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else if (!property.isList) {\n        parserSrc.push(\n          /*js*/\n          `\n        item[\'${propertyName}\'] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else {\n        parserSrc.push(\n          /*js*/\n          `\n        list = item[\'${propertyName}\'];\n        list.length = PARSE_FIELD[\'${property.countType}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.countType]};\n        for (let i = 0; i < list.length; i++) {\n          list[i] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n          offset += ${FIELD_BYTES[property.type]};\n        }\n      `\n        );\n      }\n    }\n    parserSrc.push("return offset;");\n    const fn = new Function(\n      "data",\n      "offset",\n      "item",\n      "PARSE_FIELD",\n      parserSrc.join("\\n")\n    );\n    return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);\n  }\n  function createDynamicParserFn(properties, littleEndian) {\n    const parsers = [];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parsers.push(\n          (data, offset, item) => {\n            item.f_rest[fRestIndex] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else if (!property.isList) {\n        parsers.push(\n          (data, offset, item) => {\n            item[propertyName] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else {\n        parsers.push(\n          (data, offset, item) => {\n            const list = item[propertyName];\n            list.length = PARSE_FIELD[property.countType](\n              data,\n              offset,\n              littleEndian\n            );\n            let currentOffset = offset + FIELD_BYTES[property.countType];\n            for (let i2 = 0; i2 < list.length; i2++) {\n              list[i2] = PARSE_FIELD[property.type](\n                data,\n                currentOffset,\n                littleEndian\n              );\n              currentOffset += FIELD_BYTES[property.type];\n            }\n            return currentOffset;\n          }\n        );\n      }\n    }\n    return (data, offset, item) => {\n      let currentOffset = offset;\n      for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\n        currentOffset = parsers[parserIndex](data, currentOffset, item);\n      }\n      return currentOffset;\n    };\n  }\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    SplatFileType2["PCSOGSZIP"] = "pcsogszip";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    if (view.getUint32(0, true) === 67324752) {\n      if (tryPcSogsZip(fileBytes)) {\n        return "pcsogszip";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    if (extension === "sog") {\n      return "pcsogszip";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      const isVersion2 = json.version === 2;\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (isVersion2) {\n          if (!json[key].files) {\n            return void 0;\n          }\n          if ((key === "scales" || key === "sh0") && !json[key].codebook) {\n            return void 0;\n          }\n          if (key === "means" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        } else {\n          if (!json[key].shape || !json[key].files) {\n            return void 0;\n          }\n          if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  function tryPcSogsZip(input) {\n    try {\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n      let metaFilename = null;\n      const unzipped = unzipSync(fileBytes, {\n        filter: ({ name }) => {\n          const filename = name.split(/[\\\\/]/).pop();\n          if (filename === "meta.json") {\n            metaFilename = name;\n            return true;\n          }\n          return false;\n        }\n      });\n      if (!metaFilename) {\n        return void 0;\n      }\n      const json = tryPcSogs(unzipped[metaFilename]);\n      if (!json) {\n        return void 0;\n      }\n      return { name: metaFilename, json };\n    } catch {\n      return void 0;\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  async function unpackPcSogs(json, extraFiles, splatEncoding) {\n    const isVersion2 = "version" in json;\n    if (!isVersion2 && json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = isVersion2 ? json.count : json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const meansPromise = Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]).then((means) => {\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n        setPackedSplatCenter(packedArray, i2, x2, y, z);\n      }\n    });\n    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(\n      (scales) => {\n        let xLookup;\n        let yLookup;\n        let zLookup;\n        if (isVersion2) {\n          xLookup = yLookup = zLookup = json.scales.codebook.map((x2) => Math.exp(x2));\n        } else {\n          xLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          yLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          zLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatScales(\n            packedArray,\n            i2,\n            xLookup[scales[i4 + 0]],\n            yLookup[scales[i4 + 1]],\n            zLookup[scales[i4 + 2]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(\n      (quats) => {\n        const SQRT2 = Math.sqrt(2);\n        const lookup = new Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const r0 = lookup[quats[i4 + 0]];\n          const r1 = lookup[quats[i4 + 1]];\n          const r2 = lookup[quats[i4 + 2]];\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = quats[i4 + 3] - 252;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n    );\n    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\n      (sh0) => {\n        const SH_C02 = 0.28209479177387814;\n        let rLookup;\n        let gLookup;\n        let bLookup;\n        let aLookup;\n        if (isVersion2) {\n          rLookup = gLookup = bLookup = json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map((_, i2) => i2 / 255);\n        } else {\n          rLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          gLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          bLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)\n          ).map((x2) => 1 / (1 + Math.exp(-x2)));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatRgba(\n            packedArray,\n            i2,\n            rLookup[sh0[i4 + 0]],\n            gLookup[sh0[i4 + 1]],\n            bLookup[sh0[i4 + 2]],\n            aLookup[sh0[i4 + 3]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\n    if (json.shN) {\n      const useSH3 = isVersion2 ? json.shN.bands >= 3 : json.shN.shape[1] >= 48 - 3;\n      const useSH2 = isVersion2 ? json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;\n      const useSH1 = isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;\n      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\n      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);\n      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const shN = json.shN;\n      const shNPromise = Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]).then(([centroids, labels]) => {\n        const lookup = "codebook" in shN ? shN.codebook : new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 / 255));\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n          const col = (label & 63) * 15;\n          const row = label >>> 6;\n          const offset = row * centroids.width + col;\n          for (let d = 0; d < 3; ++d) {\n            if (useSH1) {\n              for (let k = 0; k < 3; ++k) {\n                sh1[k * 3 + d] = lookup[centroids.rgba[(offset + k) * 4 + d]];\n              }\n            }\n            if (useSH2) {\n              for (let k = 0; k < 5; ++k) {\n                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * 4 + d]];\n              }\n            }\n            if (useSH3) {\n              for (let k = 0; k < 7; ++k) {\n                sh3[k * 3 + d] = lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];\n              }\n            }\n          }\n          if (useSH1)\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          if (useSH2)\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          if (useSH3)\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n        }\n      });\n      promises.push(shNPromise);\n    }\n    await Promise.all(promises);\n    return { packedArray, numSplats, extra };\n  }\n  let offscreenGlContext = null;\n  async function decodeImage(fileBytes) {\n    if (!offscreenGlContext) {\n      const canvas = new OffscreenCanvas(1, 1);\n      offscreenGlContext = canvas.getContext("webgl2");\n      if (!offscreenGlContext) {\n        throw new Error("Failed to create WebGL2 context");\n      }\n    }\n    const imageBlob = new Blob([fileBytes]);\n    const bitmap = await createImageBitmap(imageBlob, {\n      premultiplyAlpha: "none"\n    });\n    const gl = offscreenGlContext;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\n    gl.readPixels(\n      0,\n      0,\n      bitmap.width,\n      bitmap.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      data\n    );\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(framebuffer);\n    return { rgba: data, width: bitmap.width, height: bitmap.height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  async function unpackPcSogsZip(fileBytes, splatEncoding) {\n    var _a2;\n    const nameJson = tryPcSogsZip(fileBytes);\n    if (!nameJson) {\n      throw new Error("Invalid PC SOGS zip file");\n    }\n    const { name, json } = nameJson;\n    const lastSlash = name.lastIndexOf("/");\n    const lastBackslash = name.lastIndexOf("\\\\");\n    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\n    const fileMap = /* @__PURE__ */ new Map();\n    const refFiles = [\n      ...json.means.files,\n      ...json.scales.files,\n      ...json.quats.files,\n      ...json.sh0.files,\n      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []\n    ];\n    for (const file of refFiles) {\n      fileMap.set(prefix + file, file);\n    }\n    const unzipped = await new Promise(\n      (resolve, reject) => {\n        unzip(\n          fileBytes,\n          {\n            filter: ({ name: name2 }) => {\n              return fileMap.has(name2);\n            }\n          },\n          (err2, files) => {\n            if (err2) {\n              reject(err2);\n            } else {\n              resolve(files);\n            }\n          }\n        );\n      }\n    );\n    const extraFiles = {};\n    for (const [full, name2] of fileMap.entries()) {\n      extraFiles[name2] = unzipped[full];\n    }\n    return await unpackPcSogs(json, extraFiles, splatEncoding);\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.version = -1;\n      this.numSplats = 0;\n      this.shDegree = 0;\n      this.fractionalBits = 0;\n      this.flags = 0;\n      this.flagAntiAlias = false;\n      this.reserved = 0;\n      this.headerParsed = false;\n      this.parsed = false;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n    }\n    async parseHeader() {\n      if (this.headerParsed) {\n        throw new Error("SPZ file header already parsed");\n      }\n      const header = new DataView((await this.reader.read(16)).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 3) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.headerParsed = true;\n      this.parsed = false;\n    }\n    async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (!this.headerParsed) {\n        throw new Error("SPZ file header must be parsed first");\n      }\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2 || this.version === 3) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = await this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = await this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      if (this.version === 3) {\n        const maxValue = 1 / Math.sqrt(2);\n        const quatBytes = await this.reader.read(this.numSplats * 4);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 4;\n          const quaternion = [0, 0, 0, 0];\n          const values = [\n            quatBytes[i3],\n            quatBytes[i3 + 1],\n            quatBytes[i3 + 2],\n            quatBytes[i3 + 3]\n          ];\n          const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\n          const valueMask = (1 << 9) - 1;\n          const largestIndex = combinedValues >>> 30;\n          let remainingValues = combinedValues;\n          let sumSquares = 0;\n          for (let i22 = 3; i22 >= 0; --i22) {\n            if (i22 !== largestIndex) {\n              const value = remainingValues & valueMask;\n              const sign = remainingValues >>> 9 & 1;\n              remainingValues = remainingValues >>> 10;\n              quaternion[i22] = maxValue * (value / valueMask);\n              quaternion[i22] = sign === 0 ? quaternion[i22] : -quaternion[i22];\n              sumSquares += quaternion[i22] * quaternion[i22];\n            }\n          }\n          const square = 1 - sumSquares;\n          quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));\n          quatCallback == null ? void 0 : quatCallback(\n            i2,\n            quaternion[0],\n            quaternion[1],\n            quaternion[2],\n            quaternion[3]\n          );\n        }\n      } else {\n        const quatBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = await this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 3;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + // Position\n      1 + // Opacity\n      3 + // Scale\n      3 + // DC-rgb\n      4 + // Rotation\n      (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, ...q) {\n      const base = 16 + this.numSplats * 16 + index * 4;\n      const quat = normalize(q);\n      let iLargest = 0;\n      for (let i2 = 1; i2 < 4; ++i2) {\n        if (Math.abs(quat[i2]) > Math.abs(quat[iLargest])) {\n          iLargest = i2;\n        }\n      }\n      const negate = quat[iLargest] < 0 ? 1 : 0;\n      let comp = iLargest;\n      for (let i2 = 0; i2 < 4; ++i2) {\n        if (i2 !== iLargest) {\n          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;\n          const mag = Math.floor(\n            ((1 << 9) - 1) * (Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5\n          );\n          comp = comp << 10 | negbit << 9 | mag;\n        }\n      }\n      this.view.setUint8(base, comp & 255);\n      this.view.setUint8(base + 1, comp >> 8 & 255);\n      this.view.setUint8(base + 2, comp >> 16 & 255);\n      this.view.setUint8(base + 3, comp >>> 24 & 255);\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          await spz2.parseHeader();\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes, splatEncoding } = args;\n          const decoded = await unpackPly({\n            packedArray,\n            fileBytes,\n            splatEncoding\n          });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackSpz(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackAntiSplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles, splatEncoding } = args;\n          const json = JSON.parse(\n            new TextDecoder().decode(fileBytes)\n          );\n          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogsZip": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "sort32Splats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort32_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n      console.error(error);\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes,\n    splatEncoding\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  async function unpackSpz(fileBytes, splatEncoding) {\n    const spz = new SpzReader({ fileBytes });\n    await spz.parseHeader();\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    await spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(\n          packedArray,\n          index,\n          scaleX,\n          scaleY,\n          scaleZ,\n          splatEncoding\n        );\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY_F16 = 31744;\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\n  let depthArray16 = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray16) {\n      depthArray16 = new Uint32Array(DEPTH_SIZE_16);\n    }\n    depthArray16.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE_16; ++j) {\n      const nextIndex = activeSplats + depthArray16[j];\n      depthArray16[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          ordering[depthArray16[pri]] = layerBase + i2;\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-CAKcdCJd.js.map\n';
const blob = typeof self !== "undefined" && self.Blob && new Blob([jsContent], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);
  }
}
class SplatWorker {
  constructor() {
    this.messages = {};
    this.messageIdNext = 0;
    this.worker = new WorkerWrapper();
    this.worker.onmessage = (event) => this.onMessage(event);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const id = this.makeMessageId();
    const promise = new Promise((resolve, reject) => {
      this.messages[id] = { resolve, reject };
    });
    return { id, promise };
  }
  onMessage(event) {
    const { id, result, error: error2 } = event.data;
    const handler = this.messages[id];
    if (handler) {
      delete this.messages[id];
      if (error2) {
        handler.reject(error2);
      } else {
        handler.resolve(result);
      }
    }
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(name, args) {
    const { id, promise } = this.makeMessagePromiseId();
    this.worker.postMessage(
      { name, args, id },
      { transfer: getArrayBuffers(args) }
    );
    return promise;
  }
}
let maxWorkers = 4;
let numWorkers = 0;
const freeWorkers = [];
const workerQueue = [];
async function allocWorker() {
  const worker = freeWorkers.shift();
  if (worker) {
    return worker;
  }
  if (numWorkers < maxWorkers) {
    const worker2 = new SplatWorker();
    numWorkers += 1;
    return worker2;
  }
  return new Promise((resolve) => {
    workerQueue.push(resolve);
  });
}
function freeWorker(worker) {
  if (numWorkers > maxWorkers) {
    numWorkers -= 1;
    return;
  }
  const waiter = workerQueue.shift();
  if (waiter) {
    waiter(worker);
    return;
  }
  freeWorkers.push(worker);
}
async function withWorker(callback) {
  const worker = await allocWorker();
  try {
    return await callback(worker);
  } finally {
    freeWorker(worker);
  }
}
class SplatLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.fileLoader = new FileLoader(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const resolvedURL = this.manager.resolveURL(
      (this.path ?? "") + (url ?? "")
    );
    const headers = new Headers(this.requestHeader);
    const credentials = this.withCredentials ? "include" : "same-origin";
    const request = new Request(resolvedURL, { headers, credentials });
    let fileType = this.fileType;
    this.manager.itemStart(resolvedURL);
    fetchWithProgress(request, onProgress).then(async (input) => {
      var _a2;
      const progresses = [
        new ProgressEvent("progress", {
          lengthComputable: true,
          loaded: input.byteLength,
          total: input.byteLength
        })
      ];
      function updateProgresses() {
        if (onProgress) {
          const lengthComputable = progresses.every((p) => {
            return p.lengthComputable || p.loaded === 0 && p.total === 0;
          });
          const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);
          const total = progresses.reduce((sum, p) => sum + p.total, 0);
          onProgress(
            new ProgressEvent("progress", {
              lengthComputable,
              loaded,
              total
            })
          );
        }
      }
      const extraFiles = {};
      const promises = [];
      const pcSogsJson = tryPcSogs(input);
      if (fileType === "pcsogs") {
        if (pcSogsJson === void 0) {
          throw new Error("Invalid PC SOGS file");
        }
      }
      if (pcSogsJson !== void 0) {
        fileType = "pcsogs";
        for (const key of ["means", "scales", "quats", "sh0", "shN"]) {
          const prop = pcSogsJson[key];
          if (prop) {
            for (const file of prop.files) {
              const fileUrl = new URL(file, resolvedURL).toString();
              const progressIndex = progresses.length;
              progresses.push(new ProgressEvent("progress"));
              this.manager.itemStart(fileUrl);
              const request2 = new Request(fileUrl, { headers, credentials });
              const promise = fetchWithProgress(request2, (progress) => {
                progresses[progressIndex] = progress;
                updateProgresses();
              }).then((data) => {
                extraFiles[file] = data;
              }).catch((error2) => {
                this.manager.itemError(fileUrl);
                throw error2;
              }).finally(() => {
                this.manager.itemEnd(fileUrl);
              });
              promises.push(promise);
            }
          }
        }
      }
      await Promise.all(promises);
      if (onLoad) {
        const splatEncoding = ((_a2 = this.packedSplats) == null ? void 0 : _a2.splatEncoding) ?? DEFAULT_SPLAT_ENCODING;
        const decoded = await unpackSplats({
          input,
          extraFiles,
          fileType,
          pathOrUrl: resolvedURL,
          splatEncoding
        });
        if (this.packedSplats) {
          this.packedSplats.initialize(decoded);
          onLoad(this.packedSplats);
        } else {
          onLoad(new PackedSplats(decoded));
        }
      }
    }).catch((error2) => {
      this.manager.itemError(resolvedURL);
      onError == null ? void 0 : onError(error2);
    }).finally(() => {
      this.manager.itemEnd(resolvedURL);
    });
  }
  async loadAsync(url, onProgress) {
    return new Promise((resolve, reject) => {
      this.load(
        url,
        (decoded) => {
          resolve(decoded);
        },
        onProgress,
        reject
      );
    });
  }
  parse(packedSplats) {
    return new SplatMesh({ packedSplats });
  }
}
async function fetchWithProgress(request, onProgress) {
  const response = await fetch(request);
  if (!response.ok) {
    throw new Error(
      `${response.status} "${response.statusText}" fetching URL: ${request.url}`
    );
  }
  if (!response.body) {
    throw new Error(`Response body is null for URL: ${request.url}`);
  }
  const reader = response.body.getReader();
  const contentLength = Number.parseInt(
    response.headers.get("Content-Length") || "0"
  );
  const total = Number.isNaN(contentLength) ? 0 : contentLength;
  let loaded = 0;
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    chunks.push(value);
    loaded += value.length;
    if (onProgress) {
      onProgress(
        new ProgressEvent("progress", {
          lengthComputable: total !== 0,
          loaded,
          total
        })
      );
    }
  }
  const bytes = new Uint8Array(loaded);
  let offset = 0;
  for (const chunk of chunks) {
    bytes.set(chunk, offset);
    offset += chunk.length;
  }
  return bytes.buffer;
}
var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {
  SplatFileType2["PLY"] = "ply";
  SplatFileType2["SPZ"] = "spz";
  SplatFileType2["SPLAT"] = "splat";
  SplatFileType2["KSPLAT"] = "ksplat";
  SplatFileType2["PCSOGS"] = "pcsogs";
  SplatFileType2["PCSOGSZIP"] = "pcsogszip";
  return SplatFileType2;
})(SplatFileType || {});
function getSplatFileType(fileBytes) {
  const view = new DataView(fileBytes.buffer);
  if ((view.getUint32(0, true) & 16777215) === 7957616) {
    return "ply";
  }
  if ((view.getUint32(0, true) & 16777215) === 559903) {
    const header = decompressPartialGzip(fileBytes, 4);
    const gView = new DataView(header.buffer);
    if (gView.getUint32(0, true) === 1347635022) {
      return "spz";
    }
    return void 0;
  }
  if (view.getUint32(0, true) === 67324752) {
    if (tryPcSogsZip(fileBytes)) {
      return "pcsogszip";
    }
    return void 0;
  }
  return void 0;
}
function getFileExtension(pathOrUrl) {
  const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];
  const lastSlash = Math.max(
    noTrailing.lastIndexOf("/"),
    noTrailing.lastIndexOf("\\")
  );
  const filename = noTrailing.slice(lastSlash + 1);
  const lastDot = filename.lastIndexOf(".");
  if (lastDot <= 0 || lastDot === filename.length - 1) {
    return "";
  }
  return filename.slice(lastDot + 1).toLowerCase();
}
function getSplatFileTypeFromPath(pathOrUrl) {
  const extension = getFileExtension(pathOrUrl);
  if (extension === "ply") {
    return "ply";
  }
  if (extension === "spz") {
    return "spz";
  }
  if (extension === "splat") {
    return "splat";
  }
  if (extension === "ksplat") {
    return "ksplat";
  }
  if (extension === "sog") {
    return "pcsogszip";
  }
  return void 0;
}
function isPcSogs(input) {
  return tryPcSogs(input) !== void 0;
}
function tryPcSogs(input) {
  try {
    let text;
    if (typeof input === "string") {
      text = input;
    } else {
      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
      if (fileBytes.length > 65536) {
        return void 0;
      }
      text = new TextDecoder().decode(fileBytes);
    }
    const json = JSON.parse(text);
    if (!json || typeof json !== "object" || Array.isArray(json)) {
      return void 0;
    }
    const isVersion2 = json.version === 2;
    for (const key of ["means", "scales", "quats", "sh0"]) {
      if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {
        return void 0;
      }
      if (isVersion2) {
        if (!json[key].files) {
          return void 0;
        }
        if ((key === "scales" || key === "sh0") && !json[key].codebook) {
          return void 0;
        }
        if (key === "means" && (!json[key].mins || !json[key].maxs)) {
          return void 0;
        }
      } else {
        if (!json[key].shape || !json[key].files) {
          return void 0;
        }
        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {
          return void 0;
        }
      }
    }
    return json;
  } catch {
    return void 0;
  }
}
function tryPcSogsZip(input) {
  try {
    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
    let metaFilename = null;
    const unzipped = unzipSync(fileBytes, {
      filter: ({ name }) => {
        const filename = name.split(/[\\/]/).pop();
        if (filename === "meta.json") {
          metaFilename = name;
          return true;
        }
        return false;
      }
    });
    if (!metaFilename) {
      return void 0;
    }
    const json = tryPcSogs(unzipped[metaFilename]);
    if (!json) {
      return void 0;
    }
    return { name: metaFilename, json };
  } catch {
    return void 0;
  }
}
async function unpackSplats({
  input,
  extraFiles,
  fileType,
  pathOrUrl,
  splatEncoding
}) {
  const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
  let splatFileType = fileType;
  if (!fileType) {
    splatFileType = getSplatFileType(fileBytes);
    if (!splatFileType && pathOrUrl) {
      splatFileType = getSplatFileTypeFromPath(pathOrUrl);
    }
  }
  switch (splatFileType) {
    case "ply": {
      const ply = new PlyReader({ fileBytes });
      await ply.parseHeader();
      const numSplats = ply.numSplats;
      const maxSplats = getTextureSize(numSplats).maxSplats;
      const args = {
        fileBytes,
        packedArray: new Uint32Array(maxSplats * 4),
        splatEncoding
      };
      return await withWorker(async (worker) => {
        const { packedArray, numSplats: numSplats2, extra } = await worker.call(
          "unpackPly",
          args
        );
        return { packedArray, numSplats: numSplats2, extra };
      });
    }
    case "spz": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodeSpz",
          {
            fileBytes,
            splatEncoding
          }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "splat": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats } = await worker.call(
          "decodeAntiSplat",
          {
            fileBytes,
            splatEncoding
          }
        );
        return { packedArray, numSplats };
      });
    }
    case "ksplat": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodeKsplat",
          { fileBytes, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "pcsogs": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodePcSogs",
          { fileBytes, extraFiles, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "pcsogszip": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodePcSogsZip",
          { fileBytes, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    default: {
      throw new Error(`Unknown splat file type: ${splatFileType}`);
    }
  }
}
class SplatData {
  constructor({ maxSplats = 1 } = {}) {
    this.numSplats = 0;
    this.maxSplats = getTextureSize(maxSplats).maxSplats;
    this.centers = new Float32Array(this.maxSplats * 3);
    this.scales = new Float32Array(this.maxSplats * 3);
    this.quaternions = new Float32Array(this.maxSplats * 4);
    this.opacities = new Float32Array(this.maxSplats);
    this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const index = this.numSplats;
    this.ensureIndex(index);
    this.numSplats += 1;
    return index;
  }
  unpushSplat(index) {
    if (index === this.numSplats - 1) {
      this.numSplats -= 1;
    } else {
      throw new Error("Cannot unpush splat from non-last position");
    }
  }
  ensureCapacity(numSplats) {
    if (numSplats > this.maxSplats) {
      const targetSplats = Math.max(numSplats, this.maxSplats * 2);
      const newCenters = new Float32Array(targetSplats * 3);
      const newScales = new Float32Array(targetSplats * 3);
      const newQuaternions = new Float32Array(targetSplats * 4);
      const newOpacities = new Float32Array(targetSplats);
      const newColors = new Float32Array(targetSplats * 3);
      newCenters.set(this.centers);
      newScales.set(this.scales);
      newQuaternions.set(this.quaternions);
      newOpacities.set(this.opacities);
      newColors.set(this.colors);
      this.centers = newCenters;
      this.scales = newScales;
      this.quaternions = newQuaternions;
      this.opacities = newOpacities;
      this.colors = newColors;
      if (this.sh1) {
        const newSh1 = new Float32Array(targetSplats * 9);
        newSh1.set(this.sh1);
        this.sh1 = newSh1;
      }
      if (this.sh2) {
        const newSh2 = new Float32Array(targetSplats * 15);
        newSh2.set(this.sh2);
        this.sh2 = newSh2;
      }
      if (this.sh3) {
        const newSh3 = new Float32Array(targetSplats * 21);
        newSh3.set(this.sh3);
        this.sh3 = newSh3;
      }
      this.maxSplats = targetSplats;
    }
  }
  ensureIndex(index) {
    this.ensureCapacity(index + 1);
  }
  setCenter(index, x, y, z) {
    this.centers[index * 3] = x;
    this.centers[index * 3 + 1] = y;
    this.centers[index * 3 + 2] = z;
  }
  setScale(index, scaleX, scaleY, scaleZ) {
    this.scales[index * 3] = scaleX;
    this.scales[index * 3 + 1] = scaleY;
    this.scales[index * 3 + 2] = scaleZ;
  }
  setQuaternion(index, x, y, z, w) {
    this.quaternions[index * 4] = x;
    this.quaternions[index * 4 + 1] = y;
    this.quaternions[index * 4 + 2] = z;
    this.quaternions[index * 4 + 3] = w;
  }
  setOpacity(index, opacity) {
    this.opacities[index] = opacity;
  }
  setColor(index, r, g, b) {
    this.colors[index * 3] = r;
    this.colors[index * 3 + 1] = g;
    this.colors[index * 3 + 2] = b;
  }
  setSh1(index, sh1) {
    if (!this.sh1) {
      this.sh1 = new Float32Array(this.maxSplats * 9);
    }
    for (let j = 0; j < 9; ++j) {
      this.sh1[index * 9 + j] = sh1[j];
    }
  }
  setSh2(index, sh2) {
    if (!this.sh2) {
      this.sh2 = new Float32Array(this.maxSplats * 15);
    }
    for (let j = 0; j < 15; ++j) {
      this.sh2[index * 15 + j] = sh2[j];
    }
  }
  setSh3(index, sh3) {
    if (!this.sh3) {
      this.sh3 = new Float32Array(this.maxSplats * 21);
    }
    for (let j = 0; j < 21; ++j) {
      this.sh3[index * 21 + j] = sh3[j];
    }
  }
}
const DEFAULT_SPLAT_ENCODING = {
  rgbMin: 0,
  rgbMax: 1,
  lnScaleMin: LN_SCALE_MIN,
  lnScaleMax: LN_SCALE_MAX,
  sh1Min: -1,
  sh1Max: 1,
  sh2Min: -1,
  sh2Max: 1,
  sh3Min: -1,
  sh3Max: 1
};
const _PackedSplats = class _PackedSplats {
  constructor(options = {}) {
    this.maxSplats = 0;
    this.numSplats = 0;
    this.packedArray = null;
    this.isInitialized = false;
    this.target = null;
    this.source = null;
    this.needsUpdate = true;
    this.extra = {};
    this.dyno = new DynoPackedSplats({ packedSplats: this });
    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({
      key: "rgbMinMaxLnScaleMinMax",
      value: new THREE.Vector4(0, 1, LN_SCALE_MIN, LN_SCALE_MAX),
      update: (value) => {
        var _a2, _b2, _c, _d;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,
          ((_c = this.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,
          ((_d = this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX
        );
        return value;
      }
    });
    this.dynoSh1MinMax = new DynoVec2({
      key: "sh1MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1
        );
        return value;
      }
    });
    this.dynoSh2MinMax = new DynoVec2({
      key: "sh2MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1
        );
        return value;
      }
    });
    this.dynoSh3MinMax = new DynoVec2({
      key: "sh3MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1
        );
        return value;
      }
    });
    this.initialized = Promise.resolve(this);
    this.reinitialize(options);
  }
  reinitialize(options) {
    this.isInitialized = false;
    this.extra = {};
    this.splatEncoding = options.splatEncoding;
    if (options.url || options.fileBytes || options.construct) {
      this.initialized = this.asyncInitialize(options).then(() => {
        this.isInitialized = true;
        return this;
      });
    } else {
      this.initialize(options);
      this.isInitialized = true;
      this.initialized = Promise.resolve(this);
    }
  }
  initialize(options) {
    if (options.packedArray) {
      this.packedArray = options.packedArray;
      this.maxSplats = Math.floor(this.packedArray.length / 4);
      this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
      this.numSplats = Math.min(
        this.maxSplats,
        options.numSplats ?? Number.POSITIVE_INFINITY
      );
    } else {
      this.maxSplats = options.maxSplats ?? 0;
      this.numSplats = 0;
    }
    this.extra = options.extra ?? {};
  }
  async asyncInitialize(options) {
    const { url, fileBytes, construct } = options;
    if (url) {
      const loader = new SplatLoader();
      loader.packedSplats = this;
      await loader.loadAsync(url);
    } else if (fileBytes) {
      const unpacked = await unpackSplats({
        input: fileBytes,
        fileType: options.fileType,
        pathOrUrl: options.fileName ?? url,
        splatEncoding: options.splatEncoding ?? DEFAULT_SPLAT_ENCODING
      });
      this.initialize(unpacked);
    }
    if (construct) {
      const maybePromise = construct(this);
      if (maybePromise instanceof Promise) {
        await maybePromise;
      }
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    if (this.target) {
      this.target.dispose();
      this.target.texture.source.data = null;
      this.target = null;
    }
    if (this.source) {
      this.source.dispose();
      this.source.source.data = null;
      this.source = null;
    }
    this.packedArray = null;
    for (const key in this.extra) {
      const dyno2 = this.extra[key];
      if (dyno2 instanceof DynoUniform) {
        const texture2 = dyno2.value;
        if (texture2 == null ? void 0 : texture2.isTexture) {
          texture2.dispose();
          texture2.source.data = null;
        }
      }
    }
    this.extra = {};
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(numSplats) {
    const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(numSplats, 2 * this.maxSplats)
    );
    const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;
    if (!this.packedArray || targetSize > currentSize) {
      this.maxSplats = getTextureSize(targetSize).maxSplats;
      const newArray2 = new Uint32Array(this.maxSplats * 4);
      if (this.packedArray) {
        newArray2.set(this.packedArray);
      }
      this.packedArray = newArray2;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(level, numSplats) {
    let wordsPerSplat;
    let key;
    if (level === 0) {
      return this.ensureSplats(numSplats);
    }
    if (level === 1) {
      wordsPerSplat = 2;
      key = "sh1";
    } else if (level === 2) {
      wordsPerSplat = 4;
      key = "sh2";
    } else if (level === 3) {
      wordsPerSplat = 4;
      key = "sh3";
    } else {
      throw new Error(`Invalid level: ${level}`);
    }
    let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;
    const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);
    if (!this.extra[key] || targetSize > maxSplats) {
      maxSplats = getTextureSize(targetSize).maxSplats;
      const newArray2 = new Uint32Array(maxSplats * wordsPerSplat);
      if (this.extra[key]) {
        newArray2.set(this.extra[key]);
      }
      this.extra[key] = newArray2;
    }
    return this.extra[key];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(index) {
    if (!this.packedArray || index >= this.numSplats) {
      throw new Error("Invalid index");
    }
    return unpackSplat(this.packedArray, index, this.splatEncoding);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(index, center, scales, quaternion, opacity, color2) {
    const packedSplats = this.ensureSplats(index + 1);
    setPackedSplat(
      packedSplats,
      index,
      center.x,
      center.y,
      center.z,
      scales.x,
      scales.y,
      scales.z,
      quaternion.x,
      quaternion.y,
      quaternion.z,
      quaternion.w,
      opacity,
      color2.r,
      color2.g,
      color2.b
    );
    this.numSplats = Math.max(this.numSplats, index + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(center, scales, quaternion, opacity, color2) {
    const packedSplats = this.ensureSplats(this.numSplats + 1);
    setPackedSplat(
      packedSplats,
      this.numSplats,
      center.x,
      center.y,
      center.z,
      scales.x,
      scales.y,
      scales.z,
      quaternion.x,
      quaternion.y,
      quaternion.z,
      quaternion.w,
      opacity,
      color2.r,
      color2.g,
      color2.b
    );
    ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(callback) {
    if (!this.packedArray || !this.numSplats) {
      return;
    }
    for (let i = 0; i < this.numSplats; ++i) {
      const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);
      callback(
        i,
        unpacked.center,
        unpacked.scales,
        unpacked.quaternion,
        unpacked.opacity,
        unpacked.color
      );
    }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(maxSplats) {
    if (this.target && (maxSplats ?? 1) <= this.maxSplats) {
      return false;
    }
    if (this.target) {
      this.target.dispose();
    }
    const textureSize2 = getTextureSize(maxSplats ?? 1);
    const { width, height, depth: depth2 } = textureSize2;
    this.maxSplats = textureSize2.maxSplats;
    this.target = new THREE.WebGLArrayRenderTarget(width, height, depth2, {
      depthBuffer: false,
      stencilBuffer: false,
      generateMipmaps: false,
      magFilter: THREE.NearestFilter,
      minFilter: THREE.NearestFilter
    });
    this.target.texture.format = THREE.RGBAIntegerFormat;
    this.target.texture.type = THREE.UnsignedIntType;
    setTextureInternalFormat(this.target.texture, "RGBA32UI");
    this.target.scissorTest = true;
    return true;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(splatCounts) {
    let maxSplats = 0;
    const mapping = splatCounts.map((numSplats) => {
      const base = maxSplats;
      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
      maxSplats += rounded;
      return { base, count: numSplats };
    });
    return { maxSplats, mapping };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    if (this.target) {
      return this.target.texture;
    }
    if (this.source || this.packedArray) {
      const source = this.maybeUpdateSource();
      return source;
    }
    return _PackedSplats.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray) {
      throw new Error("No packed splats");
    }
    if (this.needsUpdate || !this.source) {
      this.needsUpdate = false;
      if (this.source) {
        const { width, height, depth: depth2 } = this.source.image;
        if (this.maxSplats !== width * height * depth2) {
          this.source.dispose();
          this.source = null;
        }
      }
      if (!this.source) {
        const { width, height, depth: depth2 } = getTextureSize(this.maxSplats);
        this.source = new THREE.DataArrayTexture(
          this.packedArray,
          width,
          height,
          depth2
        );
        this.source.format = THREE.RGBAIntegerFormat;
        this.source.type = THREE.UnsignedIntType;
        setTextureInternalFormat(this.source, "RGBA32UI");
        this.source.needsUpdate = true;
      } else if (this.packedArray.buffer !== this.source.image.data.buffer) {
        this.source.image.data = new Uint8Array(this.packedArray.buffer);
      }
      this.source.needsUpdate = true;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!_PackedSplats.emptySource) {
      const { width, height, depth: depth2, maxSplats } = getTextureSize(1);
      const emptyArray = new Uint32Array(maxSplats * 4);
      _PackedSplats.emptySource = new THREE.DataArrayTexture(
        emptyArray,
        width,
        height,
        depth2
      );
      _PackedSplats.emptySource.format = THREE.RGBAIntegerFormat;
      _PackedSplats.emptySource.type = THREE.UnsignedIntType;
      setTextureInternalFormat(_PackedSplats.emptySource, "RGBA32UI");
      _PackedSplats.emptySource.needsUpdate = true;
    }
    return _PackedSplats.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(generator) {
    let program = _PackedSplats.generatorProgram.get(generator);
    if (!program) {
      const graph = dynoBlock(
        { index: "int" },
        { output: "uvec4" },
        ({ index }) => {
          generator.inputs.index = index;
          const gsplat = generator.outputs.gsplat;
          const output2 = outputPackedSplat(
            gsplat,
            this.dynoRgbMinMaxLnScaleMinMax
          );
          return { output: output2 };
        }
      );
      if (!_PackedSplats.programTemplate) {
        _PackedSplats.programTemplate = new DynoProgramTemplate(
          getShaders().computeUvec4Template
        );
      }
      program = new DynoProgram({
        graph,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: _PackedSplats.programTemplate
      });
      Object.assign(program.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      });
      _PackedSplats.generatorProgram.set(generator, program);
    }
    const material = program.prepareMaterial();
    _PackedSplats.fullScreenQuad.material = material;
    return { program, material };
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator,
    base,
    count,
    renderer
  }) {
    if (!this.target) {
      throw new Error("Target must be initialized with ensureSplats");
    }
    if (base + count > this.maxSplats) {
      throw new Error("Base + count exceeds maxSplats");
    }
    const { program, material } = this.prepareProgramMaterial(generator);
    program.update();
    const renderState = this.saveRenderState(renderer);
    const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH$1) * SPLAT_TEX_WIDTH$1;
    const layerSize = SPLAT_TEX_WIDTH$1 * SPLAT_TEX_HEIGHT$1;
    material.uniforms.targetBase.value = base;
    material.uniforms.targetCount.value = count;
    while (base < nextBase) {
      const layer = Math.floor(base / layerSize);
      material.uniforms.targetLayer.value = layer;
      const layerBase = layer * layerSize;
      const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH$1);
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT$1,
        Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH$1)
      );
      this.target.scissor.set(
        0,
        layerYStart,
        SPLAT_TEX_WIDTH$1,
        layerYEnd - layerYStart
      );
      renderer.setRenderTarget(this.target, layer);
      renderer.xr.enabled = false;
      renderer.autoClear = false;
      _PackedSplats.fullScreenQuad.render(renderer);
      base += SPLAT_TEX_WIDTH$1 * (layerYEnd - layerYStart);
    }
    this.resetRenderState(renderer, renderState);
    return { nextBase };
  }
};
_PackedSplats.emptySource = null;
_PackedSplats.programTemplate = null;
_PackedSplats.generatorProgram = /* @__PURE__ */ new WeakMap();
_PackedSplats.fullScreenQuad = new FullScreenQuad(
  new THREE.RawShaderMaterial({ visible: false })
);
let PackedSplats = _PackedSplats;
class DynoPackedSplats extends DynoUniform {
  constructor({ packedSplats } = {}) {
    super({
      key: "packedSplats",
      type: TPackedSplats,
      globals: () => [definePackedSplats],
      value: {
        texture: PackedSplats.getEmpty(),
        numSplats: 0,
        rgbMinMaxLnScaleMinMax: new THREE.Vector4(
          0,
          1,
          LN_SCALE_MIN,
          LN_SCALE_MAX
        )
      },
      update: (value) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
        value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();
        value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;
        value.rgbMinMaxLnScaleMinMax.set(
          ((_d = (_c = this.packedSplats) == null ? void 0 : _c.splatEncoding) == null ? void 0 : _d.rgbMin) ?? 0,
          ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == null ? void 0 : _f.rgbMax) ?? 1,
          ((_h = (_g = this.packedSplats) == null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.lnScaleMin) ?? LN_SCALE_MIN,
          ((_j = (_i = this.packedSplats) == null ? void 0 : _i.splatEncoding) == null ? void 0 : _j.lnScaleMax) ?? LN_SCALE_MAX
        );
        return value;
      }
    });
    this.packedSplats = packedSplats;
  }
}
class SplatGeometry extends THREE.InstancedBufferGeometry {
  constructor(ordering, activeSplats) {
    super();
    this.ordering = ordering;
    this.setAttribute("position", new THREE.BufferAttribute(QUAD_VERTICES, 3));
    this.setIndex(new THREE.BufferAttribute(QUAD_INDICES$1, 1));
    this._maxInstanceCount = ordering.length;
    this.instanceCount = activeSplats;
    this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1);
    this.attribute.setUsage(THREE.DynamicDrawUsage);
    this.setAttribute("splatIndex", this.attribute);
  }
  update(ordering, activeSplats) {
    this.ordering = ordering;
    this.attribute.array = ordering;
    this.instanceCount = activeSplats;
    this.attribute.addUpdateRange(0, activeSplats);
    this.attribute.needsUpdate = true;
  }
}
const QUAD_VERTICES = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]);
const QUAD_INDICES$1 = new Uint16Array([0, 1, 2, 0, 2, 3]);
const _SparkViewpoint = class _SparkViewpoint {
  constructor(options) {
    this.lastTime = null;
    this.encodeLinear = false;
    this.superXY = 1;
    this.display = null;
    this.sorting = null;
    this.pending = null;
    this.sortingCheck = false;
    this.readback16 = new Uint16Array(0);
    this.readback32 = new Uint32Array(0);
    this.spark = options.spark;
    this.camera = options.camera;
    this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();
    if (options.target) {
      const { width, height, doubleBuffer } = options.target;
      const superXY = Math.max(1, Math.min(4, options.target.superXY ?? 1));
      this.superXY = superXY;
      if (width * superXY > 8192 || height * superXY > 8192) {
        throw new Error("Target size too large");
      }
      this.target = new THREE.WebGLRenderTarget(
        width * superXY,
        height * superXY,
        {
          format: THREE.RGBAFormat,
          type: THREE.UnsignedByteType,
          colorSpace: THREE.SRGBColorSpace
        }
      );
      if (doubleBuffer) {
        this.back = new THREE.WebGLRenderTarget(
          width * superXY,
          height * superXY,
          {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            colorSpace: THREE.SRGBColorSpace
          }
        );
      }
      this.encodeLinear = true;
    }
    this.onTextureUpdated = options.onTextureUpdated;
    this.sortRadial = options.sortRadial ?? true;
    this.sortDistance = options.sortDistance;
    this.sortCoorient = options.sortCoorient;
    this.depthBias = options.depthBias;
    this.sort360 = options.sort360;
    this.sort32 = options.sort32;
    this.stochastic = options.stochastic ?? false;
    this.orderingFreelist = new FreeList({
      allocate: (maxSplats) => new Uint32Array(maxSplats),
      valid: (ordering, maxSplats) => ordering.length === maxSplats
    });
    this.autoUpdate = false;
    this.setAutoUpdate(options.autoUpdate ?? false);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var _a2;
    this.setAutoUpdate(false);
    if (this.target) {
      this.target.dispose();
      this.target = void 0;
    }
    if (this.back) {
      this.back.dispose();
      this.back = void 0;
    }
    if (this.display) {
      this.spark.releaseAccumulator(this.display.accumulator);
      this.display.geometry.dispose();
      this.display = null;
    }
    if ((_a2 = this.pending) == null ? void 0 : _a2.accumulator) {
      this.spark.releaseAccumulator(this.pending.accumulator);
      this.pending = null;
    }
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(autoUpdate) {
    if (!this.autoUpdate && autoUpdate) {
      this.spark.autoViewpoints.push(this);
    } else if (this.autoUpdate && !autoUpdate) {
      this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
        (v) => v !== this
      );
    }
    this.autoUpdate = autoUpdate;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene,
    camera,
    viewToWorld,
    update,
    forceOrigin
  }) {
    if (viewToWorld) {
      this.viewToWorld = viewToWorld;
    } else {
      this.camera = camera ?? this.camera;
      if (this.camera) {
        this.camera.updateMatrixWorld();
        this.viewToWorld = this.camera.matrixWorld.clone();
      }
    }
    while (update ?? true) {
      const originToWorld = forceOrigin ? this.viewToWorld : this.spark.matrixWorld;
      const updated = this.spark.updateInternal({ scene, originToWorld });
      if (updated) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
    const accumulator = this.spark.active;
    accumulator.refCount += 1;
    await this.sortUpdate({ accumulator, viewToWorld: this.viewToWorld });
    this.spark.releaseAccumulator(accumulator);
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene,
    camera
  }) {
    var _a2;
    const target = this.back ?? this.target;
    if (!target) {
      throw new Error("Must initialize SparkViewpoint with target");
    }
    camera = camera ?? this.camera;
    if (!camera) {
      throw new Error("Must provide camera");
    }
    if (camera instanceof THREE.PerspectiveCamera) {
      const newCam = new THREE.PerspectiveCamera().copy(camera, false);
      newCam.aspect = target.width / target.height;
      newCam.updateProjectionMatrix();
      camera = newCam;
    }
    this.viewToWorld = camera.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(target);
      this.spark.prepareViewpoint(this);
      this.spark.renderer.render(scene, camera);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView);
      this.spark.renderer.setRenderTarget(null);
    }
    if (target !== this.target) {
      [this.target, this.back] = [this.back, this.target];
    }
    (_a2 = this.onTextureUpdated) == null ? void 0 : _a2.call(this, target.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target) {
      throw new Error("Must initialize SparkViewpoint with target");
    }
    const { width, height } = this.target;
    const byteSize = width * height * 4;
    if (!this.superPixels || this.superPixels.length < byteSize) {
      this.superPixels = new Uint8Array(byteSize);
    }
    await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      width,
      height,
      this.superPixels
    );
    const { superXY } = this;
    if (superXY === 1) {
      return this.superPixels;
    }
    const subWidth = width / superXY;
    const subHeight = height / superXY;
    const subSize = subWidth * subHeight * 4;
    if (!this.pixels || this.pixels.length < subSize) {
      this.pixels = new Uint8Array(subSize);
    }
    const { superPixels, pixels } = this;
    const super2 = superXY * superXY;
    for (let y = 0; y < subHeight; y++) {
      const row = y * subWidth;
      for (let x = 0; x < subWidth; x++) {
        const superCol = x * superXY;
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        for (let sy = 0; sy < superXY; sy++) {
          const superRow = (y * superXY + sy) * this.target.width;
          for (let sx = 0; sx < superXY; sx++) {
            const superIndex = (superRow + superCol + sx) * 4;
            r += superPixels[superIndex];
            g += superPixels[superIndex + 1];
            b += superPixels[superIndex + 2];
            a += superPixels[superIndex + 3];
          }
        }
        const pixelIndex = (row + x) * 4;
        pixels[pixelIndex] = r / super2;
        pixels[pixelIndex + 1] = g / super2;
        pixels[pixelIndex + 2] = b / super2;
        pixels[pixelIndex + 3] = a / super2;
      }
    }
    return pixels;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene,
    camera,
    viewToWorld,
    update,
    forceOrigin
  }) {
    await this.prepare({ scene, camera, viewToWorld, update, forceOrigin });
    this.renderTarget({ scene, camera });
    return this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({
    accumulator,
    forceStochastic = false
  }) {
    var _a2, _b2, _c;
    if (this.camera) {
      this.camera.updateMatrixWorld();
      this.viewToWorld = this.camera.matrixWorld.clone();
    }
    if (forceStochastic && accumulator) {
      const { numSplats, maxSplats } = accumulator.splats;
      if (numSplats > 0) {
        accumulator.refCount += 1;
        const ordering = this.orderingFreelist.alloc(maxSplats);
        for (let i = 0; i < numSplats; ++i) {
          ordering[i] = i;
        }
        this.updateDisplay({
          accumulator,
          viewToWorld: this.viewToWorld,
          ordering,
          activeSplats: numSplats,
          displayed: false
        });
      }
      return;
    }
    let needsSort = false;
    let displayed = false;
    if (!this.display) {
      needsSort = true;
    } else if (accumulator) {
      needsSort = true;
      const { mappingVersion } = this.display.accumulator;
      if (accumulator.mappingVersion === mappingVersion) {
        accumulator.refCount += 1;
        this.spark.releaseAccumulator(this.display.accumulator);
        this.display.accumulator = accumulator;
        this.display.viewToWorld.copy(this.viewToWorld);
        displayed = true;
        if (this.spark.viewpoint === this) {
          this.spark.prepareViewpoint(this);
        }
      }
    }
    const latestView = ((_a2 = this.sorting) == null ? void 0 : _a2.viewToWorld) ?? ((_b2 = this.display) == null ? void 0 : _b2.viewToWorld);
    if (latestView && !withinCoorientDist({
      matrix1: this.viewToWorld,
      matrix2: latestView,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    })) {
      needsSort = true;
    }
    if (!needsSort) {
      return;
    }
    if (accumulator) {
      accumulator.refCount += 1;
    }
    if ((_c = this.pending) == null ? void 0 : _c.accumulator) {
      this.spark.releaseAccumulator(this.pending.accumulator);
    }
    this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };
    this.driveSort();
  }
  async driveSort() {
    var _a2;
    while (true) {
      if (this.sorting || !this.pending) {
        return;
      }
      const { viewToWorld, displayed } = this.pending;
      let accumulator = this.pending.accumulator;
      if (!accumulator) {
        accumulator = ((_a2 = this.display) == null ? void 0 : _a2.accumulator) ?? this.spark.active;
        accumulator.refCount += 1;
      }
      this.pending = null;
      if (!accumulator) {
        throw new Error("No accumulator to sort");
      }
      this.sorting = { viewToWorld };
      await this.sortUpdate({ accumulator, viewToWorld, displayed });
      this.sorting = null;
      this.spark.releaseAccumulator(accumulator);
    }
  }
  async sortUpdate({
    accumulator,
    viewToWorld,
    displayed = false
  }) {
    if (this.sortingCheck) {
      throw new Error("Only one sort at a time");
    }
    this.sortingCheck = true;
    accumulator = accumulator ?? this.spark.active;
    const { numSplats, maxSplats } = accumulator.splats;
    let activeSplats = 0;
    let ordering = this.orderingFreelist.alloc(maxSplats);
    if (this.stochastic) {
      activeSplats = numSplats;
      for (let i = 0; i < numSplats; ++i) {
        ordering[i] = i;
      }
    } else if (numSplats > 0) {
      const {
        reader,
        doubleSortReader,
        sort32Reader,
        dynoSortRadial,
        dynoOrigin,
        dynoDirection,
        dynoDepthBias,
        dynoSort360,
        dynoSplats
      } = _SparkViewpoint.makeSorter();
      const sort32 = this.sort32 ?? false;
      let readback;
      if (sort32) {
        this.readback32 = reader.ensureBuffer(maxSplats, this.readback32);
        readback = this.readback32;
      } else {
        const halfMaxSplats = Math.ceil(maxSplats / 2);
        this.readback16 = reader.ensureBuffer(halfMaxSplats, this.readback16);
        readback = this.readback16;
      }
      const worldToOrigin = accumulator.toWorld.clone().invert();
      const viewToOrigin = viewToWorld.clone().premultiply(worldToOrigin);
      dynoSortRadial.value = this.sort360 ? true : this.sortRadial;
      dynoOrigin.value.set(0, 0, 0).applyMatrix4(viewToOrigin);
      dynoDirection.value.set(0, 0, -1).applyMatrix4(viewToOrigin).sub(dynoOrigin.value).normalize();
      dynoDepthBias.value = this.depthBias ?? 1;
      dynoSort360.value = this.sort360 ?? false;
      dynoSplats.packedSplats = accumulator.splats;
      const sortReader = sort32 ? sort32Reader : doubleSortReader;
      const count = sort32 ? numSplats : Math.ceil(numSplats / 2);
      await reader.renderReadback({
        renderer: this.spark.renderer,
        reader: sortReader,
        count,
        readback
      });
      const result = await withWorker(async (worker) => {
        const rpcName = sort32 ? "sort32Splats" : "sortDoubleSplats";
        return worker.call(rpcName, {
          maxSplats,
          numSplats,
          readback,
          ordering
        });
      });
      if (sort32) {
        this.readback32 = result.readback;
      } else {
        this.readback16 = result.readback;
      }
      ordering = result.ordering;
      activeSplats = result.activeSplats;
    }
    this.updateDisplay({
      accumulator,
      viewToWorld,
      ordering,
      activeSplats,
      displayed
    });
    this.sortingCheck = false;
  }
  updateDisplay({
    accumulator,
    viewToWorld,
    ordering,
    activeSplats,
    displayed = false
  }) {
    if (!this.display) {
      accumulator.refCount += 1;
      this.display = {
        accumulator,
        viewToWorld,
        geometry: new SplatGeometry(ordering, activeSplats)
      };
    } else {
      if (!displayed && accumulator !== this.display.accumulator) {
        accumulator.refCount += 1;
        this.spark.releaseAccumulator(this.display.accumulator);
        this.display.accumulator = accumulator;
      }
      this.display.viewToWorld = viewToWorld;
      const oldOrdering = this.display.geometry.ordering;
      if (oldOrdering.length === ordering.length) {
        this.display.geometry.update(ordering, activeSplats);
      } else {
        this.display.geometry.dispose();
        this.display.geometry = new SplatGeometry(ordering, activeSplats);
      }
      this.orderingFreelist.free(oldOrdering);
    }
    if (this.spark.viewpoint === this) {
      this.spark.prepareViewpoint(this);
    }
  }
  static makeSorter() {
    if (!_SparkViewpoint.dynos) {
      const dynoSortRadial = new DynoBool({ value: true });
      const dynoOrigin = new DynoVec3({ value: new THREE.Vector3() });
      const dynoDirection = new DynoVec3({ value: new THREE.Vector3() });
      const dynoDepthBias = new DynoFloat({ value: 1 });
      const dynoSort360 = new DynoBool({ value: false });
      const dynoSplats = new DynoPackedSplats();
      const reader = new Readback();
      const doubleSortReader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("No index");
          }
          const sortParams = {
            sortRadial: dynoSortRadial,
            sortOrigin: dynoOrigin,
            sortDirection: dynoDirection,
            sortDepthBias: dynoDepthBias,
            sort360: dynoSort360
          };
          const index2 = mul$4(index, dynoConst("int", 2));
          const gsplat0 = readPackedSplat(dynoSplats, index2);
          const metric0 = computeSortMetric({ gsplat: gsplat0, ...sortParams });
          const gsplat1 = readPackedSplat(
            dynoSplats,
            add$4(index2, dynoConst("int", 1))
          );
          const metric1 = computeSortMetric({ gsplat: gsplat1, ...sortParams });
          const combined = combine({
            vectorType: "vec2",
            x: metric0,
            y: metric1
          });
          const rgba8 = uintToRgba8(packHalf2x16$1(combined));
          return { rgba8 };
        }
      );
      const sort32Reader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("No index");
          }
          const sortParams = {
            sortRadial: dynoSortRadial,
            sortOrigin: dynoOrigin,
            sortDirection: dynoDirection,
            sortDepthBias: dynoDepthBias,
            sort360: dynoSort360
          };
          const gsplat = readPackedSplat(dynoSplats, index);
          const metric = computeSortMetric({ gsplat, ...sortParams });
          const rgba8 = uintToRgba8(floatBitsToUint$1(metric));
          return { rgba8 };
        }
      );
      _SparkViewpoint.dynos = {
        dynoSortRadial,
        dynoOrigin,
        dynoDirection,
        dynoDepthBias,
        dynoSort360,
        dynoSplats,
        reader,
        doubleSortReader,
        sort32Reader
      };
    }
    return _SparkViewpoint.dynos;
  }
};
_SparkViewpoint.EMPTY_TEXTURE = new THREE.Texture();
_SparkViewpoint.dynos = null;
let SparkViewpoint = _SparkViewpoint;
const defineComputeSortMetric = unindent(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function computeSortMetric({
  gsplat,
  sortRadial,
  sortOrigin,
  sortDirection,
  sortDepthBias,
  sort360
}) {
  return dyno$1({
    inTypes: {
      gsplat: Gsplat,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [defineGsplat, defineComputeSortMetric],
    inputs: {
      gsplat,
      sortRadial,
      sortOrigin,
      sortDirection,
      sortDepthBias,
      sort360
    },
    statements: ({ inputs, outputs }) => {
      const {
        gsplat: gsplat2,
        sortRadial: sortRadial2,
        sortOrigin: sortOrigin2,
        sortDirection: sortDirection2,
        sortDepthBias: sortDepthBias2,
        sort360: sort3602
      } = inputs;
      return unindentLines(`
        ${outputs.metric} = computeSort(${gsplat2}, ${sortRadial2}, ${sortOrigin2}, ${sortDirection2}, ${sortDepthBias2}, ${sort3602});
      `);
    }
  }).outputs.metric;
}
class SplatAccumulator {
  constructor() {
    this.splats = new PackedSplats();
    this.toWorld = new THREE.Matrix4();
    this.mapping = [];
    this.refCount = 0;
    this.splatsVersion = -1;
    this.mappingVersion = -1;
  }
  ensureGenerate(maxSplats) {
    if (this.splats.ensureGenerate(maxSplats)) {
      this.mapping = [];
    }
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer,
    modifier,
    generators: generators2,
    forceUpdate,
    originToWorld
  }) {
    const mapping = this.mapping.reduce((map, record) => {
      map.set(record.node, record);
      return map;
    }, /* @__PURE__ */ new Map());
    let updated = 0;
    let numSplats = 0;
    for (const { node, generator, version, base, count } of generators2) {
      const current = mapping.get(node);
      if (forceUpdate || generator !== (current == null ? void 0 : current.generator) || version !== (current == null ? void 0 : current.version) || base !== (current == null ? void 0 : current.base) || count !== (current == null ? void 0 : current.count)) {
        if (generator && count > 0) {
          const modGenerator = modifier.apply(generator);
          try {
            this.splats.generate({
              generator: modGenerator,
              base,
              count,
              renderer
            });
          } catch (error2) {
            node.generator = void 0;
            node.generatorError = error2;
          }
          updated += 1;
        }
      }
      numSplats = Math.max(numSplats, base + count);
    }
    this.splats.numSplats = numSplats;
    this.toWorld.copy(originToWorld);
    this.mapping = generators2;
    return updated !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(other) {
    if (this.mapping.length !== other.mapping.length) {
      return false;
    }
    return this.mapping.every(({ node, base, count }, i) => {
      const {
        node: otherNode,
        base: otherBase,
        count: otherCount
      } = other.mapping[i];
      return node === otherNode && base === otherBase && count === otherCount;
    });
  }
  // CPU fallback for WebGPU: directly copy packed splat data from each generator.
  // This bypasses the GPU generation pipeline (dyno shaders) and copies raw data.
  // Note: This does NOT apply transforms - splats will be in their original
  // object-space coordinates. For full transform support, TSL compute shaders
  // would be needed.
  generateSplatsCpu({
    generators: generators2,
    originToWorld
  }) {
    let numSplats = 0;
    for (const { base, count } of generators2) {
      numSplats = Math.max(numSplats, base + count);
    }
    this.splats.ensureSplats(numSplats);
    for (const { node, base, count } of generators2) {
      if (count <= 0) continue;
      const sourcePackedSplats = node.packedSplats;
      if (!(sourcePackedSplats == null ? void 0 : sourcePackedSplats.packedArray)) continue;
      const sourceArray = sourcePackedSplats.packedArray;
      const targetArray = this.splats.packedArray;
      if (!targetArray) continue;
      const copyCount = Math.min(count, sourcePackedSplats.numSplats);
      for (let i = 0; i < copyCount; i++) {
        const srcOffset = i * 4;
        const dstOffset = (base + i) * 4;
        targetArray[dstOffset] = sourceArray[srcOffset];
        targetArray[dstOffset + 1] = sourceArray[srcOffset + 1];
        targetArray[dstOffset + 2] = sourceArray[srcOffset + 2];
        targetArray[dstOffset + 3] = sourceArray[srcOffset + 3];
      }
    }
    this.splats.numSplats = numSplats;
    this.splats.needsUpdate = true;
    this.toWorld.copy(originToWorld);
    this.mapping = generators2;
    return true;
  }
  // Ensure we have enough space for CPU-based generation (uses packedArray, not render target)
  ensureGenerateCpu(maxSplats) {
    this.splats.ensureSplats(maxSplats);
    if (this.splats.maxSplats !== maxSplats) {
      this.mapping = [];
    }
  }
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "182";
const BasicShadowMap = 0;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AddEquation = 100;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const LessEqualDepth = 3;
const MultiplyOperation = 0;
const NoToneMapping = 0;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const LinearFilter = 1006;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const RGBAFormat = 1023;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RGFormat = 1030;
const RG11_EAC_Format = 37490;
const RED_GREEN_RGTC2_Format = 36285;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const NoNormalPacking = "";
const NormalRGPacking = "rg";
const NormalGAPacking = "ga";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const LessCompare = 513;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
function arrayNeedsUint32(array2) {
  for (let i = array2.length - 1; i >= 0; --i) {
    if (array2[i] >= 65535) return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
const _cache$1 = {};
function log$2(...params) {
  const message = "THREE." + params.shift();
  {
    console.log(message, ...params);
  }
}
function warn(...params) {
  const message = "THREE." + params.shift();
  {
    console.warn(message, ...params);
  }
}
function error(...params) {
  const message = "THREE." + params.shift();
  {
    console.error(message, ...params);
  }
}
function warnOnce(...params) {
  const message = params.join(" ");
  if (message in _cache$1) return;
  _cache$1[message] = true;
  warn(...params);
}
class EventDispatcher {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return false;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array2 = listenerArray.slice(0);
      for (let i = 0, l = array2.length; i < l; i++) {
        array2[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp$2(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b22) {
  return b1 + (x - a1) * (b22 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length2 = 1) {
  return length2 - Math.abs(euclideanModulo(x, length2 * 2) - length2);
}
function smoothstep$1(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min2, max2) {
  if (x <= min2) return 0;
  if (x >= max2) return 1;
  x = (x - min2) / (max2 - min2);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range2) {
  return range2 * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees2) {
  return degrees2 * DEG2RAD;
}
function radToDeg(radians2) {
  return radians2 * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos2 = Math.cos;
  const sin2 = Math.sin;
  const c2 = cos2(b / 2);
  const s2 = sin2(b / 2);
  const c13 = cos2((a + c) / 2);
  const s13 = sin2((a + c) / 2);
  const c1_3 = cos2((a - c) / 2);
  const s1_3 = sin2((a - c) / 2);
  const c3_1 = cos2((c - a) / 2);
  const s3_1 = sin2((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      warn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$2(value, array2) {
  switch (array2.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  /**
   * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: clamp$2,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: smoothstep$1,
  /**
   * A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: normalize$2,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize
};
class Vector2 {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    return this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$2(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    return this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Quaternion {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];
    let x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w12 = src1[srcOffset1 + 3];
    if (t <= 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w02;
      return;
    }
    if (t >= 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w12;
      return;
    }
    if (w02 !== w12 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let dot2 = x0 * x1 + y0 * y1 + z0 * z1 + w02 * w12;
      if (dot2 < 0) {
        x1 = -x1;
        y1 = -y1;
        z1 = -z1;
        w12 = -w12;
        dot2 = -dot2;
      }
      let s = 1 - t;
      if (dot2 < 0.9995) {
        const theta = Math.acos(dot2);
        const sin2 = Math.sin(theta);
        s = Math.sin(s * theta) / sin2;
        t = Math.sin(t * theta) / sin2;
        x0 = x0 * s + x1 * t;
        y0 = y0 * s + y1 * t;
        z0 = z0 * s + z1 * t;
        w02 = w02 * s + w12 * t;
      } else {
        x0 = x0 * s + x1 * t;
        y0 = y0 * s + y1 * t;
        z0 = z0 * s + z1 * t;
        w02 = w02 * s + w12 * t;
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w02 * w02);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w02 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w02;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w02 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w12 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w12 + w02 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w12 + w02 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w12 + w02 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w02 * w12 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos2 = Math.cos;
    const sin2 = Math.sin;
    const c1 = cos2(x / 2);
    const c2 = cos2(y / 2);
    const c3 = cos2(z / 2);
    const s1 = sin2(x / 2);
    const s2 = sin2(y / 2);
    const s3 = sin2(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < 1e-8) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$2(this.dot(q), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(q, step2) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step2 / angle);
    this.slerp(q, t);
    return this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(qb, t) {
    if (t <= 0) return this;
    if (t >= 1) return this.copy(qb);
    let x = qb._x, y = qb._y, z = qb._z, w = qb._w;
    let dot2 = this.dot(qb);
    if (dot2 < 0) {
      x = -x;
      y = -y;
      z = -z;
      w = -w;
      dot2 = -dot2;
    }
    let s = 1 - t;
    if (dot2 < 0.9995) {
      const theta = Math.acos(dot2);
      const sin2 = Math.sin(theta);
      s = Math.sin(s * theta) / sin2;
      t = Math.sin(t * theta) / sin2;
      this._x = this._x * s + x * t;
      this._y = this._y * s + y * t;
      this._z = this._z * s + z * t;
      this._w = this._w * s + w * t;
      this._onChangeCallback();
    } else {
      this._x = this._x * s + x * t;
      this._y = this._y * s + y * t;
      this._z = this._z * s + z * t;
      this._w = this._w * s + w * t;
      this.normalize();
    }
    return this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(array2, offset = 0) {
    this._x = array2[offset];
    this._y = array2[offset + 1];
    this._z = array2[offset + 2];
    this._w = array2[offset + 3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._w;
    return array2;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(attribute2, index) {
    this._x = attribute2.getX(index);
    this._y = attribute2.getY(index);
    this._z = attribute2.getZ(index);
    this._w = attribute2.getW(index);
    this._onChangeCallback();
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(z) {
    this.z = z;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    this.z = clamp$2(this.z, min2.z, max2.z);
    return this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    this.z = clamp$2(this.z, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(v) {
    return this.crossVectors(this, v);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(normal2) {
    return this.sub(_vector$c.copy(normal2).multiplyScalar(2 * this.dot(normal2)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$2(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    this.z = attribute2.getZ(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Matrix3 {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det2 = n11 * t11 + n21 * t12 + n31 * t13;
    if (det2 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array2[i + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array2 = [], offset = 0) {
    const te = this.elements;
    array2[offset] = te[0];
    array2[offset + 1] = te[1];
    array2[offset + 2] = te[2];
    array2[offset + 3] = te[3];
    array2[offset + 4] = te[4];
    array2[offset + 5] = te[5];
    array2[offset + 6] = te[6];
    array2[offset + 7] = te[7];
    array2[offset + 8] = te[8];
    return array2;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function createColorManagement() {
  const ColorManagement2 = {
    enabled: true,
    workingColorSpace: LinearSRGBColorSpace,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(color2, sourceColorSpace, targetColorSpace) {
      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color2;
      }
      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
        color2.r = SRGBToLinear(color2.r);
        color2.g = SRGBToLinear(color2.g);
        color2.b = SRGBToLinear(color2.b);
      }
      if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
        color2.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
        color2.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
      }
      if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
        color2.r = LinearToSRGB(color2.r);
        color2.g = LinearToSRGB(color2.g);
        color2.b = LinearToSRGB(color2.b);
      }
      return color2;
    },
    workingToColorSpace: function(color2, targetColorSpace) {
      return this.convert(color2, this.workingColorSpace, targetColorSpace);
    },
    colorSpaceToWorking: function(color2, sourceColorSpace) {
      return this.convert(color2, sourceColorSpace, this.workingColorSpace);
    },
    getPrimaries: function(colorSpace) {
      return this.spaces[colorSpace].primaries;
    },
    getTransfer: function(colorSpace) {
      if (colorSpace === NoColorSpace) return LinearTransfer;
      return this.spaces[colorSpace].transfer;
    },
    getToneMappingMode: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode || "standard";
    },
    getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
    },
    define: function(colorSpaces) {
      Object.assign(this.spaces, colorSpaces);
    },
    // Internal APIs
    _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
      return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(color2, targetColorSpace) {
      warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");
      return ColorManagement2.workingToColorSpace(color2, targetColorSpace);
    },
    toWorkingColorSpace: function(color2, sourceColorSpace) {
      warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");
      return ColorManagement2.colorSpaceToWorking(color2, sourceColorSpace);
    }
  };
  const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
  const D65 = [0.3127, 0.329];
  ColorManagement2.define({
    [LinearSRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    },
    [SRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    }
  });
  return ColorManagement2;
}
const ColorManagement = /* @__PURE__ */ createColorManagement();
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(image, type = "image/png") {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context2 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context2.putImageData(image, 0, 0);
      } else {
        context2.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    return canvas.toDataURL(type);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context2 = canvas.getContext("2d");
      context2.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context2.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context2.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      warn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  /**
   * Returns the dimensions of the source into the given target vector.
   *
   * @param {(Vector2|Vector3)} target - The target object the result is written into.
   * @return {(Vector2|Vector3)} The dimensions of the source.
   */
  getSize(target) {
    const data = this.data;
    if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
      target.set(data.videoWidth, data.videoHeight, 0);
    } else if (typeof VideoFrame !== "undefined" && data instanceof VideoFrame) {
      target.set(data.displayHeight, data.displayWidth, 0);
    } else if (data !== null) {
      target.set(data.width, data.height, data.depth || 0);
    } else {
      target.set(0, 0, 0);
    }
    return target;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output2 = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output2.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output2;
    }
    return output2;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      warn("Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
const _tempVec3 = /* @__PURE__ */ new Vector3();
class Texture2 extends EventDispatcher {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(image = Texture2.DEFAULT_IMAGE, mapping = Texture2.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy2 = Texture2.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy2;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.updateRanges = [];
    this.version = 0;
    this.onUpdate = null;
    this.renderTarget = null;
    this.isRenderTargetTexture = false;
    this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;
    this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(_tempVec3).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(_tempVec3).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(_tempVec3).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.renderTarget = source.renderTarget;
    this.isRenderTargetTexture = source.isRenderTargetTexture;
    this.isArrayTexture = source.isArrayTexture;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(values) {
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        warn(`Texture.setValues(): parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        warn(`Texture.setValues(): property '${key}' does not exist.`);
        continue;
      }
      if (currentValue && newValue && (currentValue.isVector2 && newValue.isVector2)) {
        currentValue.copy(newValue);
      } else if (currentValue && newValue && (currentValue.isVector3 && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else if (currentValue && newValue && (currentValue.isMatrix3 && newValue.isMatrix3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output2 = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output2.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output2;
    }
    return output2;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(uv2) {
    if (this.mapping !== UVMapping) return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture2.DEFAULT_IMAGE = null;
Texture2.DEFAULT_MAPPING = UVMapping;
Texture2.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(x) {
    this.x = x;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(y) {
    this.y = y;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(z) {
    this.z = z;
    return this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(w) {
    this.w = w;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(min2, max2) {
    this.x = clamp$2(this.x, min2.x, max2.x);
    this.y = clamp$2(this.y, min2.y, max2.y);
    this.z = clamp$2(this.z, min2.z, max2.z);
    this.w = clamp$2(this.w, min2.w, max2.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp$2(this.x, minVal, maxVal);
    this.y = clamp$2(this.y, minVal, maxVal);
    this.z = clamp$2(this.z, minVal, maxVal);
    this.w = clamp$2(this.w, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(min2, max2) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(clamp$2(length2, min2, max2));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(array2, offset = 0) {
    this.x = array2[offset];
    this.y = array2[offset + 1];
    this.z = array2[offset + 2];
    this.w = array2[offset + 3];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.x;
    array2[offset + 1] = this.y;
    array2[offset + 2] = this.z;
    array2[offset + 3] = this.w;
    return array2;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(attribute2, index) {
    this.x = attribute2.getX(index);
    this.y = attribute2.getY(index);
    this.z = attribute2.getZ(index);
    this.w = attribute2.getW(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(width = 1, height = 1, options = {}) {
    super();
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: false
    }, options);
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = options.depth;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: options.depth };
    const texture2 = new Texture2(image);
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture2.clone();
      this.textures[i].isRenderTargetTexture = true;
      this.textures[i].renderTarget = this;
    }
    this._setTextureOptions(options);
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this._depthTexture = null;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
    this.multiview = options.multiview;
  }
  _setTextureOptions(options = {}) {
    const values = {
      minFilter: LinearFilter,
      generateMipmaps: false,
      flipY: false,
      internalFormat: null
    };
    if (options.mapping !== void 0) values.mapping = options.mapping;
    if (options.wrapS !== void 0) values.wrapS = options.wrapS;
    if (options.wrapT !== void 0) values.wrapT = options.wrapT;
    if (options.wrapR !== void 0) values.wrapR = options.wrapR;
    if (options.magFilter !== void 0) values.magFilter = options.magFilter;
    if (options.minFilter !== void 0) values.minFilter = options.minFilter;
    if (options.format !== void 0) values.format = options.format;
    if (options.type !== void 0) values.type = options.type;
    if (options.anisotropy !== void 0) values.anisotropy = options.anisotropy;
    if (options.colorSpace !== void 0) values.colorSpace = options.colorSpace;
    if (options.flipY !== void 0) values.flipY = options.flipY;
    if (options.generateMipmaps !== void 0) values.generateMipmaps = options.generateMipmaps;
    if (options.internalFormat !== void 0) values.internalFormat = options.internalFormat;
    for (let i = 0; i < this.textures.length; i++) {
      const texture2 = this.textures[i];
      texture2.setValues(values);
    }
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  set depthTexture(current) {
    if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
    if (current !== null) current.renderTarget = this;
    this._depthTexture = current;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(width, height, depth2 = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth2) {
      this.width = width;
      this.height = height;
      this.depth = depth2;
      for (let i = 0, il = this.textures.length; i < il; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth2;
        if (this.textures[i].isData3DTexture !== true) {
          this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
        }
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il = source.textures.length; i < il; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
      this.textures[i].renderTarget = this;
      const image = Object.assign({}, source.textures[i].image);
      this.textures[i].source = new Source(image);
    }
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class DataArrayTexture extends Texture2 {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(data = null, width = 1, height = 1, depth2 = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth: depth2 };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Box3 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(min2 = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min2;
    this.max = max2;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(array2) {
    this.makeEmpty();
    for (let i = 0, il = array2.length; i < il; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array2, i));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(attribute2) {
    this.makeEmpty();
    for (let i = 0, il = attribute2.count; i < il; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute2, i));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(plane) {
    let min2, max2;
    if (plane.normal.x > 0) {
      min2 = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min2 = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min2 += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min2 += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min2 += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min2 += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min2 <= -plane.constant && max2 >= -plane.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(json) {
    this.min.fromArray(json.min);
    this.max.fromArray(json.max);
    return this;
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq2 = _v1$6.lengthSq();
    if (lengthSq2 > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq2);
      const delta = (length2 - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length2);
      this.radius += delta;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Sphere} A reference to this bounding sphere.
   */
  fromJSON(json) {
    this.radius = json.radius;
    this.center.fromArray(json.center);
    return this;
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det2 = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det2 > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det2;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det2;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(sphere) {
    if (sphere.radius < 0) return false;
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    if (this.determinant() === 0) {
      xAxis.set(1, 0, 0);
      yAxis.set(0, 1, 0);
      zAxis.set(0, 0, 1);
      return this;
    }
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(m) {
    if (m.determinant() === 0) {
      return this.identity();
    }
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    const t11 = n23 * n34 - n24 * n33;
    const t12 = n22 * n34 - n24 * n32;
    const t13 = n22 * n33 - n23 * n32;
    const t21 = n21 * n34 - n24 * n31;
    const t22 = n21 * n33 - n23 * n31;
    const t23 = n21 * n32 - n22 * n31;
    return n11 * (n42 * t11 - n43 * t12 + n44 * t13) - n12 * (n41 * t11 - n43 * t21 + n44 * t22) + n13 * (n41 * t12 - n42 * t21 + n44 * t23) - n14 * (n41 * t13 - n42 * t22 + n43 * t23);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det2 = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det2 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det2;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(position, quaternion, scale) {
    const te = this.elements;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    if (this.determinant() === 0) {
      scale.set(1, 1, 1);
      quaternion.identity();
      return this;
    }
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det2 = this.determinant();
    if (det2 < 0) sx = -sx;
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (reversedDepth) {
      c = near / (far - near);
      d = far * near / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -(far + near) / (far - near);
        d = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -far / (far - near);
        d = -far * near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
      }
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
    const te = this.elements;
    const x = 2 / (right - left);
    const y = 2 / (top - bottom);
    const a = -(right + left) / (right - left);
    const b = -(top + bottom) / (top - bottom);
    let c, d;
    if (reversedDepth) {
      c = 1 / (far - near);
      d = far / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -2 / (far - near);
        d = -(far + near) / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -1 / (far - near);
        d = -near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
      }
    }
    te[0] = x;
    te[4] = 0;
    te[8] = 0;
    te[12] = a;
    te[1] = 0;
    te[5] = y;
    te[9] = 0;
    te[13] = b;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array2[i + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array2 = [], offset = 0) {
    const te = this.elements;
    array2[offset] = te[0];
    array2[offset + 1] = te[1];
    array2[offset + 2] = te[2];
    array2[offset + 3] = te[3];
    array2[offset + 4] = te[4];
    array2[offset + 5] = te[5];
    array2[offset + 6] = te[6];
    array2[offset + 7] = te[7];
    array2[offset + 8] = te[8];
    array2[offset + 9] = te[9];
    array2[offset + 10] = te[10];
    array2[offset + 11] = te[11];
    array2[offset + 12] = te[12];
    array2[offset + 13] = te[13];
    array2[offset + 14] = te[14];
    array2[offset + 15] = te[15];
    return array2;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp$2(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp$2(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp$2(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp$2(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp$2(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp$2(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        warn("Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(array2) {
    this._x = array2[0];
    this._y = array2[1];
    this._z = array2[2];
    if (array2[3] !== void 0) this._order = array2[3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this._x;
    array2[offset + 1] = this._y;
    array2[offset + 2] = this._z;
    array2[offset + 3] = this._order;
    return array2;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1 | 0;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(layer) {
    this.mask = (1 << layer | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(layer) {
    this.mask |= 1 << layer | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(layer) {
    this.mask ^= 1 << layer | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(layer) {
    this.mask &= ~(1 << layer | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(layer) {
    return (this.mask & (1 << layer | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1$1 = /* @__PURE__ */ new Matrix4();
const _target$1 = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new Matrix4()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.customDepthMaterial = void 0;
    this.customDistanceMaterial = void 0;
    this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target$1.copy(x);
    } else {
      _target$1.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1$1.lookAt(_position$3, _target$1, this.up);
    } else {
      _m1$1$1.lookAt(_target$1, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1$1);
    if (parent) {
      _m1$1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      error("Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      error("Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1$1);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      child.updateMatrixWorld(force);
    }
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output2 = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output2.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.geometryInfo = this._geometryInfo.map((info) => ({
        ...info,
        boundingBox: info.boundingBox ? info.boundingBox.toJSON() : void 0,
        boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : void 0
      }));
      object.instanceInfo = this._instanceInfo.map((info) => ({ ...info }));
      object.availableInstanceIds = this._availableInstanceIds.slice();
      object.availableGeometryIds = this._availableGeometryIds.slice();
      object.nextIndexStart = this._nextIndexStart;
      object.nextVertexStart = this._nextVertexStart;
      object.geometryCount = this._geometryCount;
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      object.indirectTexture = this._indirectTexture.toJSON(meta);
      if (this._colorsTexture !== null) {
        object.colorsTexture = this._colorsTexture.toJSON(meta);
      }
      if (this.boundingSphere !== null) {
        object.boundingSphere = this.boundingSphere.toJSON();
      }
      if (this.boundingBox !== null) {
        object.boundingBox = this.boundingBox.toJSON();
      }
    }
    function serialize(library, element2) {
      if (library[element2.uuid] === void 0) {
        library[element2.uuid] = element2.toJSON(meta);
      }
      return element2.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output2.geometries = geometries;
      if (materials.length > 0) output2.materials = materials;
      if (textures.length > 0) output2.textures = textures;
      if (images.length > 0) output2.images = images;
      if (shapes.length > 0) output2.shapes = shapes;
      if (skeletons.length > 0) output2.skeletons = skeletons;
      if (animations.length > 0) output2.animations = animations;
      if (nodes.length > 0) output2.nodes = nodes;
    }
    output2.object = object;
    return output2;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
const _v40 = /* @__PURE__ */ new Vector4();
const _v41 = /* @__PURE__ */ new Vector4();
const _v42 = /* @__PURE__ */ new Vector4();
class Triangle {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(point, a, b, c) {
    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(attribute2, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute2, i0);
    this.b.fromBufferAttribute(attribute2, i1);
    this.c.fromBufferAttribute(attribute2, i2);
    return this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
class Color {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp$2(s, 0, 1);
    l = clamp$2(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string2) {
      if (string2 === void 0) return;
      if (parseFloat(string2) < 1) {
        warn("Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(255, parseInt(color2[1], 10)) / 255,
              Math.min(255, parseInt(color2[2], 10)) / 255,
              Math.min(255, parseInt(color2[3], 10)) / 255,
              colorSpace
            );
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(100, parseInt(color2[1], 10)) / 100,
              Math.min(100, parseInt(color2[2], 10)) / 100,
              Math.min(100, parseInt(color2[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setHSL(
              parseFloat(color2[1]) / 360,
              parseFloat(color2[2]) / 100,
              parseFloat(color2[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          warn("Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        warn("Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      warn("Color: Unknown color " + style);
    }
    return this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp$2(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp$2(_color.g * 255, 0, 255)) * 256 + Math.round(clamp$2(_color.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    const max2 = Math.max(r, g, b);
    const min2 = Math.min(r, g, b);
    let hue2, saturation2;
    const lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue2 = 0;
      saturation2 = 0;
    } else {
      const delta = max2 - min2;
      saturation2 = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r:
          hue2 = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue2 = (b - r) / delta + 2;
          break;
        case b:
          hue2 = (r - g) / delta + 4;
          break;
      }
      hue2 /= 6;
    }
    target.h = hue2;
    target.s = saturation2;
    target.l = lightness;
    return target;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(array2, offset = 0) {
    this.r = array2[offset];
    this.g = array2[offset + 1];
    this.b = array2[offset + 2];
    return this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(array2 = [], offset = 0) {
    array2[offset] = this.r;
    array2[offset + 1] = this.g;
    array2[offset + 2] = this.b;
    return array2;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(attribute2, index) {
    this.r = attribute2.getX(index);
    this.g = attribute2.getY(index);
    this.b = attribute2.getZ(index);
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  /**
   * Constructs a new material.
   */
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.allowOverride = true;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        warn(`Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        warn(`Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.sheenColorMap && this.sheenColorMap.isTexture) {
      data.sheenColorMap = this.sheenColorMap.toJSON(meta).uuid;
    }
    if (this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture) {
      data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(meta).uuid;
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.allowOverride === false) data.allowOverride = false;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.allowOverride = source.allowOverride;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
}
class MeshBasicMaterial extends Material {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
let _id$2 = 0;
class BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized = false) {
    if (Array.isArray(array2)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.name = "";
    this.array = array2;
    this.itemSize = itemSize;
    this.count = array2 !== void 0 ? array2.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(index1, attribute2, index2) {
    index1 *= this.itemSize;
    index2 *= attribute2.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute2.array[index2 + i];
    }
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(array2) {
    this.array.set(array2);
    return this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(index, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(index, y) {
    if (this.normalized) y = normalize$2(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(index, z) {
    if (this.normalized) z = normalize$2(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(index, w) {
    if (this.normalized) w = normalize$2(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
      w = normalize$2(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Uint16Array(array2), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Uint32Array(array2), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array2, itemSize, normalized) {
    super(new Float32Array(array2), itemSize, normalized);
  }
}
let _id$1 = 0;
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.indirectOffset = 0;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @param {number|Array<number>} [indirectOffset=0] - The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(indirect, indirectOffset = 0) {
    this.indirect = indirect;
    this.indirectOffset = indirectOffset;
    return this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(name, attribute2) {
    this.attributes[name] = attribute2;
    return this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal2 = this.attributes.normal;
    if (normal2 !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal2.applyNormalMatrix(normalMatrix);
      normal2.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(q) {
    _m1$3.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(angle) {
    _m1$3.makeRotationX(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(angle) {
    _m1$3.makeRotationY(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(angle) {
    _m1$3.makeRotationZ(angle);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(x, y, z) {
    _m1$3.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(x, y, z) {
    _m1$3.makeScale(x, y, z);
    this.applyMatrix4(_m1$3);
    return this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      const l = Math.min(points.length, positionAttribute.count);
      for (let i = 0; i < l; i++) {
        const point = points[i];
        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        warn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      error("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      error('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      error("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        error('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      error("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index.count
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          index.getX(j + 0),
          index.getX(j + 1),
          index.getX(j + 2)
        );
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromBufferAttribute(normalAttribute, v);
      n2.copy(n);
      const t = tan1[v];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function convertBufferAttribute(attribute2, indices2) {
      const array2 = attribute2.array;
      const itemSize = attribute2.itemSize;
      const normalized = attribute2.normalized;
      const array22 = new array2.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute2.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute2.data.stride + attribute2.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array22[index2++] = array2[index++];
        }
      }
      return new BufferAttribute(array22, itemSize, normalized);
    }
    if (this.index === null) {
      warn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      const newAttribute = convertBufferAttribute(attribute2, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute2 = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute2, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const data = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute2 = attributes[key];
      data.data.attributes[key] = attribute2.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray2 = this.morphAttributes[key];
      const array2 = [];
      for (let i = 0, il = attributeArray2.length; i < il; i++) {
        const attribute2 = attributeArray2[i];
        array2.push(attribute2.toJSON(data.data));
      }
      if (array2.length > 0) {
        morphAttributes[key] = array2;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = boundingSphere.toJSON();
    }
    return data;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute2 = attributes[name];
      this.setAttribute(name, attribute2.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array2 = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array2.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array2;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.count = 1;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects, _ray$3);
  }
  _computeIntersections(raycaster, intersects, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv2 = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal2 = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal2, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal2, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far) return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv2, uv1, normal2, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv2) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv2, a, b, c, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
    }
    if (normal2) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal2, a, b, c, barycoord, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(width = 1, height = 1, depth2 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth: depth2,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth2, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth2, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth2, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth2, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth2, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth2, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth3, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth3 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth3 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
class Camera extends Object3D {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
    this._reversedDepth = false;
  }
  /**
   * The flag that indicates whether the camera uses a reversed depth buffer.
   *
   * @type {boolean}
   * @default false
   */
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(distance2, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance2 / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(distance2, target) {
    this.getViewBounds(distance2, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
class CubeTexture extends Texture2 {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy2, colorSpace) {
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy2, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class InterleavedBuffer {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(array2, stride) {
    this.isInterleavedBuffer = true;
    this.array = array2;
    this.stride = stride;
    this.count = array2 !== void 0 ? array2.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(index1, interleavedBuffer, index2) {
    index1 *= this.stride;
    index2 *= interleavedBuffer.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = interleavedBuffer.array[index2 + i];
    }
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array2 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array2, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const _vector$7 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.applyMatrix4(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.applyNormalMatrix(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$7.fromBufferAttribute(this, i);
      _vector$7.transformDirection(m);
      this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(index, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(index, y) {
    if (this.normalized) y = normalize$2(y, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(index, z) {
    if (this.normalized) z = normalize$2(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(index, w) {
    if (this.normalized) w = normalize$2(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y = normalize$2(y, this.array);
      z = normalize$2(z, this.array);
      w = normalize$2(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(data) {
    if (data === void 0) {
      log$2("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array2 = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array2.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array2), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(data) {
    if (data === void 0) {
      log$2("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array2 = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array2.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array2,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
class DataTexture extends Texture2 {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy2, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy2, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(array2, itemSize, normalized, meshPerAttribute = 1) {
    super(array2, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(normal2 = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal2;
    this.constant = constant;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(normal2, constant) {
    this.normal.copy(normal2);
    this.constant = constant;
    return this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(normal2, point) {
    this.normal.copy(normal2);
    this.constant = -point.dot(this.normal);
    return this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(a, b, c) {
    const normal2 = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal2, a);
    return this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal2);
    return this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class FramebufferTexture extends Texture2 {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} [width] - The width of the texture.
   * @param {number} [height] - The height of the texture.
   */
  constructor(width, height) {
    super({ width, height });
    this.isFramebufferTexture = true;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
class DepthTexture extends Texture2 {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy2, format = DepthFormat, depth2 = 1) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    const image = { width, height, depth: depth2 };
    super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy2);
    this.isDepthTexture = true;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.source = new Source(Object.assign({}, source.image));
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
}
class CubeDepthTexture extends DepthTexture {
  /**
   * Constructs a new cube depth texture.
   *
   * @param {number} size - The size (width and height) of each cube face.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   */
  constructor(size, type = UnsignedIntType, mapping = CubeReflectionMapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy2, format = DepthFormat) {
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    super(size, size, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy2, format);
    this.image = images;
    this.isCubeDepthTexture = true;
    this.isCubeTexture = true;
  }
  /**
   * Alias for {@link CubeDepthTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class OrthographicCamera extends Camera {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(array2, stride, meshPerAttribute = 1) {
    super(array2, stride);
    this.isInstancedInterleavedBuffer = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
class Matrix2 {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(n11, n12, n21, n22) {
    Matrix2.prototype.isMatrix2 = true;
    this.elements = [
      1,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n21, n22);
    }
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    this.set(
      1,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(array2, offset = 0) {
    for (let i = 0; i < 4; i++) {
      this.elements[i] = array2[i + offset];
    }
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(n11, n12, n21, n22) {
    const te = this.elements;
    te[0] = n11;
    te[2] = n12;
    te[1] = n21;
    te[3] = n22;
    return this;
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const refreshUniforms = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
const _lightsCache = /* @__PURE__ */ new WeakMap();
class NodeMaterialObserver {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(builder) {
    this.renderObjects = /* @__PURE__ */ new WeakMap();
    this.hasNode = this.containsNode(builder);
    this.hasAnimation = builder.object.isSkinnedMesh === true;
    this.refreshUniforms = refreshUniforms;
    this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(renderObject) {
    const hasInitialized = this.renderObjects.has(renderObject);
    if (hasInitialized === false) {
      this.getRenderObjectData(renderObject);
      return true;
    }
    return false;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(renderer) {
    const mrt2 = renderer.getMRT();
    return mrt2 !== null && mrt2.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(renderObject) {
    let data = this.renderObjects.get(renderObject);
    if (data === void 0) {
      const { geometry, material, object } = renderObject;
      data = {
        material: this.getMaterialData(material),
        geometry: {
          id: geometry.id,
          attributes: this.getAttributesData(geometry.attributes),
          indexVersion: geometry.index ? geometry.index.version : null,
          drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
        },
        worldMatrix: object.matrixWorld.clone()
      };
      if (object.center) {
        data.center = object.center.clone();
      }
      if (object.morphTargetInfluences) {
        data.morphTargetInfluences = object.morphTargetInfluences.slice();
      }
      if (renderObject.bundle !== null) {
        data.version = renderObject.bundle.version;
      }
      if (data.material.transmission > 0) {
        const { width, height } = renderObject.context;
        data.bufferWidth = width;
        data.bufferHeight = height;
      }
      data.lights = this.getLightsData(renderObject.lightsNode.getLights());
      this.renderObjects.set(renderObject, data);
    }
    return data;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(attributes) {
    const attributesData = {};
    for (const name in attributes) {
      const attribute2 = attributes[name];
      attributesData[name] = {
        version: attribute2.version
      };
    }
    return attributesData;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(builder) {
    const material = builder.material;
    for (const property2 in material) {
      if (material[property2] && material[property2].isNode)
        return true;
    }
    if (builder.context.modelViewMatrix || builder.context.modelNormalViewMatrix || builder.context.getAO || builder.context.getShadow)
      return true;
    return false;
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(material) {
    const data = {};
    for (const property2 of this.refreshUniforms) {
      const value = material[property2];
      if (value === null || value === void 0) continue;
      if (typeof value === "object" && value.clone !== void 0) {
        if (value.isTexture === true) {
          data[property2] = { id: value.id, version: value.version };
        } else {
          data[property2] = value.clone();
        }
      } else {
        data[property2] = value;
      }
    }
    return data;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Light>} lightsData - The current material lights.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(renderObject, lightsData) {
    const { object, material, geometry } = renderObject;
    const renderObjectData = this.getRenderObjectData(renderObject);
    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
      renderObjectData.worldMatrix.copy(object.matrixWorld);
      return false;
    }
    const materialData = renderObjectData.material;
    for (const property2 in materialData) {
      const value = materialData[property2];
      const mtlValue = material[property2];
      if (value.equals !== void 0) {
        if (value.equals(mtlValue) === false) {
          value.copy(mtlValue);
          return false;
        }
      } else if (mtlValue.isTexture === true) {
        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
          value.id = mtlValue.id;
          value.version = mtlValue.version;
          return false;
        }
      } else if (value !== mtlValue) {
        materialData[property2] = mtlValue;
        return false;
      }
    }
    if (materialData.transmission > 0) {
      const { width, height } = renderObject.context;
      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
        renderObjectData.bufferWidth = width;
        renderObjectData.bufferHeight = height;
        return false;
      }
    }
    const storedGeometryData = renderObjectData.geometry;
    const attributes = geometry.attributes;
    const storedAttributes = storedGeometryData.attributes;
    const storedAttributeNames = Object.keys(storedAttributes);
    const currentAttributeNames = Object.keys(attributes);
    if (storedGeometryData.id !== geometry.id) {
      storedGeometryData.id = geometry.id;
      return false;
    }
    if (storedAttributeNames.length !== currentAttributeNames.length) {
      renderObjectData.geometry.attributes = this.getAttributesData(attributes);
      return false;
    }
    for (const name of storedAttributeNames) {
      const storedAttributeData = storedAttributes[name];
      const attribute2 = attributes[name];
      if (attribute2 === void 0) {
        delete storedAttributes[name];
        return false;
      }
      if (storedAttributeData.version !== attribute2.version) {
        storedAttributeData.version = attribute2.version;
        return false;
      }
    }
    const index = geometry.index;
    const storedIndexVersion = storedGeometryData.indexVersion;
    const currentIndexVersion = index ? index.version : null;
    if (storedIndexVersion !== currentIndexVersion) {
      storedGeometryData.indexVersion = currentIndexVersion;
      return false;
    }
    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
      storedGeometryData.drawRange.start = geometry.drawRange.start;
      storedGeometryData.drawRange.count = geometry.drawRange.count;
      return false;
    }
    if (renderObjectData.morphTargetInfluences) {
      let morphChanged = false;
      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {
        if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {
          renderObjectData.morphTargetInfluences[i] = object.morphTargetInfluences[i];
          morphChanged = true;
        }
      }
      if (morphChanged) return false;
    }
    if (renderObjectData.lights) {
      for (let i = 0; i < lightsData.length; i++) {
        if (renderObjectData.lights[i].map !== lightsData[i].map) {
          return false;
        }
      }
    }
    if (renderObjectData.center) {
      if (renderObjectData.center.equals(object.center) === false) {
        renderObjectData.center.copy(object.center);
        return true;
      }
    }
    if (renderObject.bundle !== null) {
      renderObjectData.version = renderObject.bundle.version;
    }
    return true;
  }
  /**
   * Returns the lights data for the given material lights.
   *
   * @param {Array<Light>} materialLights - The material lights.
   * @return {Array<Object>} The lights data for the given material lights.
   */
  getLightsData(materialLights) {
    const lights2 = [];
    for (const light of materialLights) {
      if (light.isSpotLight === true && light.map !== null) {
        lights2.push({ map: light.map.version });
      }
    }
    return lights2;
  }
  /**
   * Returns the lights for the given lights node and render ID.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {number} renderId - The render ID.
   * @return {Array<Object>} The lights for the given lights node and render ID.
   */
  getLights(lightsNode, renderId) {
    if (_lightsCache.has(lightsNode)) {
      const cached = _lightsCache.get(lightsNode);
      if (cached.renderId === renderId) {
        return cached.lightsData;
      }
    }
    const lightsData = this.getLightsData(lightsNode.getLights());
    _lightsCache.set(lightsNode, { renderId, lightsData });
    return lightsData;
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject, nodeFrame) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject) || this.needsVelocity(nodeFrame.renderer))
      return true;
    const { renderId } = nodeFrame;
    if (this.renderId !== renderId) {
      this.renderId = renderId;
      return true;
    }
    const isStatic = renderObject.object.static === true;
    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
    if (isStatic || isBundle)
      return false;
    const lightsData = this.getLights(renderObject.lightsNode, renderId);
    const notEqual2 = this.equals(renderObject, lightsData) !== true;
    return notEqual2;
  }
}
function cyrb53(value, seed = 0) {
  let h12 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i = 0, val; i < value.length; i++) {
      val = value[i];
      h12 = Math.imul(h12 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i = 0, ch; i < value.length; i++) {
      ch = value.charCodeAt(i);
      h12 = Math.imul(h12 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507);
  h12 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h12 >>> 0);
}
const hashString = (str) => cyrb53(str);
const hashArray = (array2) => cyrb53(array2);
const hash$1 = (...params) => cyrb53(params);
const typeFromLength = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
const dataFromObject = /* @__PURE__ */ new WeakMap();
function getTypeFromLength(length2) {
  return typeFromLength.get(length2);
}
function getTypedArrayFromType(type) {
  if (/[iu]?vec\d/.test(type)) {
    if (type.startsWith("ivec")) return Int32Array;
    if (type.startsWith("uvec")) return Uint32Array;
    return Float32Array;
  }
  if (/mat\d/.test(type)) return Float32Array;
  if (/float/.test(type)) return Float32Array;
  if (/uint/.test(type)) return Uint32Array;
  if (/int/.test(type)) return Int32Array;
  throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
}
function getLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 9;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getMemoryLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 12;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getAlignmentFromType(type) {
  if (/float|int|uint/.test(type)) return 4;
  if (/vec2/.test(type)) return 8;
  if (/vec3/.test(type)) return 16;
  if (/vec4/.test(type)) return 16;
  if (/mat2/.test(type)) return 8;
  if (/mat3/.test(type)) return 16;
  if (/mat4/.test(type)) return 16;
  error("TSL: Unsupported type:", type);
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix2 === true) {
    return "mat2";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat2") {
    return new Matrix2(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function getDataFromObject(object) {
  let data = dataFromObject.get(object);
  if (data === void 0) {
    data = {};
    dataFromObject.set(object, data);
  }
  return data;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array2.length; i++) {
    chars += String.fromCharCode(array2[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}
const NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
const NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
const NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
const NodeAccess = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
};
const defaultShaderStages = ["fragment", "vertex"];
const defaultBuildStages = ["setup", "analyze", "generate"];
const shaderStages = [...defaultShaderStages, "compute"];
const vectorComponents = ["x", "y", "z", "w"];
const _parentBuildStage = {
  analyze: "setup",
  generate: "analyze"
};
let _nodeId = 0;
class Node extends EventDispatcher {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this.name = "";
    this.global = false;
    this.parents = false;
    this.isNode = true;
    this._beforeNodes = null;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this);
    return this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(callback) {
    this.updateReference = callback.bind(this);
    return this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode } of this._getChildren()) {
      yield childNode;
    }
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  /**
   * Returns the child nodes of this node.
   *
   * @private
   * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
   * @returns {Array<Object>} An array of objects describing the child nodes.
   */
  _getChildren(ignores = /* @__PURE__ */ new Set()) {
    const children = [];
    ignores.add(this);
    for (const property2 of Object.getOwnPropertyNames(this)) {
      const object = this[property2];
      if (property2.startsWith("_") === true || ignores.has(object)) continue;
      if (Array.isArray(object) === true) {
        for (let i = 0; i < object.length; i++) {
          const child = object[i];
          if (child && child.isNode === true) {
            children.push({ property: property2, index: i, childNode: child });
          }
        }
      } else if (object && object.isNode === true) {
        children.push({ property: property2, childNode: object });
      } else if (object && Object.getPrototypeOf(object) === Object.prototype) {
        for (const subProperty in object) {
          if (subProperty.startsWith("_") === true) continue;
          const child = object[subProperty];
          if (child && child.isNode === true) {
            children.push({ property: property2, index: subProperty, childNode: child });
          }
        }
      }
    }
    return children;
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
   * @return {number} The cache key of the node.
   */
  getCacheKey(force = false, ignores = null) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      if (ignores === null) ignores = /* @__PURE__ */ new Set();
      const values = [];
      for (const { property: property2, childNode } of this._getChildren(ignores)) {
        values.push(hashString(property2.slice(0, -4)), childNode.getCacheKey(force, ignores));
      }
      this._cacheKey = hash$1(hashArray(values), this.customCacheKey());
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return this.id;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(builder) {
    const hash5 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash5);
    return nodeFromHash || this;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?number} The number of elements in the node array.
   */
  getArrayCount() {
    return null;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
   * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(builder, output2 = null) {
    const usageCount = builder.increaseUsage(this);
    if (this.parents === true) {
      const nodeData = builder.getDataFromNode(this, "any");
      nodeData.stages = nodeData.stages || {};
      nodeData.stages[builder.shaderStage] = nodeData.stages[builder.shaderStage] || [];
      nodeData.stages[builder.shaderStage].push(output2);
    }
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder, this);
        }
      }
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output] - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    warn("Abstract function.");
  }
  before(node) {
    if (this._beforeNodes === null) this._beforeNodes = [];
    this._beforeNodes.push(node);
    return this;
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?(string|Node)} [output=null] - Can be used to define the output type.
   * @return {?(Node|string)} The result of the build process, depending on the build stage.
   */
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    if (this._beforeNodes !== null) {
      const currentBeforeNodes = this._beforeNodes;
      this._beforeNodes = null;
      for (const beforeNode of currentBeforeNodes) {
        beforeNode.build(builder, output2);
      }
      this._beforeNodes = currentBeforeNodes;
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.buildStages = nodeData.buildStages || {};
    nodeData.buildStages[builder.buildStage] = true;
    const parentBuildStage = _parentBuildStage[builder.buildStage];
    if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
      const previousBuildStage = builder.getBuildStage();
      builder.setBuildStage(parentBuildStage);
      this.build(builder);
      builder.setBuildStage(previousBuildStage);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        properties.initialized = true;
        properties.outputNode = this.setup(builder) || properties.outputNode || null;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            if (childNode.parents === true) {
              const childProperties = builder.getNodeProperties(childNode);
              childProperties.parents = childProperties.parents || [];
              childProperties.parents.push(this);
            }
            childNode.build(builder);
          }
        }
      }
      result = properties.outputNode;
    } else if (buildStage === "analyze") {
      this.analyze(builder, output2);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length < 2;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData2 = builder.getDataFromNode(this);
        result = nodeData2.snippet;
        if (result === void 0) {
          if (nodeData2.generated === void 0) {
            nodeData2.generated = true;
            result = this.generate(builder) || "";
            nodeData2.snippet = result;
          } else {
            warn("Node: Recursion detected.", this);
            result = "/* Recursion detected. */";
          }
        } else if (nodeData2.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
      if (result === "" && output2 !== null && output2 !== "void" && output2 !== "OutputType") {
        error(`TSL: Invalid generated code, expected a "${output2}".`);
        result = builder.generateConst(output2);
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Generator<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return this._getChildren();
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.7,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
}
class ArrayElementNode extends Node {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  /**
   * This method is overwritten since the member type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @return {string} The member type.
   */
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  generate(builder) {
    const indexType = this.indexNode.getNodeType(builder);
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, !builder.isVector(indexType) && builder.isInteger(indexType) ? indexType : "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
}
class ConvertNode extends Node {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
}
class TempNode extends Node {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super(nodeType);
    this.isTempNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
}
class JoinNode extends TempNode {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const maxLength = builder.getTypeLength(type);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    let length2 = 0;
    for (const input of nodes) {
      if (length2 >= maxLength) {
        error(`TSL: Length of parameters exceeds maximum length of function '${type}()' type.`);
        break;
      }
      let inputType = input.getNodeType(builder);
      let inputTypeLength = builder.getTypeLength(inputType);
      let inputSnippet;
      if (length2 + inputTypeLength > maxLength) {
        error(`TSL: Length of '${type}()' data exceeds maximum length of output type.`);
        inputTypeLength = maxLength - length2;
        inputType = builder.getTypeFromLength(inputTypeLength);
      }
      length2 += inputTypeLength;
      inputSnippet = input.build(builder, inputType);
      const inputPrimitiveType = builder.getComponentType(inputType);
      if (inputPrimitiveType !== primitiveType) {
        const targetType = builder.getTypeFromLength(inputTypeLength, primitiveType);
        inputSnippet = builder.format(inputSnippet, inputType, targetType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
}
const _stringVectorComponents = vectorComponents.join("");
class SplitNode extends Node {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  /**
   * Returns the scope of the node.
   *
   * @return {Node} The scope of the node.
   */
  getScope() {
    return this.node.getScope();
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
}
class SetNode extends TempNode {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const componentType = builder.getComponentType(targetNode.getNodeType(builder));
    const targetType = builder.getTypeFromLength(components.length, componentType);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class FlipNode extends TempNode {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
}
class InputNode extends Node {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    warn("Abstract function.");
  }
}
const _regNum = /float|u?int/;
class ConstNode extends InputNode {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    if (_regNum.test(type) && _regNum.test(output2)) {
      return builder.generateConst(output2, this.value);
    }
    return builder.format(this.generateConst(builder), type, output2);
  }
}
class MemberNode extends Node {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs a member node.
   *
   * @param {Node} structNode - The struct node.
   * @param {string} property - The property name.
   */
  constructor(structNode, property2) {
    super();
    this.structNode = structNode;
    this.property = property2;
    this.isMemberNode = true;
  }
  hasMember(builder) {
    if (this.structNode.isMemberNode) {
      if (this.structNode.hasMember(builder) === false) {
        return false;
      }
    }
    return this.structNode.getMemberType(builder, this.property) !== "void";
  }
  getNodeType(builder) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    return this.structNode.getMemberType(builder, this.property);
  }
  getMemberType(builder, name) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    const type = this.getNodeType(builder);
    const struct2 = builder.getStructTypeNode(type);
    return struct2.getMemberType(builder, name);
  }
  generate(builder) {
    if (this.hasMember(builder) === false) {
      warn(`TSL: Member "${this.property}" does not exist in struct.`);
      const type = this.getNodeType(builder);
      return builder.generateConst(type);
    }
    const propertyName = this.structNode.build(builder);
    return propertyName + "." + this.property;
  }
}
let currentStack = null;
const NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    warn(`TSL: Redefinition of method chaining '${name}'.`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`THREE.TSL: Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
  if (name !== "assign") {
    Node.prototype[name] = function(...params) {
      return this.isStackNode ? this.addToStack(nodeElement(...params)) : nodeElement(this, ...params);
    };
    Node.prototype[name + "Assign"] = function(...params) {
      return this.isStackNode ? this.assign(params[0], nodeElement(...params)) : this.assign(nodeElement(this, ...params));
    };
  }
}
const parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
const parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
Node.prototype.assign = function(...params) {
  if (this.isStackNode !== true) {
    if (currentStack !== null) {
      currentStack.assign(this, ...params);
    } else {
      error("TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().");
    }
    return this;
  } else {
    const nodeElement = NodeElements.get("assign");
    return this.addToStack(nodeElement(...params));
  }
};
Node.prototype.toVarIntent = function() {
  return this;
};
Node.prototype.get = function(value) {
  return new MemberNode(this, value);
};
const proto = {};
function setProtoSwizzle(property2, altA, altB) {
  proto[property2] = proto[altA] = proto[altB] = {
    get() {
      this._cache = this._cache || {};
      let split2 = this._cache[property2];
      if (split2 === void 0) {
        split2 = new SplitNode(this, property2);
        this._cache[property2] = split2;
      }
      return split2;
    },
    set(value) {
      this[property2].assign(nodeObject(value));
    }
  };
  const propUpper = property2.toUpperCase();
  const altAUpper = altA.toUpperCase();
  const altBUpper = altB.toUpperCase();
  Node.prototype["set" + propUpper] = Node.prototype["set" + altAUpper] = Node.prototype["set" + altBUpper] = function(value) {
    const swizzle2 = parseSwizzleAndSort(property2);
    return new SetNode(this, swizzle2, nodeObject(value));
  };
  Node.prototype["flip" + propUpper] = Node.prototype["flip" + altAUpper] = Node.prototype["flip" + altBUpper] = function() {
    const swizzle2 = parseSwizzleAndSort(property2);
    return new FlipNode(this, swizzle2);
  };
}
const swizzleA = ["x", "y", "z", "w"];
const swizzleB = ["r", "g", "b", "a"];
const swizzleC = ["s", "t", "p", "q"];
for (let a = 0; a < 4; a++) {
  let prop = swizzleA[a];
  let altA = swizzleB[a];
  let altB = swizzleC[a];
  setProtoSwizzle(prop, altA, altB);
  for (let b = 0; b < 4; b++) {
    prop = swizzleA[a] + swizzleA[b];
    altA = swizzleB[a] + swizzleB[b];
    altB = swizzleC[a] + swizzleC[b];
    setProtoSwizzle(prop, altA, altB);
    for (let c = 0; c < 4; c++) {
      prop = swizzleA[a] + swizzleA[b] + swizzleA[c];
      altA = swizzleB[a] + swizzleB[b] + swizzleB[c];
      altB = swizzleC[a] + swizzleC[b] + swizzleC[c];
      setProtoSwizzle(prop, altA, altB);
      for (let d = 0; d < 4; d++) {
        prop = swizzleA[a] + swizzleA[b] + swizzleA[c] + swizzleA[d];
        altA = swizzleB[a] + swizzleB[b] + swizzleB[c] + swizzleB[d];
        altB = swizzleC[a] + swizzleC[b] + swizzleC[c] + swizzleC[d];
        setProtoSwizzle(prop, altA, altB);
      }
    }
  }
}
for (let i = 0; i < 32; i++) {
  proto[i] = {
    get() {
      this._cache = this._cache || {};
      let element2 = this._cache[i];
      if (element2 === void 0) {
        element2 = new ArrayElementNode(this, new ConstNode(i, "uint"));
        this._cache[i] = element2;
      }
      return element2;
    },
    set(value) {
      this[i].assign(nodeObject(value));
    }
  };
}
Object.defineProperties(Node.prototype, proto);
const nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
const ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    return obj;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return obj.isFn ? obj : Fn$4(obj);
  }
  return obj;
};
const ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
const ShaderNodeArray = function(array2, altType = null) {
  const len = array2.length;
  for (let i = 0; i < len; i++) {
    array2[i] = nodeObject(array2[i], altType);
  }
  return array2;
};
const ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  function assignNode(node) {
    if (settings !== null) {
      node = nodeObject(Object.assign(node, settings));
      if (settings.intent === true) {
        node = node.toVarIntent();
      }
    } else {
      node = nodeObject(node);
    }
    return node;
  }
  let fn, name = scope, minParams, maxParams;
  function verifyParamsLimit(params) {
    let tslName;
    if (name) tslName = /[a-z]/i.test(name) ? name + "()" : name;
    else tslName = NodeClass.type;
    if (minParams !== void 0 && params.length < minParams) {
      error(`TSL: "${tslName}" parameter length is less than minimum required.`);
      return params.concat(new Array(minParams - params.length).fill(0));
    } else if (maxParams !== void 0 && params.length > maxParams) {
      error(`TSL: "${tslName}" parameter length exceeds limit.`);
      return params.slice(0, maxParams);
    }
    return params;
  }
  if (scope === null) {
    fn = (...params) => {
      return assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params))));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)), factor));
    };
  } else {
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params))));
    };
  }
  fn.setParameterLength = (...params) => {
    if (params.length === 1) minParams = maxParams = params[0];
    else if (params.length === 2) [minParams, maxParams] = params;
    return fn;
  };
  fn.setName = (value) => {
    name = value;
    return fn;
  };
  return fn;
};
const ShaderNodeImmutable = function(NodeClass, ...params) {
  return new NodeClass(...nodeArray(params));
};
class ShaderCallNodeInternal extends Node {
  constructor(shaderNode, rawInputs) {
    super();
    this.shaderNode = shaderNode;
    this.rawInputs = rawInputs;
    this.isShaderCallNodeInternal = true;
  }
  getNodeType(builder) {
    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
  }
  getElementType(builder) {
    return this.getOutputNode(builder).getElementType(builder);
  }
  getMemberType(builder, name) {
    return this.getOutputNode(builder).getMemberType(builder, name);
  }
  call(builder) {
    const { shaderNode, rawInputs } = this;
    const properties = builder.getNodeProperties(shaderNode);
    const subBuild2 = builder.getClosestSubBuild(shaderNode.subBuilds) || "";
    const subBuildProperty = subBuild2 || "default";
    if (properties[subBuildProperty]) {
      return properties[subBuildProperty];
    }
    const previousSubBuildFn = builder.subBuildFn;
    const previousFnCall = builder.fnCall;
    builder.subBuildFn = subBuild2;
    builder.fnCall = this;
    let result = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      builder.addInclude(functionNode);
      const inputs = rawInputs ? getLayoutParameters(rawInputs) : null;
      result = nodeObject(functionNode.call(inputs));
    } else {
      const secureNodeBuilder = new Proxy(builder, {
        get: (target, property2, receiver) => {
          let value;
          if (Symbol.iterator === property2) {
            value = function* () {
              yield void 0;
            };
          } else {
            value = Reflect.get(target, property2, receiver);
          }
          return value;
        }
      });
      const inputs = rawInputs ? getProxyParameters(rawInputs) : null;
      const hasParameters = Array.isArray(rawInputs) ? rawInputs.length > 0 : rawInputs !== null;
      const jsFunc = shaderNode.jsFunc;
      const outputNode = hasParameters || jsFunc.length > 1 ? jsFunc(inputs, secureNodeBuilder) : jsFunc(secureNodeBuilder);
      result = nodeObject(outputNode);
    }
    builder.subBuildFn = previousSubBuildFn;
    builder.fnCall = previousFnCall;
    if (shaderNode.once) {
      properties[subBuildProperty] = result;
    }
    return result;
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    properties[subBuildOutput] = properties[subBuildOutput] || this.setupOutput(builder);
    properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
    return properties[subBuildOutput];
  }
  build(builder, output2 = null) {
    let result = null;
    const buildStage = builder.getBuildStage();
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    const outputNode = this.getOutputNode(builder);
    const previousFnCall = builder.fnCall;
    builder.fnCall = this;
    if (buildStage === "setup") {
      const subBuildInitialized = builder.getSubBuildProperty("initialized", this);
      if (properties[subBuildInitialized] !== true) {
        properties[subBuildInitialized] = true;
        properties[subBuildOutput] = this.getOutputNode(builder);
        properties[subBuildOutput].build(builder);
        if (this.shaderNode.subBuilds) {
          for (const node of builder.chaining) {
            const nodeData = builder.getDataFromNode(node, "any");
            nodeData.subBuilds = nodeData.subBuilds || /* @__PURE__ */ new Set();
            for (const subBuild2 of this.shaderNode.subBuilds) {
              nodeData.subBuilds.add(subBuild2);
            }
          }
        }
      }
      result = properties[subBuildOutput];
    } else if (buildStage === "analyze") {
      outputNode.build(builder, output2);
    } else if (buildStage === "generate") {
      result = outputNode.build(builder, output2) || "";
    }
    builder.fnCall = previousFnCall;
    return result;
  }
}
function getLayoutParameters(params) {
  let output2;
  nodeObjects(params);
  const isArrayAsParameter = params[0] && (params[0].isNode || Object.getPrototypeOf(params[0]) !== Object.prototype);
  if (isArrayAsParameter) {
    output2 = [...params];
  } else {
    output2 = params[0];
  }
  return output2;
}
function getProxyParameters(params) {
  let index = 0;
  nodeObjects(params);
  return new Proxy(params, {
    get: (target, property2, receiver) => {
      let value;
      if (property2 === "length") {
        value = params.length;
        return value;
      }
      if (Symbol.iterator === property2) {
        value = function* () {
          for (const inputNode of params) {
            yield nodeObject(inputNode);
          }
        };
      } else {
        if (params.length > 0) {
          if (Object.getPrototypeOf(params[0]) === Object.prototype) {
            const objectTarget = params[0];
            if (objectTarget[property2] === void 0) {
              value = objectTarget[index++];
            } else {
              value = Reflect.get(objectTarget, property2, receiver);
            }
          } else if (params[0] instanceof Node) {
            if (params[property2] === void 0) {
              value = params[index++];
            } else {
              value = Reflect.get(params, property2, receiver);
            }
          }
        } else {
          value = Reflect.get(target, property2, receiver);
        }
        value = nodeObject(value);
      }
      return value;
    }
  });
}
class ShaderNodeInternal extends Node {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  getLayout() {
    return this.layout;
  }
  call(rawInputs = null) {
    return new ShaderCallNodeInternal(this, rawInputs);
  }
  setup() {
    return this.call();
  }
}
const bools = [false, true];
const uints = [0, 1, 2, 3];
const ints = [-1, -2];
const floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
const boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools) boolsCacheMap.set(bool2, new ConstNode(bool2));
const uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints) uintsCacheMap.set(uint2, new ConstNode(uint2, "uint"));
const intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int2 of ints) intsCacheMap.set(int2, new ConstNode(int2, "int"));
const floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float2 of floats) floatsCacheMap.set(float2, new ConstNode(float2));
for (const float2 of floats) floatsCacheMap.set(-float2, new ConstNode(-float2));
const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
const constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
const getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
const ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    for (const param of params) {
      if (param === void 0) {
        error(`TSL: Invalid parameter for the type "${type}".`);
        return new ConstNode(0, type);
      }
    }
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => {
      const paramType = typeof param;
      return paramType !== "object" && paramType !== "function";
    })) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObjectIntent(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (node.nodeType === type) return nodeObjectIntent(node);
      return nodeObjectIntent(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObjectIntent(new JoinNode(nodes, type));
  };
};
const defined = (v) => typeof v === "object" && v !== null ? v.value : v;
const getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc, nodeType) {
  return new ShaderNodeInternal(jsFunc, nodeType);
}
const nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
const nodeObjectIntent = (val, altType = null) => (
  /* new */
  nodeObject(val, altType).toVarIntent()
);
const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
const nodeProxy = (NodeClass, scope = null, factor = null, settings = null) => new ShaderNodeProxy(NodeClass, scope, factor, settings);
const nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
const nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) => new ShaderNodeProxy(NodeClass, scope, factor, { ...settings, intent: true });
let fnId = 0;
class FnNode extends Node {
  constructor(jsFunc, layout = null) {
    super();
    let nodeType = null;
    if (layout !== null) {
      if (typeof layout === "object") {
        nodeType = layout.return;
      } else {
        if (typeof layout === "string") {
          nodeType = layout;
        } else {
          error("TSL: Invalid layout type.");
        }
        layout = null;
      }
    }
    this.shaderNode = new ShaderNode(jsFunc, nodeType);
    if (layout !== null) {
      this.setLayout(layout);
    }
    this.isFn = true;
  }
  setLayout(layout) {
    const nodeType = this.shaderNode.nodeType;
    if (typeof layout.inputs !== "object") {
      const fullLayout = {
        name: "fn" + fnId++,
        type: nodeType,
        inputs: []
      };
      for (const name in layout) {
        if (name === "return") continue;
        fullLayout.inputs.push({
          name,
          type: layout[name]
        });
      }
      layout = fullLayout;
    }
    this.shaderNode.setLayout(layout);
    return this;
  }
  getNodeType(builder) {
    return this.shaderNode.getNodeType(builder) || "float";
  }
  call(...params) {
    const fnCall = this.shaderNode.call(params);
    if (this.shaderNode.nodeType === "void") fnCall.toStack();
    return fnCall.toVarIntent();
  }
  once(subBuilds = null) {
    this.shaderNode.once = true;
    this.shaderNode.subBuilds = subBuilds;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    error('TSL: "Fn()" was declared but not invoked. Try calling it like "Fn()( ...params )".');
    return builder.generateConst(type);
  }
}
function Fn$4(jsFunc, layout = null) {
  const instance2 = new FnNode(jsFunc, layout);
  return new Proxy(() => {
  }, {
    apply(target, thisArg, params) {
      return instance2.call(...params);
    },
    get(target, prop, receiver) {
      return Reflect.get(instance2, prop, receiver);
    },
    set(target, prop, value, receiver) {
      return Reflect.set(instance2, prop, value, receiver);
    }
  });
}
const setCurrentStack$3 = (stack2) => {
  currentStack = stack2;
};
const getCurrentStack$3 = () => currentStack;
const If = (...params) => currentStack.If(...params);
const Switch = (...params) => currentStack.Switch(...params);
function Stack(node) {
  if (currentStack) currentStack.addToStack(node);
  return node;
}
addMethodChaining("toStack", Stack);
const color = new ConvertType("color");
const float$4 = new ConvertType("float", cacheMaps.float);
const int$3 = new ConvertType("int", cacheMaps.ints);
const uint$3 = new ConvertType("uint", cacheMaps.uint);
const bool = new ConvertType("bool", cacheMaps.bool);
const vec2$2 = new ConvertType("vec2");
const ivec2$2 = new ConvertType("ivec2");
const uvec2 = new ConvertType("uvec2");
const bvec2 = new ConvertType("bvec2");
const vec3$2 = new ConvertType("vec3");
const ivec3$3 = new ConvertType("ivec3");
const uvec3 = new ConvertType("uvec3");
const bvec3 = new ConvertType("bvec3");
const vec4$3 = new ConvertType("vec4");
const ivec4 = new ConvertType("ivec4");
const uvec4 = new ConvertType("uvec4");
const bvec4 = new ConvertType("bvec4");
const mat2 = new ConvertType("mat2");
const mat3 = new ConvertType("mat3");
const mat4 = new ConvertType("mat4");
const string = (value = "") => new ConstNode(value, "string");
const arrayBuffer = (value) => new ConstNode(value, "ArrayBuffer");
addMethodChaining("toColor", color);
addMethodChaining("toFloat", float$4);
addMethodChaining("toInt", int$3);
addMethodChaining("toUint", uint$3);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2$2);
addMethodChaining("toIVec2", ivec2$2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3$2);
addMethodChaining("toIVec3", ivec3$3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4$3);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
const element = /* @__PURE__ */ nodeProxy(ArrayElementNode).setParameterLength(2);
const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
const split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
const append = (node) => {
  warn("TSL: append() has been renamed to Stack().");
  return Stack(node);
};
addMethodChaining("append", (node) => {
  warn("TSL: .append() has been renamed to .toStack().");
  return Stack(node);
});
class PropertyNode extends Node {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
    this.global = true;
  }
  customCacheKey() {
    return hashString(this.type + ":" + (this.name || "") + ":" + (this.varying ? "1" : "0"));
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
}
const property = (type, name) => new PropertyNode(type, name);
const varyingProperty$1 = (type, name) => new PropertyNode(type, name, true);
const diffuseColor = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
const diffuseContribution = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "DiffuseContribution");
const emissive = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "EmissiveColor");
const roughness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Roughness");
const metalness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Metalness");
const clearcoat = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Clearcoat");
const clearcoatRoughness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
const sheen = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "Sheen");
const sheenRoughness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "SheenRoughness");
const iridescence = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Iridescence");
const iridescenceIOR = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "IridescenceIOR");
const iridescenceThickness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "IridescenceThickness");
const alphaT = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "AlphaT");
const anisotropy = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Anisotropy");
const anisotropyT = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
const anisotropyB = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
const specularColor = /* @__PURE__ */ nodeImmutable(PropertyNode, "color", "SpecularColor");
const specularColorBlended = /* @__PURE__ */ nodeImmutable(PropertyNode, "color", "SpecularColorBlended");
const specularF90 = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "SpecularF90");
const shininess = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Shininess");
const output = /* @__PURE__ */ nodeImmutable(PropertyNode, "vec4", "Output");
const dashSize = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "dashSize");
const gapSize = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "gapSize");
const pointWidth = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "pointWidth");
const ior = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "IOR");
const transmission = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Transmission");
const thickness = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Thickness");
const attenuationDistance = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "AttenuationDistance");
const attenuationColor = /* @__PURE__ */ nodeImmutable(PropertyNode, "color", "AttenuationColor");
const dispersion = /* @__PURE__ */ nodeImmutable(PropertyNode, "float", "Dispersion");
class UniformGroupNode extends Node {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
}
const uniformGroup = (name) => new UniformGroupNode(name);
const sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
const frameGroup = /* @__PURE__ */ sharedUniformGroup("frame");
const renderGroup = /* @__PURE__ */ sharedUniformGroup("render");
const objectGroup = /* @__PURE__ */ uniformGroup("object");
class UniformNode extends InputNode {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    callback = callback.bind(this);
    return super.onUpdate((frame) => {
      const value = callback(frame, this);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  getInputType(builder) {
    let type = super.getInputType(builder);
    if (type === "bool") {
      type = "uint";
    }
    return type;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash5 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash5);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash5);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName);
    const uniformName = builder.getPropertyName(nodeUniform);
    if (builder.context.nodeName !== void 0) delete builder.context.nodeName;
    let snippet = uniformName;
    if (type === "bool") {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const nodeVar = builder.getVarFromNode(this, null, "bool");
        propertyName = builder.getPropertyName(nodeVar);
        nodeData.propertyName = propertyName;
        snippet = builder.format(uniformName, sharedNodeType, type);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
      }
      snippet = propertyName;
    }
    return builder.format(snippet, type, output2);
  }
}
const uniform$2 = (value, type) => {
  const nodeType = getConstNodeType(type || value);
  if (nodeType === value) {
    value = getValueFromType(nodeType);
  }
  if (value && value.isNode === true) {
    let v = value.value;
    value.traverse((n) => {
      if (n.isConstNode === true) {
        v = n.value;
      }
    });
    value = v;
  }
  return new UniformNode(value, nodeType);
};
class ArrayNode extends TempNode {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(nodeType, count, values = null) {
    super(nodeType);
    this.count = count;
    this.values = values;
    this.isArrayNode = true;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The number of elements in the node array.
   */
  getArrayCount() {
    return this.count;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    if (this.nodeType === null) {
      return this.values[0].getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Returns the type of a member variable.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member variable.
   * @return {string} The type of the member variable.
   */
  getMemberType(builder, name) {
    if (this.nodeType === null) {
      return this.values[0].getMemberType(builder, name);
    }
    return super.getMemberType(builder, name);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(builder) {
    const type = this.getNodeType(builder);
    return builder.generateArray(type, this.count, this.values);
  }
}
const array = (...params) => {
  let node;
  if (params.length === 1) {
    const values = params[0];
    node = new ArrayNode(null, values.length, values);
  } else {
    const nodeType = params[0];
    const count = params[1];
    node = new ArrayNode(nodeType, count);
  }
  return nodeObject(node);
};
addMethodChaining("toArray", (node, count) => array(Array(count).fill(node)));
class AssignNode extends TempNode {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
    this.isAssignNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDifferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDifferentVector;
    }
    return false;
  }
  setup(builder) {
    const { targetNode, sourceNode } = this;
    const scope = targetNode.getScope();
    const scopeData = builder.getDataFromNode(scope);
    scopeData.assign = true;
    const properties = builder.getNodeProperties(this);
    properties.sourceNode = sourceNode;
    properties.targetNode = targetNode.context({ assign: true });
  }
  generate(builder, output2) {
    const { targetNode, sourceNode } = builder.getNodeProperties(this);
    const needsSplitAssign = this.needsSplitAssign(builder);
    const target = targetNode.build(builder);
    const targetType = targetNode.getNodeType(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output2 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const splitNode = targetNode.node;
      const splitTargetNode = splitNode.node.context({ assign: true });
      const targetRoot = splitTargetNode.build(builder);
      for (let i = 0; i < splitNode.components.length; i++) {
        const component = splitNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
      }
      if (output2 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output2 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output2 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output2);
  }
}
const assign = /* @__PURE__ */ nodeProxy(AssignNode).setParameterLength(2);
addMethodChaining("assign", assign);
class FunctionCallNode extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  /**
   * Returns the type of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @returns {string} The type of this node.
   */
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  /**
   * Returns the function node of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} [name] - The name of the member.
   * @returns {string} The type of the member.
   */
  getMemberType(builder, name) {
    return this.functionNode.getMemberType(builder, name);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output2;
      if (pointer) output2 = "&" + node.build(builder);
      else output2 = node.build(builder, type);
      return output2;
    };
    if (Array.isArray(parameters)) {
      if (parameters.length > inputs.length) {
        error("TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'.");
        parameters.length = inputs.length;
      } else if (parameters.length < inputs.length) {
        error("TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");
        while (parameters.length < inputs.length) {
          parameters.push(float$4(0));
        }
      }
      for (let i = 0; i < parameters.length; i++) {
        params.push(generateInput(parameters[i], inputs[i]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          error(`TSL: Input '${inputNode.name}' not found in 'Fn()'.`);
          params.push(generateInput(float$4(0), inputNode));
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
}
const call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return new FunctionCallNode(nodeObject(func), params);
};
addMethodChaining("call", call);
const _vectorOperators = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod"
};
class OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new OperatorNode(op, aNode, bNode);
      for (let i = 0; i < params.length - 1; i++) {
        finalOp = new OperatorNode(op, finalOp, params[i]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
    this.isOperatorNode = true;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(builder, output2) {
    return builder.getMethod(_vectorOperators[this.op], output2);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output=null] - The output type.
   * @return {string} The node type.
   */
  getNodeType(builder, output2 = null) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return output2 || "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          return typeA;
        } else if (builder.isVector(typeB)) {
          return builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) {
          return typeA;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          return typeB;
        } else if (builder.isVector(typeA)) {
          return builder.getVectorFromMatrix(typeB);
        }
      }
      if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const { aNode, bNode } = this;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==" || op === "!=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (builder.isVector(typeB)) {
          typeA = typeB;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (op === "%") {
        typeA = type;
        typeB = builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
      } else if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          typeB = "float";
        } else if (builder.isVector(typeB)) {
          typeB = builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) ;
        else {
          typeA = typeB = type;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          typeA = "float";
        } else if (builder.isVector(typeA)) {
          typeA = builder.getVectorFromMatrix(typeB);
        } else {
          typeA = typeB = type;
        }
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode ? bNode.build(builder, typeB) : null;
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output2 !== "void") {
      const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;
      if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (isGLSL) {
          if (builder.isVector(typeA)) {
            return builder.format(`${this.getOperatorMethod(builder, output2)}( ${a}, ${b} )`, type, output2);
          } else {
            return builder.format(`( ${a} ${op} ${b} )`, type, output2);
          }
        } else {
          return builder.format(`( ${a} ${op} ${b} )`, type, output2);
        }
      } else if (op === "%") {
        if (builder.isInteger(typeB)) {
          return builder.format(`( ${a} % ${b} )`, type, output2);
        } else {
          return builder.format(`${this.getOperatorMethod(builder, type)}( ${a}, ${b} )`, type, output2);
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output2);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`( ${b} ${op} ${a} )`, type, output2);
        } else if (typeA === "float" && builder.isMatrix(typeB)) {
          return builder.format(`${a} ${op} ${b}`, type, output2);
        } else {
          let snippet = `( ${a} ${op} ${b} )`;
          if (!isGLSL && type === "bool" && builder.isVector(typeA) && builder.isVector(typeB)) {
            snippet = `all${snippet}`;
          }
          return builder.format(snippet, type, output2);
        }
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`${b} ${op} ${a}`, type, output2);
        } else {
          return builder.format(`${a} ${op} ${b}`, type, output2);
        }
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
}
const add$3 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "+").setParameterLength(2, Infinity).setName("add");
const sub$3 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "-").setParameterLength(2, Infinity).setName("sub");
const mul$3 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "*").setParameterLength(2, Infinity).setName("mul");
const div$2 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "/").setParameterLength(2, Infinity).setName("div");
const mod = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "%").setParameterLength(2).setName("mod");
const equal = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "==").setParameterLength(2).setName("equal");
const notEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "!=").setParameterLength(2).setName("notEqual");
const lessThan = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<").setParameterLength(2).setName("lessThan");
const greaterThan = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">").setParameterLength(2).setName("greaterThan");
const lessThanEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<=").setParameterLength(2).setName("lessThanEqual");
const greaterThanEqual = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">=").setParameterLength(2).setName("greaterThanEqual");
const and = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "&&").setParameterLength(2, Infinity).setName("and");
const or = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "||").setParameterLength(2, Infinity).setName("or");
const not = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "!").setParameterLength(1).setName("not");
const xor = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "^^").setParameterLength(2).setName("xor");
const bitAnd$1 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "&").setParameterLength(2).setName("bitAnd");
const bitNot = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "~").setParameterLength(1).setName("bitNot");
const bitOr$1 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "|").setParameterLength(2).setName("bitOr");
const bitXor = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "^").setParameterLength(2).setName("bitXor");
const shiftLeft$1 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, "<<").setParameterLength(2).setName("shiftLeft");
const shiftRight$1 = /* @__PURE__ */ nodeProxyIntent(OperatorNode, ">>").setParameterLength(2).setName("shiftRight");
const incrementBefore = Fn$4(([a]) => {
  a.addAssign(1);
  return a;
});
const decrementBefore = Fn$4(([a]) => {
  a.subAssign(1);
  return a;
});
const increment = /* @__PURE__ */ Fn$4(([a]) => {
  const temp = int$3(a).toConst();
  a.addAssign(1);
  return temp;
});
const decrement = /* @__PURE__ */ Fn$4(([a]) => {
  const temp = int$3(a).toConst();
  a.subAssign(1);
  return temp;
});
addMethodChaining("add", add$3);
addMethodChaining("sub", sub$3);
addMethodChaining("mul", mul$3);
addMethodChaining("div", div$2);
addMethodChaining("mod", mod);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd$1);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr$1);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft$1);
addMethodChaining("shiftRight", shiftRight$1);
addMethodChaining("incrementBefore", incrementBefore);
addMethodChaining("decrementBefore", decrementBefore);
addMethodChaining("increment", increment);
addMethodChaining("decrement", decrement);
const modInt = (a, b) => {
  warn('TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.');
  return mod(int$3(a), int$3(b));
};
addMethodChaining("modInt", modInt);
class MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    if ((method === MathNode.MAX || method === MathNode.MIN) && arguments.length > 3) {
      let finalOp = new MathNode(method, aNode, bNode);
      for (let i = 2; i < arguments.length - 1; i++) {
        finalOp = new MathNode(method, finalOp, arguments[i]);
      }
      aNode = finalOp;
      bNode = arguments[arguments.length - 1];
      cNode = null;
    }
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
    this.isMathNode = true;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else if (method === MathNode.ALL || method === MathNode.ANY) {
      return "bool";
    } else if (method === MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else {
      return this.getInputType(builder);
    }
  }
  setup(builder) {
    const { aNode, bNode, method } = this;
    let outputNode = null;
    if (method === MathNode.ONE_MINUS) {
      outputNode = sub$3(1, aNode);
    } else if (method === MathNode.RECIPROCAL) {
      outputNode = div$2(1, aNode);
    } else if (method === MathNode.DIFFERENCE) {
      outputNode = abs$2(sub$3(aNode, bNode));
    } else if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = aNode;
      let tB = bNode;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4$3(vec3$2(tB), 0);
      } else {
        tA = vec4$3(vec3$2(tA), 0);
      }
      const mulNode = mul$3(tA, tB).xyz;
      outputNode = normalize$1(mulNode);
    }
    if (outputNode !== null) {
      return outputNode;
    } else {
      return super.setup(builder);
    }
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode) {
      return super.generate(builder, output2);
    }
    let method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const coordinateSystem = builder.renderer.coordinateSystem;
    if (method === MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output2);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX)) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        if (coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null) {
          method = "atan2";
        }
        if (builder.shaderStage !== "fragment" && (method === MathNode.DFDX || method === MathNode.DFDY)) {
          warn(`TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`);
          method = "/*" + method + "*/";
        }
        params.push(a.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c !== null) params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
}
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.DETERMINANT = "determinant";
MathNode.INVERSE = "inverse";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
const EPSILON = /* @__PURE__ */ float$4(1e-6);
const INFINITY = /* @__PURE__ */ float$4(1e6);
const PI$1 = /* @__PURE__ */ float$4(Math.PI);
const PI2 = /* @__PURE__ */ float$4(Math.PI * 2);
const TWO_PI = /* @__PURE__ */ float$4(Math.PI * 2);
const HALF_PI = /* @__PURE__ */ float$4(Math.PI * 0.5);
const all = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ALL).setParameterLength(1);
const any = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ANY).setParameterLength(1);
const radians = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.RADIANS).setParameterLength(1);
const degrees = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DEGREES).setParameterLength(1);
const exp$2 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.EXP).setParameterLength(1);
const exp2 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.EXP2).setParameterLength(1);
const log$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.LOG).setParameterLength(1);
const log2 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.LOG2).setParameterLength(1);
const sqrt$3 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.SQRT).setParameterLength(1);
const inverseSqrt = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.INVERSE_SQRT).setParameterLength(1);
const floor = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.FLOOR).setParameterLength(1);
const ceil = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.CEIL).setParameterLength(1);
const normalize$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.NORMALIZE).setParameterLength(1);
const fract = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.FRACT).setParameterLength(1);
const sin$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.SIN).setParameterLength(1);
const cos$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.COS).setParameterLength(1);
const tan = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.TAN).setParameterLength(1);
const asin = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ASIN).setParameterLength(1);
const acos = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ACOS).setParameterLength(1);
const atan = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ATAN).setParameterLength(1, 2);
const abs$2 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ABS).setParameterLength(1);
const sign = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.SIGN).setParameterLength(1);
const length = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.LENGTH).setParameterLength(1);
const negate = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.NEGATE).setParameterLength(1);
const oneMinus = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ONE_MINUS).setParameterLength(1);
const dFdx = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DFDX).setParameterLength(1);
const dFdy = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DFDY).setParameterLength(1);
const round = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.ROUND).setParameterLength(1);
const reciprocal = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.RECIPROCAL).setParameterLength(1);
const trunc = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.TRUNC).setParameterLength(1);
const fwidth = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.FWIDTH).setParameterLength(1);
const transpose = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.TRANSPOSE).setParameterLength(1);
const determinant = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DETERMINANT).setParameterLength(1);
const inverse = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.INVERSE).setParameterLength(1);
const equals = (x, y) => {
  warn('TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"');
  return equal(x, y);
};
const min$1$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.MIN).setParameterLength(2, Infinity);
const max$1$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.MAX).setParameterLength(2, Infinity);
const step = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.STEP).setParameterLength(2);
const reflect = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.REFLECT).setParameterLength(2);
const distance = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DISTANCE).setParameterLength(2);
const difference = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DIFFERENCE).setParameterLength(2);
const dot$3 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.DOT).setParameterLength(2);
const cross$1 = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.CROSS).setParameterLength(2);
const pow = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.POW).setParameterLength(2);
const pow2 = (x) => mul$3(x, x);
const pow3 = (x) => mul$3(x, x, x);
const pow4 = (x) => mul$3(x, x, x, x);
const transformDirection = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.TRANSFORM_DIRECTION).setParameterLength(2);
const cbrt = (a) => mul$3(sign(a), pow(abs$2(a), 1 / 3));
const lengthSq = (a) => dot$3(a, a);
const mix = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.MIX).setParameterLength(3);
const clamp$1 = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
const saturate = (value) => clamp$1(value);
const refract = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.REFRACT).setParameterLength(3);
const smoothstep = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.SMOOTHSTEP).setParameterLength(3);
const faceForward = /* @__PURE__ */ nodeProxyIntent(MathNode, MathNode.FACEFORWARD).setParameterLength(3);
const rand = /* @__PURE__ */ Fn$4(([uv2]) => {
  const a = 12.9898, b = 78.233, c = 43758.5453;
  const dt = dot$3(uv2.xy, vec2$2(a, b)), sn = mod(dt, PI$1);
  return fract(sin$1(sn).mul(c));
});
const mixElement = (t, e1, e2) => mix(e1, e2, t);
const smoothstepElement = (x, low, high) => smoothstep(low, high, x);
const stepElement = (x, edge) => step(edge, x);
const atan2 = (y, x) => {
  warn('TSL: "atan2" is overloaded. Use "atan" instead.');
  return atan(y, x);
};
const faceforward = faceForward;
const inversesqrt = inverseSqrt;
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals);
addMethodChaining("radians", radians);
addMethodChaining("degrees", degrees);
addMethodChaining("exp", exp$2);
addMethodChaining("exp2", exp2);
addMethodChaining("log", log$1);
addMethodChaining("log2", log2);
addMethodChaining("sqrt", sqrt$3);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil);
addMethodChaining("normalize", normalize$1);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin$1);
addMethodChaining("cos", cos$1);
addMethodChaining("tan", tan);
addMethodChaining("asin", asin);
addMethodChaining("acos", acos);
addMethodChaining("atan", atan);
addMethodChaining("abs", abs$2);
addMethodChaining("sign", sign);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan2);
addMethodChaining("min", min$1$1);
addMethodChaining("max", max$1$1);
addMethodChaining("step", stepElement);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance);
addMethodChaining("dot", dot$3);
addMethodChaining("cross", cross$1);
addMethodChaining("pow", pow);
addMethodChaining("pow2", pow2);
addMethodChaining("pow3", pow3);
addMethodChaining("pow4", pow4);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp$1);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference);
addMethodChaining("saturate", saturate);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose);
addMethodChaining("determinant", determinant);
addMethodChaining("inverse", inverse);
addMethodChaining("rand", rand);
class ConditionalNode extends Node {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { ifNode, elseNode } = builder.getNodeProperties(this);
    if (ifNode === void 0) {
      builder.flowBuildStage(this, "setup");
      return this.getNodeType(builder);
    }
    const ifType = ifNode.getNodeType(builder);
    if (elseNode !== null) {
      const elseType = elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode;
    const ifNode = this.ifNode.isolate();
    const elseNode = this.elseNode ? this.elseNode.isolate() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const isUniformFlow = builder.context.uniformFlow;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = isUniformFlow ? ifNode : ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode ? isUniformFlow ? elseNode : elseNode.context({ nodeBlock: elseNode }) : null;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const functionNode = builder.currentFunctionNode;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    const isUniformFlow = builder.context.uniformFlow;
    if (isUniformFlow && elseNode !== null) {
      const ifSnippet2 = ifNode.build(builder, type);
      const elseSnippet = elseNode.build(builder, type);
      const mathSnippet = builder.getTernary(nodeSnippet, ifSnippet2, elseSnippet);
      return builder.format(mathSnippet, type, output2);
    }
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
        if (functionNode === null) {
          warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
          ifSnippet = "// " + ifSnippet;
        }
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
          if (functionNode === null) {
            warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
            elseSnippet = "// " + elseSnippet;
          }
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
}
const select$3 = /* @__PURE__ */ nodeProxy(ConditionalNode).setParameterLength(2, 3);
addMethodChaining("select", select$3);
class ContextNode extends Node {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(node = null, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * Gathers the context data from all parent context nodes.
   *
   * @return {Object} The gathered context data.
   */
  getFlowContextData() {
    const children = [];
    this.traverse((node) => {
      if (node.isContextNode === true) {
        children.push(node.value);
      }
    });
    return Object.assign({}, ...children);
  }
  /**
   * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @returns {string} The member type.
   */
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  analyze(builder) {
    const previousContext = builder.addContext(this.value);
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  setup(builder) {
    const previousContext = builder.addContext(this.value);
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  generate(builder, output2) {
    const previousContext = builder.addContext(this.value);
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
}
const context = (nodeOrValue = null, value = {}) => {
  let node = nodeOrValue;
  if (node === null || node.isNode !== true) {
    value = node || value;
    node = null;
  }
  return new ContextNode(node, value);
};
const uniformFlow = (node) => context(node, { uniformFlow: true });
const setName = (node, name) => context(node, { nodeName: name });
function builtinShadowContext(shadowNode, light, node = null) {
  return context(node, {
    getShadow: ({ light: shadowLight, shadowColorNode }) => {
      if (light === shadowLight) {
        return shadowColorNode.mul(shadowNode);
      }
      return shadowColorNode;
    }
  });
}
function builtinAOContext(aoNode, node = null) {
  return context(node, {
    getAO: (inputNode, { material }) => {
      if (material.transparent === true) return inputNode;
      return inputNode !== null ? inputNode.mul(aoNode) : aoNode;
    }
  });
}
function label(node, name) {
  warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
  return setName(node, name);
}
addMethodChaining("context", context);
addMethodChaining("label", label);
addMethodChaining("uniformFlow", uniformFlow);
addMethodChaining("setName", setName);
addMethodChaining("builtinShadowContext", (node, shadowNode, light) => builtinShadowContext(shadowNode, light, node));
addMethodChaining("builtinAOContext", (node, aoValue) => builtinAOContext(aoValue, node));
class VarNode extends Node {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(node, name = null, readOnly = false) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
    this.readOnly = readOnly;
    this.parents = true;
    this.intent = false;
  }
  /**
   * Sets the intent flag for this node.
   *
   * This flag is used to indicate that this node is used for intent
   * and should not be built directly. Instead, it is used to indicate that
   * the node should be treated as a variable intent.
   *
   * It's useful for assigning variables without needing creating a new variable node.
   *
   * @param {boolean} value - The value to set for the intent flag.
   * @returns {VarNode} This node.
   */
  setIntent(value) {
    this.intent = value;
    return this;
  }
  /**
   * Checks if this node is used for intent.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {boolean} Whether this node is used for intent.
   */
  isIntent(builder) {
    const data = builder.getDataFromNode(this);
    if (data.forceDeclaration === true) return false;
    return this.intent;
  }
  /**
   * Returns the intent flag of this node.
   *
   * @return {boolean} The intent flag.
   */
  getIntent() {
    return this.intent;
  }
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  getElementType(builder) {
    return this.node.getElementType(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  getArrayCount(builder) {
    return this.node.getArrayCount(builder);
  }
  isAssign(builder) {
    const data = builder.getDataFromNode(this);
    return data.assign;
  }
  build(...params) {
    const builder = params[0];
    if (this._hasStack(builder) === false && builder.buildStage === "setup") {
      if (builder.context.nodeLoop || builder.context.nodeBlock) {
        let addBefore = false;
        if (this.node.isShaderCallNodeInternal && this.node.shaderNode.getLayout() === null) {
          if (builder.fnCall && builder.fnCall.shaderNode) {
            const shaderNodeData = builder.getDataFromNode(this.node.shaderNode);
            if (shaderNodeData.hasLoop) {
              const data = builder.getDataFromNode(this);
              data.forceDeclaration = true;
              addBefore = true;
            }
          }
        }
        const baseStack = builder.getBaseStack();
        if (addBefore) {
          baseStack.addToStackBefore(this);
        } else {
          baseStack.addToStack(this);
        }
      }
    }
    if (this.isIntent(builder)) {
      if (this.isAssign(builder) !== true) {
        return this.node.build(...params);
      }
    }
    return super.build(...params);
  }
  generate(builder) {
    const { node, name, readOnly } = this;
    const { renderer } = builder;
    const isWebGPUBackend = renderer.backend.isWebGPUBackend === true;
    let isDeterministic = false;
    let shouldTreatAsReadOnly = false;
    if (readOnly) {
      isDeterministic = builder.isDeterministic(node);
      shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
    }
    const nodeType = this.getNodeType(builder);
    if (nodeType == "void") {
      if (this.isIntent(builder) !== true) {
        error('TSL: ".toVar()" can not be used with void type.');
      }
      const snippet2 = node.build(builder);
      return snippet2;
    }
    const vectorType = builder.getVectorType(nodeType);
    const snippet = node.build(builder, vectorType);
    const nodeVar = builder.getVarFromNode(this, name, vectorType, void 0, shouldTreatAsReadOnly);
    const propertyName = builder.getPropertyName(nodeVar);
    let declarationPrefix = propertyName;
    if (shouldTreatAsReadOnly) {
      if (isWebGPUBackend) {
        declarationPrefix = isDeterministic ? `const ${propertyName}` : `let ${propertyName}`;
      } else {
        const count = node.getArrayCount(builder);
        declarationPrefix = `const ${builder.getVar(nodeVar.type, propertyName, count)}`;
      }
    }
    builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
    return propertyName;
  }
  _hasStack(builder) {
    const nodeData = builder.getDataFromNode(this);
    return nodeData.stack !== void 0;
  }
}
const createVar = /* @__PURE__ */ nodeProxy(VarNode);
const Var = (node, name = null) => createVar(node, name).toStack();
const Const = (node, name = null) => createVar(node, name, true).toStack();
const VarIntent = (node) => {
  return createVar(node).setIntent(true).toStack();
};
addMethodChaining("toVar", Var);
addMethodChaining("toConst", Const);
addMethodChaining("toVarIntent", VarIntent);
class SubBuildNode extends Node {
  static get type() {
    return "SubBuild";
  }
  constructor(node, name, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
    this.isSubBuildNode = true;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) return this.nodeType;
    builder.addSubBuild(this.name);
    const nodeType = this.node.getNodeType(builder);
    builder.removeSubBuild();
    return nodeType;
  }
  build(builder, ...params) {
    builder.addSubBuild(this.name);
    const data = this.node.build(builder, ...params);
    builder.removeSubBuild();
    return data;
  }
}
const subBuild = (node, name, type = null) => nodeObject(new SubBuildNode(nodeObject(node), name, type));
class VaryingNode extends Node {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
    this.interpolationType = null;
    this.interpolationSampling = null;
    this.global = true;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(type, sampling = null) {
    this.interpolationType = type;
    this.interpolationSampling = sampling;
    return this;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      const interpolationType = this.interpolationType;
      const interpolationSampling = this.interpolationSampling;
      properties.varying = varying2 = builder.getVaryingFromNode(this, name, type, interpolationType, interpolationSampling);
      properties.node = subBuild(this.node, "VERTEX");
    }
    varying2.needsInterpolation || (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  analyze(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  generate(builder) {
    const propertyKey = builder.getSubBuildProperty("property", builder.currentStack);
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    if (properties[propertyKey] === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying2, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, properties.node, type, propertyName);
      properties[propertyKey] = propertyName;
    }
    return builder.getPropertyName(varying2);
  }
}
const varying = /* @__PURE__ */ nodeProxy(VaryingNode).setParameterLength(1, 2);
const vertexStage = (node) => varying(node);
addMethodChaining("toVarying", varying);
addMethodChaining("toVertexStage", vertexStage);
addMethodChaining("varying", (...params) => {
  warn("TSL: .varying() has been renamed to .toVarying().");
  return varying(...params);
});
addMethodChaining("vertexStage", (...params) => {
  warn("TSL: .vertexStage() has been renamed to .toVertexStage().");
  return varying(...params);
});
const sRGBTransferEOTF = /* @__PURE__ */ Fn$4(([color2]) => {
  const a = color2.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color2.mul(0.0773993808);
  const factor = color2.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
const sRGBTransferOETF = /* @__PURE__ */ Fn$4(([color2]) => {
  const a = color2.pow(0.41666).mul(1.055).sub(0.055);
  const b = color2.mul(12.92);
  const factor = color2.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
const WORKING_COLOR_SPACE = "WorkingColorSpace";
const OUTPUT_COLOR_SPACE = "OutputColorSpace";
class ColorSpaceNode extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (ColorManagement.enabled === false || source === target || !source || !target) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4$3(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
      outputNode = vec4$3(
        mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4$3(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
}
const workingToColorSpace = (node, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, targetColorSpace));
const colorSpaceToWorking = (node, sourceColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, WORKING_COLOR_SPACE));
const convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
class ReferenceBaseNode extends Node {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(group) {
    this.group = group;
    return this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return new ReferenceElementNode$1(this, nodeObject(indexNode));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    const node = uniform$2(null, uniformType);
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
}
class RendererReferenceNode extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(property2, inputType, renderer = null) {
    super(property2, inputType, renderer);
    this.renderer = renderer;
    this.setGroup(renderGroup);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
}
const rendererReference = (name, type, renderer = null) => new RendererReferenceNode(name, type, renderer);
class ToneMappingNode extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(toneMapping2, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this._toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return hash$1(this._toneMapping);
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(value) {
    this._toneMapping = value;
    return this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this._toneMapping;
    if (toneMapping2 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping2);
    if (toneMappingFn !== null) {
      outputNode = vec4$3(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
    } else {
      error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
}
const toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
const toneMappingExposure = /* @__PURE__ */ rendererReference("toneMappingExposure", "float");
addMethodChaining("toneMapping", (color2, mapping, exposure) => toneMapping(mapping, exposure, color2));
const _bufferLib = /* @__PURE__ */ new WeakMap();
function _getBufferAttribute(value, itemSize) {
  let buffer2 = _bufferLib.get(value);
  if (buffer2 === void 0) {
    buffer2 = new InterleavedBuffer(value, itemSize);
    _bufferLib.set(value, buffer2);
  }
  return buffer2;
}
class BufferAttributeNode extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true && value.itemSize <= 4) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const itemSize = builder.getTypeLength(type);
    const value = this.value;
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    let buffer2;
    if (value.isInterleavedBuffer === true) {
      buffer2 = value;
    } else if (value.isBufferAttribute === true) {
      buffer2 = _getBufferAttribute(value.array, stride);
    } else {
      buffer2 = _getBufferAttribute(value, stride);
    }
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output2 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
}
function createBufferAttribute(array2, type = null, stride = 0, offset = 0, usage = StaticDrawUsage, instanced = false) {
  if (type === "mat3" || type === null && array2.itemSize === 9) {
    return mat3(
      new BufferAttributeNode(array2, "vec3", 9, 0).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array2, "vec3", 9, 3).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array2, "vec3", 9, 6).setUsage(usage).setInstanced(instanced)
    );
  } else if (type === "mat4" || type === null && array2.itemSize === 16) {
    return mat4(
      new BufferAttributeNode(array2, "vec4", 16, 0).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array2, "vec4", 16, 4).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array2, "vec4", 16, 8).setUsage(usage).setInstanced(instanced),
      new BufferAttributeNode(array2, "vec4", 16, 12).setUsage(usage).setInstanced(instanced)
    );
  }
  return new BufferAttributeNode(array2, type, stride, offset);
}
const bufferAttribute = (array2, type = null, stride = 0, offset = 0) => createBufferAttribute(array2, type, stride, offset);
const dynamicBufferAttribute = (array2, type = null, stride = 0, offset = 0) => createBufferAttribute(array2, type, stride, offset, DynamicDrawUsage);
const instancedBufferAttribute = (array2, type = null, stride = 0, offset = 0) => createBufferAttribute(array2, type, stride, offset, StaticDrawUsage, true);
const instancedDynamicBufferAttribute = (array2, type = null, stride = 0, offset = 0) => createBufferAttribute(array2, type, stride, offset, DynamicDrawUsage, true);
addMethodChaining("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
class ComputeNode extends Node {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Array<number>} workgroupSize - TODO.
   */
  constructor(computeNode, workgroupSize) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.workgroupSize = workgroupSize;
    this.count = null;
    this.version = 1;
    this.name = "";
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
  }
  /**
   * TODO
   *
   * @param {number|Array<number>} count - Array with [ x, y, z ] values for dispatch or a single number for the count
   * @return {ComputeNode}
   */
  setCount(count) {
    this.count = count;
    return this;
  }
  /**
   * TODO
   *
   * @return {number|Array<number>}
   */
  getCount() {
    return this.count;
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  setup(builder) {
    const result = this.computeNode.build(builder);
    if (result) {
      const properties = builder.getNodeProperties(this);
      properties.outputComputeNode = result.outputNode;
      result.outputNode = null;
    }
    return result;
  }
  generate(builder, output2) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    } else {
      const properties = builder.getNodeProperties(this);
      const outputComputeNode = properties.outputComputeNode;
      if (outputComputeNode) {
        return outputComputeNode.build(builder, output2);
      }
    }
  }
}
const computeKernel = (node, workgroupSize = [64]) => {
  if (workgroupSize.length === 0 || workgroupSize.length > 3) {
    error("TSL: compute() workgroupSize must have 1, 2, or 3 elements");
  }
  for (let i = 0; i < workgroupSize.length; i++) {
    const val = workgroupSize[i];
    if (typeof val !== "number" || val <= 0 || !Number.isInteger(val)) {
      error(`TSL: compute() workgroupSize element at index [ ${i} ] must be a positive integer`);
    }
  }
  while (workgroupSize.length < 3) workgroupSize.push(1);
  return nodeObject(new ComputeNode(nodeObject(node), workgroupSize));
};
const compute = (node, count, workgroupSize) => computeKernel(node, workgroupSize).setCount(count);
addMethodChaining("compute", compute);
addMethodChaining("computeKernel", computeKernel);
class IsolateNode extends Node {
  static get type() {
    return "IsolateNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(node, parent = true) {
    super();
    this.node = node;
    this.parent = parent;
    this.isIsolateNode = true;
  }
  getNodeType(builder) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const nodeType = this.node.getNodeType(builder);
    builder.setCache(previousCache);
    return nodeType;
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
  setParent(parent) {
    this.parent = parent;
    return this;
  }
  getParent() {
    return this.parent;
  }
}
const isolate = (node) => new IsolateNode(nodeObject(node));
function cache(node, parent = true) {
  warn('TSL: "cache()" has been deprecated. Use "isolate()" instead.');
  return isolate(node).setParent(parent);
}
addMethodChaining("cache", cache);
addMethodChaining("isolate", isolate);
class BypassNode extends Node {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(outputNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = outputNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
}
const bypass = /* @__PURE__ */ nodeProxy(BypassNode).setParameterLength(2);
addMethodChaining("bypass", bypass);
class RemapNode extends Node {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(node, inLowNode, inHighNode, outLowNode = float$4(0), outHighNode = float$4(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
}
const remap = /* @__PURE__ */ nodeProxy(RemapNode, null, null, { doClamp: false }).setParameterLength(3, 5);
const remapClamp = /* @__PURE__ */ nodeProxy(RemapNode).setParameterLength(3, 5);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
class ExpressionNode extends Node {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(snippet, type, output2);
    }
  }
}
const expression = /* @__PURE__ */ nodeProxy(ExpressionNode).setParameterLength(1, 2);
const Discard$1 = (conditional) => (conditional ? select$3(conditional, expression("discard")) : expression("discard")).toStack();
const Return = () => expression("return").toStack();
addMethodChaining("discard", Discard$1);
class RenderOutputNode extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(colorNode, toneMapping2, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this._toneMapping = toneMapping2;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutputNode = true;
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(value) {
    this._toneMapping = value;
    return this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup({ context: context2 }) {
    let outputNode = this.colorNode || context2.color;
    const toneMapping2 = (this._toneMapping !== null ? this._toneMapping : context2.toneMapping) || NoToneMapping;
    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context2.outputColorSpace) || NoColorSpace;
    if (toneMapping2 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping2);
    }
    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
}
const renderOutput = (color2, toneMapping2 = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color2), toneMapping2, outputColorSpace));
addMethodChaining("renderOutput", renderOutput);
class DebugNode extends TempNode {
  static get type() {
    return "DebugNode";
  }
  constructor(node, callback = null) {
    super();
    this.node = node;
    this.callback = callback;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup(builder) {
    return this.node.build(builder);
  }
  analyze(builder) {
    return this.node.build(builder);
  }
  generate(builder) {
    const callback = this.callback;
    const snippet = this.node.build(builder);
    const title = "--- TSL debug - " + builder.shaderStage + " shader ---";
    const border = "-".repeat(title.length);
    let code2 = "";
    code2 += "// #" + title + "#\n";
    code2 += builder.flow.code.replace(/^\t/mg, "") + "\n";
    code2 += "/* ... */ " + snippet + " /* ... */\n";
    code2 += "// #" + border + "#\n";
    if (callback !== null) {
      callback(builder, code2);
    } else {
      log$2(code2);
    }
    return snippet;
  }
}
const debug = (node, callback = null) => nodeObject(new DebugNode(nodeObject(node), callback)).toStack();
addMethodChaining("debug", debug);
class InspectorBase {
  /**
   * Creates a new InspectorBase.
   */
  constructor() {
    this._renderer = null;
    this.currentFrame = null;
  }
  /**
   * Returns the node frame for the current renderer.
   *
   * @return {Object} The node frame.
   */
  get nodeFrame() {
    return this._renderer._nodes.nodeFrame;
  }
  /**
   * Sets the renderer for this inspector.
   *
   * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
   * @return {InspectorBase} This inspector instance.
   */
  setRenderer(renderer) {
    this._renderer = renderer;
    return this;
  }
  /**
   * Returns the renderer associated with this inspector.
   *
   * @return {WebGLRenderer} The associated renderer.
   */
  getRenderer() {
    return this._renderer;
  }
  /**
   * Initializes the inspector.
   */
  init() {
  }
  /**
   * Called when a frame begins.
   */
  begin() {
  }
  /**
   * Called when a frame ends.
   */
  finish() {
  }
  /**
   * Inspects a node.
   *
   * @param {Node} node - The node to inspect.
   */
  inspect() {
  }
  /**
   * When a compute operation is performed.
   *
   * @param {ComputeNode} computeNode - The compute node being executed.
   * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
   */
  computeAsync() {
  }
  /**
   * Called when a compute operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  beginCompute() {
  }
  /**
   * Called when a compute operation ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  finishCompute() {
  }
  /**
   * Called when a render operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {Scene} scene - The scene being rendered.
   * @param {Camera} camera - The camera being used for rendering.
   * @param {?WebGLRenderTarget} renderTarget - The render target, if any.
   */
  beginRender() {
  }
  /**
   * Called when an animation loop ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  finishRender() {
  }
  /**
   * Called when a texture copy operation is performed.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   */
  copyTextureToTexture() {
  }
  /**
   * Called when a framebuffer copy operation is performed.
   *
   * @param {Texture} framebufferTexture - The texture associated with the framebuffer.
   */
  copyFramebufferToTexture() {
  }
}
class InspectorNode extends Node {
  /**
   * Returns the type of the node.
   *
   * @returns {string}
   */
  static get type() {
    return "InspectorNode";
  }
  /**
   * Creates an InspectorNode.
   *
   * @param {Node} node - The node to inspect.
   * @param {string} [name=''] - Optional name for the inspector node.
   * @param {Function|null} [callback=null] - Optional callback to modify the node during setup.
   */
  constructor(node, name = "", callback = null) {
    super();
    this.node = node;
    this.name = name;
    this.callback = callback;
    this.updateType = NodeUpdateType.FRAME;
    this.isInspectorNode = true;
  }
  /**
   * Returns the name of the inspector node.
   *
   * @returns {string}
   */
  getName() {
    return this.name || this.node.name;
  }
  /**
   * Updates the inspector node, allowing inspection of the wrapped node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    frame.renderer.inspector.inspect(this);
  }
  /**
   * Returns the type of the wrapped node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {string}
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * Sets up the inspector node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {Node} The setup node.
   */
  setup(builder) {
    let node = this.node;
    if (builder.context.inspector === true && this.callback !== null) {
      node = this.callback(node);
    }
    if (builder.renderer.backend.isWebGPUBackend !== true && builder.renderer.inspector.constructor !== InspectorBase) {
      warnOnce('TSL: ".toInspector()" is only available with WebGPU.');
    }
    return node;
  }
}
function inspector(node, name = "", callback = null) {
  node = nodeObject(node);
  return node.before(new InspectorNode(node, name, callback));
}
addMethodChaining("toInspector", inspector);
function addNodeElement(name) {
  warn("TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add", name);
}
class AttributeNode extends Node {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this.global = true;
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = this.nodeType;
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._attributeName = this._attributeName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._attributeName = data._attributeName;
  }
}
const attribute$1 = (name, nodeType = null) => new AttributeNode(name, nodeType);
const uv$1 = (index = 0) => attribute$1("uv" + (index > 0 ? index : ""), "vec2");
class TextureSizeNode extends Node {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const level = this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output2);
  }
}
const textureSize = /* @__PURE__ */ nodeProxy(TextureSizeNode).setParameterLength(1, 2);
class MaxMipLevelNode extends UniformNode {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(textureNode) {
    super(0);
    this._textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
}
const maxMipLevel = /* @__PURE__ */ nodeProxy(MaxMipLevelNode).setParameterLength(1);
const EmptyTexture$1 = /* @__PURE__ */ new Texture2();
class TextureNode extends UniformNode {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.biasNode = biasNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.offsetNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this._matrixUniform = null;
    this._flipYUniform = null;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    if (this.value.type === UnsignedIntType) {
      return "uvec4";
    } else if (this.value.type === IntType) {
      return "ivec4";
    }
    return "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return uv$1(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(uvNode) {
    if (this._matrixUniform === null) this._matrixUniform = uniform$2(this.value.matrix);
    return this._matrixUniform.mul(vec3$2(uvNode, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    return this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    if (builder.isFlipY()) {
      if (this._flipYUniform === null) this._flipYUniform = uniform$2(false);
      uvNode = uvNode.toVar();
      if (this.sampler) {
        uvNode = this._flipYUniform.select(uvNode.flipY(), uvNode);
      } else {
        uvNode = this._flipYUniform.select(uvNode.setY(int$3(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1)), uvNode);
      }
    }
    return uvNode;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    properties.referenceNode = this.referenceNode;
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
    }
    const uvNode = Fn$4(() => {
      let uvNode2 = this.uvNode;
      if ((uvNode2 === null || builder.context.forceUVContext === true) && builder.context.getUV) {
        uvNode2 = builder.context.getUV(this, builder);
      }
      if (!uvNode2) uvNode2 = this.getDefaultUV();
      if (this.updateMatrix === true) {
        uvNode2 = this.getTransformedUV(uvNode2);
      }
      uvNode2 = this.setupUV(builder, uvNode2);
      this.updateType = this._matrixUniform !== null || this._flipYUniform !== null ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
      return uvNode2;
    })();
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.biasNode = this.biasNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
    properties.offsetNode = this.offsetNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @param {?string} offsetSnippet - The offset snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet) {
    const texture2 = this.value;
    let snippet;
    if (biasSnippet) {
      snippet = builder.generateTextureBias(texture2, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
    } else if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
    } else {
      snippet = builder.generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, offsetSnippet);
    }
    return snippet;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    const texture2 = this.value;
    const properties = builder.getNodeProperties(this);
    const textureProperty = super.generate(builder, "property");
    if (/^sampler/.test(output2)) {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode, offsetNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const offsetSnippet = offsetNode ? this.generateOffset(builder, offsetNode) : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);
        nodeData.snippet = snippet2;
        nodeData.propertyName = propertyName;
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsToWorkingColorSpace(texture2)) {
        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture2.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(uvNode) {
    warn("TextureNode: .uv() has been renamed. Use .sample() instead.");
    return this.sample(uvNode);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = nodeObject(uvNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @param {Node<uvec2>} uvNode - The uv node.
   * @returns {TextureNode} A texture node representing the texture load.
   */
  load(uvNode) {
    return this.sample(uvNode).setSampler(false);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(amountNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this.getBase();
    const map = textureNode.value;
    if (textureNode.generateMipmaps === false && (map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter)) {
      warn("TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.");
      textureNode.biasNode = null;
    }
    return nodeObject(textureNode);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = nodeObject(levelNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(biasNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(biasNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the base texture of this node.
   * @return {TextureNode} The base texture node.
   */
  getBase() {
    return this.referenceNode ? this.referenceNode.getBase() : this;
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining an offset node.
   *
   * @param {Node<ivec2>} offsetNode - The offset node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  offset(offsetNode) {
    const textureNode = this.clone();
    textureNode.offsetNode = nodeObject(offsetNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
    data.sampler = this.sampler;
    data.updateMatrix = this.updateMatrix;
    data.updateType = this.updateType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
    this.sampler = data.sampler;
    this.updateMatrix = data.updateMatrix;
    this.updateType = data.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const texture2 = this.value;
    const matrixUniform = this._matrixUniform;
    if (matrixUniform !== null) matrixUniform.value = texture2.matrix;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
    const flipYUniform = this._flipYUniform;
    if (flipYUniform !== null) {
      flipYUniform.value = texture2.image instanceof ImageBitmap && texture2.flipY === true || texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true || texture2.isDepthTexture === true;
    }
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    return newNode;
  }
}
const textureBase = /* @__PURE__ */ nodeProxy(TextureNode).setParameterLength(1, 4).setName("texture");
const texture$2 = (value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value.getBase();
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = textureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
const uniformTexture = (value = EmptyTexture$1) => texture$2(value);
const textureLoad$2 = (...params) => texture$2(...params).setSampler(false);
const textureLevel = (value, uv2, level) => texture$2(value, uv2).level(level);
const sampler = (value) => (value.isNode === true ? value : texture$2(value)).convert("sampler");
const samplerComparison = (value) => (value.isNode === true ? value : texture$2(value)).convert("samplerComparison");
class BufferNode extends UniformNode {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.updateRanges = [];
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
}
const buffer = (value, type, count) => new BufferNode(value, type, count);
class UniformArrayElementNode extends ArrayElementNode {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(uniformArrayNode, indexNode) {
    super(uniformArrayNode, indexNode);
    this.isArrayBufferElementNode = true;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    const paddedType = this.node.getPaddedType();
    return builder.format(snippet, paddedType, type);
  }
}
class UniformArrayNode extends BufferNode {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(value, elementType = null) {
    super(null);
    this.array = value;
    this.elementType = elementType === null ? getValueType(value[0]) : elementType;
    this.paddedType = this.getPaddedType();
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const elementType = this.elementType;
    let paddedType = "vec4";
    if (elementType === "mat2") {
      paddedType = "mat2";
    } else if (/mat/.test(elementType) === true) {
      paddedType = "mat4";
    } else if (elementType.charAt(0) === "i") {
      paddedType = "ivec4";
    } else if (elementType.charAt(0) === "u") {
      paddedType = "uvec4";
    }
    return paddedType;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: array2, value } = this;
    const elementType = this.elementType;
    if (elementType === "float" || elementType === "int" || elementType === "uint") {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 4;
        value[index] = array2[i];
      }
    } else if (elementType === "color") {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 4;
        const vector = array2[i];
        value[index] = vector.r;
        value[index + 1] = vector.g;
        value[index + 2] = vector.b || 0;
      }
    } else if (elementType === "mat2") {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 4;
        const matrix = array2[i];
        value[index] = matrix.elements[0];
        value[index + 1] = matrix.elements[1];
        value[index + 2] = matrix.elements[2];
        value[index + 3] = matrix.elements[3];
      }
    } else if (elementType === "mat3") {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 16;
        const matrix = array2[i];
        value[index] = matrix.elements[0];
        value[index + 1] = matrix.elements[1];
        value[index + 2] = matrix.elements[2];
        value[index + 4] = matrix.elements[3];
        value[index + 5] = matrix.elements[4];
        value[index + 6] = matrix.elements[5];
        value[index + 8] = matrix.elements[6];
        value[index + 9] = matrix.elements[7];
        value[index + 10] = matrix.elements[8];
        value[index + 15] = 1;
      }
    } else if (elementType === "mat4") {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 16;
        const matrix = array2[i];
        for (let i2 = 0; i2 < matrix.elements.length; i2++) {
          value[index + i2] = matrix.elements[i2];
        }
      }
    } else {
      for (let i = 0; i < array2.length; i++) {
        const index = i * 4;
        const vector = array2[i];
        value[index] = vector.x;
        value[index + 1] = vector.y;
        value[index + 2] = vector.z || 0;
        value[index + 3] = vector.w || 0;
      }
    }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(builder) {
    const length2 = this.array.length;
    const elementType = this.elementType;
    let arrayType = Float32Array;
    const paddedType = this.paddedType;
    const paddedElementLength = builder.getTypeLength(paddedType);
    if (elementType.charAt(0) === "i") arrayType = Int32Array;
    if (elementType.charAt(0) === "u") arrayType = Uint32Array;
    this.value = new arrayType(length2 * paddedElementLength);
    this.bufferCount = length2;
    this.bufferType = paddedType;
    return super.setup(builder);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(indexNode) {
    return new UniformArrayElementNode(this, nodeObject(indexNode));
  }
}
const uniformArray = (values, nodeType) => new UniformArrayNode(values, nodeType);
class BuiltinNode extends Node {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(name) {
    super("float");
    this.name = name;
    this.isBuiltinNode = true;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
}
const builtin = nodeProxy(BuiltinNode).setParameterLength(1);
let _screenSizeVec, _viewportVec;
class ScreenNode extends Node {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.
   */
  constructor(scope) {
    super();
    this.scope = scope;
    this._output = null;
    this.isViewportNode = true;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('float'|'vec2'|'vec4')} The node type.
   */
  getNodeType() {
    if (this.scope === ScreenNode.DPR) return "float";
    if (this.scope === ScreenNode.VIEWPORT) return "vec4";
    else return "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT || this.scope === ScreenNode.DPR) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer }) {
    const renderTarget = renderer.getRenderTarget();
    if (this.scope === ScreenNode.VIEWPORT) {
      if (renderTarget !== null) {
        _viewportVec.copy(renderTarget.viewport);
      } else {
        renderer.getViewport(_viewportVec);
        _viewportVec.multiplyScalar(renderer.getPixelRatio());
      }
    } else if (this.scope === ScreenNode.DPR) {
      this._output.value = renderer.getPixelRatio();
    } else {
      if (renderTarget !== null) {
        _screenSizeVec.width = renderTarget.width;
        _screenSizeVec.height = renderTarget.height;
      } else {
        renderer.getDrawingBufferSize(_screenSizeVec);
      }
    }
  }
  setup() {
    const scope = this.scope;
    let output2 = null;
    if (scope === ScreenNode.SIZE) {
      output2 = uniform$2(_screenSizeVec || (_screenSizeVec = new Vector2()));
    } else if (scope === ScreenNode.VIEWPORT) {
      output2 = uniform$2(_viewportVec || (_viewportVec = new Vector4()));
    } else if (scope === ScreenNode.DPR) {
      output2 = uniform$2(1);
    } else {
      output2 = vec2$2(screenCoordinate.div(screenSize));
    }
    this._output = output2;
    return output2;
  }
  generate(builder) {
    if (this.scope === ScreenNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);
        coord = `${builder.getType("vec2")}( ${coord}.x, ${size}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
}
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
ScreenNode.DPR = "dpr";
const screenDPR = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.DPR);
const screenUV = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.UV);
const screenSize = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.SIZE);
const screenCoordinate = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.COORDINATE);
const viewport = /* @__PURE__ */ nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
const viewportSize = viewport.zw;
const viewportCoordinate = /* @__PURE__ */ screenCoordinate.sub(viewport.xy);
const viewportUV = /* @__PURE__ */ viewportCoordinate.div(viewportSize);
const viewportResolution = /* @__PURE__ */ Fn$4(() => {
  warn('TSL: "viewportResolution" is deprecated. Use "screenSize" instead.');
  return screenSize;
}, "vec2").once()();
const cameraIndex = /* @__PURE__ */ uniform$2(0, "uint").setName("u_cameraIndex").setGroup(sharedUniformGroup("cameraIndex")).toVarying("v_cameraIndex");
const cameraNear = /* @__PURE__ */ uniform$2("float").setName("cameraNear").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.near);
const cameraFar = /* @__PURE__ */ uniform$2("float").setName("cameraFar").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.far);
const cameraProjectionMatrix = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraProjectionMatrix2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.projectionMatrix);
    }
    const cameraProjectionMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatrices");
    cameraProjectionMatrix2 = cameraProjectionMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrix");
  } else {
    cameraProjectionMatrix2 = uniform$2("mat4").setName("cameraProjectionMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.projectionMatrix);
  }
  return cameraProjectionMatrix2;
}).once()();
const cameraProjectionMatrixInverse = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraProjectionMatrixInverse2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.projectionMatrixInverse);
    }
    const cameraProjectionMatricesInverse = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatricesInverse");
    cameraProjectionMatrixInverse2 = cameraProjectionMatricesInverse.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrixInverse");
  } else {
    cameraProjectionMatrixInverse2 = uniform$2("mat4").setName("cameraProjectionMatrixInverse").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.projectionMatrixInverse);
  }
  return cameraProjectionMatrixInverse2;
}).once()();
const cameraViewMatrix = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraViewMatrix2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.matrixWorldInverse);
    }
    const cameraViewMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraViewMatrices");
    cameraViewMatrix2 = cameraViewMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraViewMatrix");
  } else {
    cameraViewMatrix2 = uniform$2("mat4").setName("cameraViewMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.matrixWorldInverse);
  }
  return cameraViewMatrix2;
}).once()();
const cameraWorldMatrix = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraWorldMatrix2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.matrixWorld);
    }
    const cameraWorldMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraWorldMatrices");
    cameraWorldMatrix2 = cameraWorldMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraWorldMatrix");
  } else {
    cameraWorldMatrix2 = uniform$2("mat4").setName("cameraWorldMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.matrixWorld);
  }
  return cameraWorldMatrix2;
}).once()();
const cameraNormalMatrix = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraNormalMatrix2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.normalMatrix);
    }
    const cameraNormalMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraNormalMatrices");
    cameraNormalMatrix2 = cameraNormalMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraNormalMatrix");
  } else {
    cameraNormalMatrix2 = uniform$2("mat3").setName("cameraNormalMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.normalMatrix);
  }
  return cameraNormalMatrix2;
}).once()();
const cameraPosition = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraPosition2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const positions = [];
    for (let i = 0, l = camera.cameras.length; i < l; i++) {
      positions.push(new Vector3());
    }
    const cameraPositions = uniformArray(positions).setGroup(renderGroup).setName("cameraPositions").onRenderUpdate(({ camera: camera2 }, self2) => {
      const subCameras = camera2.cameras;
      const array2 = self2.array;
      for (let i = 0, l = subCameras.length; i < l; i++) {
        array2[i].setFromMatrixPosition(subCameras[i].matrixWorld);
      }
    });
    cameraPosition2 = cameraPositions.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraPosition");
  } else {
    cameraPosition2 = uniform$2(new Vector3()).setName("cameraPosition").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }, self2) => self2.value.setFromMatrixPosition(camera2.matrixWorld));
  }
  return cameraPosition2;
}).once()();
const cameraViewport = /* @__PURE__ */ Fn$4(({ camera }) => {
  let cameraViewport2;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const viewports = [];
    for (const subCamera of camera.cameras) {
      viewports.push(subCamera.viewport);
    }
    const cameraViewports = uniformArray(viewports, "vec4").setGroup(renderGroup).setName("cameraViewports");
    cameraViewport2 = cameraViewports.element(cameraIndex).toConst("cameraViewport");
  } else {
    cameraViewport2 = vec4$3(0, 0, screenSize.x, screenSize.y).toConst("cameraViewport");
  }
  return cameraViewport2;
}).once()();
const _sphere = /* @__PURE__ */ new Sphere();
class Object3DNode extends Node {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(scope, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this.uniformNode = new UniformNode(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {('mat4'|'vec3'|'float')} The node type.
   */
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      return "mat4";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
      return "vec3";
    } else if (scope === Object3DNode.RADIUS) {
      return "float";
    }
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const object = this.object3d;
    const uniformNode = this.uniformNode;
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    } else if (scope === Object3DNode.RADIUS) {
      const geometry = frame.object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      uniformNode.value = _sphere.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX) {
      this.uniformNode.nodeType = "mat4";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
      this.uniformNode.nodeType = "vec3";
    } else if (scope === Object3DNode.RADIUS) {
      this.uniformNode.nodeType = "float";
    }
    return this.uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
}
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
Object3DNode.RADIUS = "radius";
const objectDirection = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.DIRECTION).setParameterLength(1);
const objectWorldMatrix = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX).setParameterLength(1);
const objectPosition = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.POSITION).setParameterLength(1);
const objectScale = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.SCALE).setParameterLength(1);
const objectViewPosition = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION).setParameterLength(1);
const objectRadius = /* @__PURE__ */ nodeProxy(Object3DNode, Object3DNode.RADIUS).setParameterLength(1);
class ModelNode extends Object3DNode {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(scope) {
    super(scope);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
}
const modelDirection = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.DIRECTION);
const modelWorldMatrix = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
const modelPosition = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.POSITION);
const modelScale = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.SCALE);
const modelViewPosition = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
const modelRadius = /* @__PURE__ */ nodeImmutable(ModelNode, ModelNode.RADIUS);
const modelNormalMatrix = /* @__PURE__ */ uniform$2(new Matrix3()).onObjectUpdate(({ object }, self2) => self2.value.getNormalMatrix(object.matrixWorld));
const modelWorldMatrixInverse = /* @__PURE__ */ uniform$2(new Matrix4()).onObjectUpdate(({ object }, self2) => self2.value.copy(object.matrixWorld).invert());
const modelViewMatrix = /* @__PURE__ */ Fn$4((builder) => {
  return builder.context.modelViewMatrix || mediumpModelViewMatrix;
}).once()().toVar("modelViewMatrix");
const mediumpModelViewMatrix = /* @__PURE__ */ cameraViewMatrix.mul(modelWorldMatrix);
const highpModelViewMatrix = /* @__PURE__ */ Fn$4((builder) => {
  builder.context.isHighPrecisionModelViewMatrix = true;
  return uniform$2("mat4").onObjectUpdate(({ object, camera }) => {
    return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
  });
}).once()().toVar("highpModelViewMatrix");
const highpModelNormalViewMatrix = /* @__PURE__ */ Fn$4((builder) => {
  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
  return uniform$2("mat3").onObjectUpdate(({ object, camera }) => {
    if (isHighPrecisionModelViewMatrix !== true) {
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    }
    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
  });
}).once()().toVar("highpModelNormalViewMatrix");
const positionGeometry = /* @__PURE__ */ attribute$1("position", "vec3");
const positionLocal$1 = /* @__PURE__ */ positionGeometry.toVarying("positionLocal");
const positionPrevious = /* @__PURE__ */ positionGeometry.toVarying("positionPrevious");
const positionWorld = /* @__PURE__ */ Fn$4((builder) => {
  return modelWorldMatrix.mul(positionLocal$1).xyz.toVarying(builder.getSubBuildProperty("v_positionWorld"));
}, "vec3").once(["POSITION"])();
const positionWorldDirection = /* @__PURE__ */ Fn$4(() => {
  const vertexPWD = positionLocal$1.transformDirection(modelWorldMatrix).toVarying("v_positionWorldDirection");
  return vertexPWD.normalize().toVar("positionWorldDirection");
}, "vec3").once(["POSITION"])();
const positionView = /* @__PURE__ */ Fn$4((builder) => {
  return builder.context.setupPositionView().toVarying("v_positionView");
}, "vec3").once(["POSITION"])();
const positionViewDirection = /* @__PURE__ */ Fn$4((builder) => {
  let output2;
  if (builder.camera.isOrthographicCamera) {
    output2 = vec3$2(0, 0, 1);
  } else {
    output2 = positionView.negate().toVarying("v_positionViewDirection").normalize();
  }
  return output2.toVar("positionViewDirection");
}, "vec3").once(["POSITION"])();
class FrontFacingNode extends Node {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    if (builder.shaderStage !== "fragment") return "true";
    const { material } = builder;
    if (material.side === BackSide) {
      return "false";
    }
    return builder.getFrontFacing();
  }
}
const frontFacing = /* @__PURE__ */ nodeImmutable(FrontFacingNode);
const faceDirection = /* @__PURE__ */ float$4(frontFacing).mul(2).sub(1);
const directionToFaceDirection = /* @__PURE__ */ Fn$4(([direction], { material }) => {
  const side = material.side;
  if (side === BackSide) {
    direction = direction.mul(-1);
  } else if (side === DoubleSide) {
    direction = direction.mul(faceDirection);
  }
  return direction;
});
const normalGeometry = /* @__PURE__ */ attribute$1("normal", "vec3");
const normalLocal = /* @__PURE__ */ Fn$4((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    warn('TSL: Vertex attribute "normal" not found on geometry.');
    return vec3$2(0, 1, 0);
  }
  return normalGeometry;
}, "vec3").once()().toVar("normalLocal");
const normalFlat = /* @__PURE__ */ positionView.dFdx().cross(positionView.dFdy()).normalize().toVar("normalFlat");
const normalViewGeometry = /* @__PURE__ */ Fn$4((builder) => {
  let node;
  if (builder.material.flatShading === true) {
    node = normalFlat;
  } else {
    node = transformNormalToView(normalLocal).toVarying("v_normalViewGeometry").normalize();
  }
  return node;
}, "vec3").once()().toVar("normalViewGeometry");
const normalWorldGeometry = /* @__PURE__ */ Fn$4((builder) => {
  let normal2 = normalViewGeometry.transformDirection(cameraViewMatrix);
  if (builder.material.flatShading !== true) {
    normal2 = normal2.toVarying("v_normalWorldGeometry");
  }
  return normal2.normalize().toVar("normalWorldGeometry");
}, "vec3").once()();
const normalView = /* @__PURE__ */ Fn$4(({ subBuildFn, material, context: context2 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalViewGeometry;
    if (material.flatShading !== true) {
      node = directionToFaceDirection(node);
    }
  } else {
    node = context2.setupNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("normalView");
const normalWorld = /* @__PURE__ */ normalView.transformDirection(cameraViewMatrix).toVar("normalWorld");
const clearcoatNormalView = /* @__PURE__ */ Fn$4(({ subBuildFn, context: context2 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalView;
  } else {
    node = context2.setupClearcoatNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("clearcoatNormalView");
const transformNormal = /* @__PURE__ */ Fn$4(([normal2, matrix = modelWorldMatrix]) => {
  const m = mat3(matrix);
  const transformedNormal = normal2.div(vec3$2(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
  return m.mul(transformedNormal).xyz;
});
const transformNormalToView = /* @__PURE__ */ Fn$4(([normal2], builder) => {
  const modelNormalViewMatrix = builder.context.modelNormalViewMatrix;
  if (modelNormalViewMatrix) {
    return modelNormalViewMatrix.transformDirection(normal2);
  }
  const transformedNormal = modelNormalMatrix.mul(normal2);
  return cameraViewMatrix.transformDirection(transformedNormal);
});
const transformedNormalView = Fn$4(() => {
  warn('TSL: "transformedNormalView" is deprecated. Use "normalView" instead.');
  return normalView;
}).once(["NORMAL", "VERTEX"])();
const transformedNormalWorld = Fn$4(() => {
  warn('TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.');
  return normalWorld;
}).once(["NORMAL", "VERTEX"])();
const transformedClearcoatNormalView = Fn$4(() => {
  warn('TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.');
  return clearcoatNormalView;
}).once(["NORMAL", "VERTEX"])();
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const materialRefractionRatio = /* @__PURE__ */ uniform$2(0).onReference(({ material }) => material).onObjectUpdate(({ material }) => material.refractionRatio);
const materialEnvIntensity = /* @__PURE__ */ uniform$2(1).onReference(({ material }) => material).onObjectUpdate(function({ material, scene }) {
  return material.envMap ? material.envMapIntensity : scene.environmentIntensity;
});
const materialEnvRotation = /* @__PURE__ */ uniform$2(new Matrix4()).onReference(function(frame) {
  return frame.material;
}).onObjectUpdate(function({ material, scene }) {
  const rotation = scene.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
  if (rotation) {
    _e1$1.copy(rotation);
    _m1$1.makeRotationFromEuler(_e1$1);
  } else {
    _m1$1.identity();
  }
  return _m1$1;
});
const reflectView = /* @__PURE__ */ positionViewDirection.negate().reflect(normalView);
const refractView = /* @__PURE__ */ positionViewDirection.negate().refract(normalView, materialRefractionRatio);
const reflectVector = /* @__PURE__ */ reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");
const refractVector = /* @__PURE__ */ refractView.transformDirection(cameraViewMatrix).toVar("reflectVector");
const EmptyTexture = /* @__PURE__ */ new CubeTexture();
class CubeTextureNode extends TextureNode {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value, uvNode, levelNode, biasNode);
    this.isCubeTextureNode = true;
  }
  /**
   * Overwrites the default implementation to return the appropriate cube texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    if (this.value.isDepthTexture === true) {
      return "cubeDepthTexture";
    }
    return "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const texture2 = this.value;
    if (texture2.mapping === CubeReflectionMapping) {
      return reflectVector;
    } else if (texture2.mapping === CubeRefractionMapping) {
      return refractVector;
    } else {
      error('CubeTextureNode: Mapping "%s" not supported.', texture2.mapping);
      return vec3$2(0, 0, 0);
    }
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (texture2.isDepthTexture === true) {
      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
        return vec3$2(uvNode.x, uvNode.y.negate(), uvNode.z);
      }
      return uvNode;
    }
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture2.isRenderTargetTexture) {
      uvNode = vec3$2(uvNode.x.negate(), uvNode.yz);
    }
    return materialEnvRotation.mul(uvNode);
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, this.sampler === true ? "vec3" : "ivec3");
  }
}
const cubeTextureBase = /* @__PURE__ */ nodeProxy(CubeTextureNode).setParameterLength(1, 4).setName("cubeTexture");
const cubeTexture = (value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isCubeTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value;
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = cubeTextureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
const uniformCubeTexture = (value = EmptyTexture) => cubeTextureBase(value);
class ReferenceElementNode2 extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
}
class ReferenceNode extends Node {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.name = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return new ReferenceElementNode2(this, nodeObject(indexNode));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(group) {
    this.group = group;
    return this;
  }
  /**
   * Sets the name for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @deprecated
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniformArray(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture$2(null);
    } else if (uniformType === "cubeTexture") {
      node = cubeTexture(null);
    } else {
      node = uniform$2(null, uniformType);
    }
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    if (this.name !== null) node.setName(this.name);
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
}
const reference = (name, type, object) => new ReferenceNode(name, type, object);
const referenceBuffer = (name, type, count, object) => new ReferenceNode(name, type, object, count);
class MaterialReferenceNode extends ReferenceNode {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
    this.isMaterialReferenceNode = true;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
}
const materialReference = (name, type, material = null) => new MaterialReferenceNode(name, type, material);
const uv = uv$1();
const q0 = positionView.dFdx();
const q1 = positionView.dFdy();
const st0 = uv.dFdx();
const st1 = uv.dFdy();
const N = normalView;
const q1perp = q1.cross(N);
const q0perp = N.cross(q0);
const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
const det = T.dot(T).max(B.dot(B));
const scale$1 = det.equal(0).select(0, det.inverseSqrt());
const tangentViewFrame = /* @__PURE__ */ T.mul(scale$1).toVar("tangentViewFrame");
const bitangentViewFrame = /* @__PURE__ */ B.mul(scale$1).toVar("bitangentViewFrame");
const tangentGeometry = /* @__PURE__ */ attribute$1("tangent", "vec4");
const tangentLocal = /* @__PURE__ */ tangentGeometry.xyz.toVar("tangentLocal");
const tangentView = /* @__PURE__ */ Fn$4(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = modelViewMatrix.mul(vec4$3(tangentLocal, 0)).xyz.toVarying("v_tangentView").normalize();
  } else {
    node = tangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("tangentView");
const tangentWorld = /* @__PURE__ */ tangentView.transformDirection(cameraViewMatrix).toVarying("v_tangentWorld").normalize().toVar("tangentWorld");
const getBitangent = /* @__PURE__ */ Fn$4(([crossNormalTangent, varyingName], { subBuildFn, material }) => {
  let bitangent = crossNormalTangent.mul(tangentGeometry.w).xyz;
  if (subBuildFn === "NORMAL" && material.flatShading !== true) {
    bitangent = bitangent.toVarying(varyingName);
  }
  return bitangent;
}).once(["NORMAL"]);
const bitangentGeometry = /* @__PURE__ */ getBitangent(normalGeometry.cross(tangentGeometry), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
const bitangentLocal = /* @__PURE__ */ getBitangent(normalLocal.cross(tangentLocal), "v_bitangentLocal").normalize().toVar("bitangentLocal");
const bitangentView = /* @__PURE__ */ Fn$4(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = getBitangent(normalView.cross(tangentView), "v_bitangentView").normalize();
  } else {
    node = bitangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("bitangentView");
const bitangentWorld = /* @__PURE__ */ getBitangent(normalWorld.cross(tangentWorld), "v_bitangentWorld").normalize().toVar("bitangentWorld");
const TBNViewMatrix = /* @__PURE__ */ mat3(tangentView, bitangentView, normalView).toVar("TBNViewMatrix");
const parallaxDirection = /* @__PURE__ */ positionViewDirection.mul(TBNViewMatrix);
const parallaxUV = (uv2, scale) => uv2.sub(parallaxDirection.mul(scale));
const bentNormalView = /* @__PURE__ */ Fn$4(() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix(bentNormal, normalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
}).once()();
const directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
const colorToDirection = (node) => nodeObject(node).mul(2).sub(1);
const unpackNormal = (xy) => vec3$2(xy, sqrt$3(saturate(float$4(1).sub(dot$3(xy, xy)))));
class NormalMapNode extends TempNode {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
    this.unpackNormalMode = NoNormalPacking;
  }
  setup({ material }) {
    const { normalMapType, scaleNode, unpackNormalMode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (normalMapType === TangentSpaceNormalMap) {
      if (unpackNormalMode === NormalRGPacking) {
        normalMap2 = unpackNormal(normalMap2.xy);
      } else if (unpackNormalMode === NormalGAPacking) {
        normalMap2 = unpackNormal(normalMap2.yw);
      } else if (unpackNormalMode !== NoNormalPacking) {
        console.error(`THREE.NodeMaterial: Unexpected unpack normal mode: ${unpackNormalMode}`);
      }
    } else {
      if (unpackNormalMode !== NoNormalPacking) {
        console.error(`THREE.NodeMaterial: Normal map type '${normalMapType}' is not compatible with unpack normal mode '${unpackNormalMode}'`);
      }
    }
    if (scaleNode !== null) {
      let scale = scaleNode;
      if (material.flatShading === true) {
        scale = directionToFaceDirection(scale);
      }
      normalMap2 = vec3$2(normalMap2.xy.mul(scale), normalMap2.z);
    }
    let output2 = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      output2 = transformNormalToView(normalMap2);
    } else if (normalMapType === TangentSpaceNormalMap) {
      output2 = TBNViewMatrix.mul(normalMap2).normalize();
    } else {
      error(`NodeMaterial: Unsupported normal map type: ${normalMapType}`);
      output2 = normalView;
    }
    return output2;
  }
}
const normalMap = /* @__PURE__ */ nodeProxy(NormalMapNode).setParameterLength(1, 2);
const dHdxy_fwd = Fn$4(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.isolate().context({ getUV: (texNode) => callback(texNode.uvNode || uv$1()), forceUVContext: true });
  const Hll = float$4(sampleTexture((uvNode) => uvNode));
  return vec2$2(
    float$4(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float$4(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
const perturbNormalArb = Fn$4((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
class BumpMapNode extends TempNode {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
}
const bumpMap = /* @__PURE__ */ nodeProxy(BumpMapNode).setParameterLength(1, 2);
const _propertyCache = /* @__PURE__ */ new Map();
class MaterialNode extends Node {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(property2, type) {
    let node = _propertyCache.get(property2);
    if (node === void 0) {
      node = materialReference(property2, type);
      _propertyCache.set(property2, node);
    }
    return node;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(property2) {
    return this.getCache(property2, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(property2) {
    return this.getCache(property2, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(property2) {
    return this.getCache(property2 === "map" ? "map" : property2 + "Map", "texture");
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.COLOR) {
      const colorNode = material.color !== void 0 ? this.getColor(scope) : vec3$2();
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float$4(1);
      }
    } else if (scope === MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensityNode = this.getFloat(scope);
      if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {
        node = specularIntensityNode.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensityNode;
      }
    } else if (scope === MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === MaterialNode.EMISSIVE) {
      const emissiveIntensityNode = this.getFloat("emissiveIntensity");
      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(this.getTexture("normal"), this.getCache("normalScale", "vec2"));
        node.normalMapType = material.normalMapType;
        if (material.normalMap.format == RGFormat || material.normalMap.format == RED_GREEN_RGTC2_Format || material.normalMap.format == RG11_EAC_Format) {
          node.unpackNormalMode = NormalRGPacking;
        }
      } else if (material.bumpMap) {
        node = bumpMap(this.getTexture("bump").r, this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = normalMap(this.getTexture(scope), this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(1e-4, 1);
    } else if (scope === MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2$2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else if (scope === MaterialNode.LIGHT_MAP) {
      node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
    } else if (scope === MaterialNode.AO) {
      node = this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    } else if (scope === MaterialNode.LINE_DASH_OFFSET) {
      node = material.dashOffset ? this.getFloat(scope) : float$4(0);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
}
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_SIZE = "size";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO = "ao";
const materialAlphaTest = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
const materialColor = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.COLOR);
const materialShininess = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SHININESS);
const materialEmissive = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
const materialOpacity = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.OPACITY);
const materialSpecular = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
const materialSpecularIntensity = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
const materialSpecularColor = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
const materialSpecularStrength = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
const materialReflectivity = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
const materialRoughness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
const materialMetalness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.METALNESS);
const materialNormal = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.NORMAL);
const materialClearcoat = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
const materialClearcoatRoughness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
const materialClearcoatNormal = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
const materialRotation = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ROTATION);
const materialSheen = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SHEEN);
const materialSheenRoughness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
const materialAnisotropy = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
const materialIridescence = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
const materialIridescenceIOR = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
const materialIridescenceThickness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
const materialTransmission = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
const materialThickness = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
const materialIOR = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.IOR);
const materialAttenuationDistance = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
const materialAttenuationColor = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
const materialLineScale = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
const materialLineDashSize = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
const materialLineGapSize = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
const materialLineWidth = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
const materialLineDashOffset = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
const materialPointSize = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.POINT_SIZE);
const materialDispersion = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
const materialLightMap = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);
const materialAO = /* @__PURE__ */ nodeImmutable(MaterialNode, MaterialNode.AO);
const materialAnisotropyVector = /* @__PURE__ */ uniform$2(new Vector2()).onReference(function(frame) {
  return frame.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
const modelViewProjection = /* @__PURE__ */ Fn$4((builder) => {
  return builder.context.setupModelViewProjection();
}, "vec4").once()().toVarying("v_modelViewProjection");
class StorageArrayElementNode extends ArrayElementNode {
  static get type() {
    return "StorageArrayElementNode";
  }
  /**
   * Constructs storage buffer element node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  /**
   * The storage buffer node.
   *
   * @param {Node} value
   * @type {StorageBufferNode}
   */
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  getMemberType(builder, name) {
    const structTypeNode = this.storageBufferNode.structTypeNode;
    if (structTypeNode) {
      return structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== "compute")) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = this.node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
}
const storageElement = /* @__PURE__ */ nodeProxy(StorageArrayElementNode).setParameterLength(2);
class StorageBufferNode extends BufferNode {
  static get type() {
    return "StorageBufferNode";
  }
  /**
   * Constructs a new storage buffer node.
   *
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferCount=0] - The buffer count.
   */
  constructor(value, bufferType = null, bufferCount = 0) {
    let nodeType, structTypeNode = null;
    if (bufferType && bufferType.isStruct) {
      nodeType = "struct";
      structTypeNode = bufferType.layout;
      if (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute) {
        bufferCount = value.count;
      }
    } else if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
      nodeType = getTypeFromLength(value.itemSize);
      bufferCount = value.count;
    } else {
      nodeType = bufferType;
    }
    super(value, nodeType, bufferCount);
    this.isStorageBufferNode = true;
    this.structTypeNode = structTypeNode;
    this.access = NodeAccess.READ_WRITE;
    this.isAtomic = false;
    this.isPBO = false;
    this._attribute = null;
    this._varying = null;
    this.global = true;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  /**
   * This method is overwritten since the buffer data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferCount === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
  }
  /**
   * Enables element access with the given index node.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {StorageArrayElementNode} A node representing the element access.
   */
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  /**
   * Defines whether this node is a PBO or not. Only relevant for WebGL.
   *
   * @param {boolean} value - The value so set.
   * @return {StorageBufferNode} A reference to this node.
   */
  setPBO(value) {
    this.isPBO = value;
    return this;
  }
  /**
   * Returns the `isPBO` value.
   *
   * @return {boolean} Whether the node represents a PBO or not.
   */
  getPBO() {
    return this.isPBO;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Defines whether the node is atomic or not.
   *
   * @param {boolean} value - The atomic flag.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAtomic(value) {
    this.isAtomic = value;
    return this;
  }
  /**
   * Convenience method for making this node atomic.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toAtomic() {
    return this.setAtomic(true);
  }
  /**
   * Returns attribute data for this storage buffer node.
   *
   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
   */
  getAttributeData() {
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    return {
      attribute: this._attribute,
      varying: this._varying
    };
  }
  /**
   * This method is overwritten since the node type from the availability of storage buffers
   * and the attribute data.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getNodeType(builder);
    }
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.getNodeType(builder);
    }
    const { attribute: attribute2 } = this.getAttributeData();
    return attribute2.getNodeType(builder);
  }
  /**
   * Returns the type of a member of the struct.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  /**
   * Generates the code snippet of the storage buffer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    if (this.structTypeNode !== null) this.structTypeNode.build(builder);
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.generate(builder);
    }
    const { attribute: attribute2, varying: varying2 } = this.getAttributeData();
    const output2 = varying2.build(builder);
    builder.registerTransform(output2, attribute2);
    return output2;
  }
}
const storage = (value, type = null, count = 0) => new StorageBufferNode(value, type, count);
const storageObject = (value, type, count) => {
  warn('TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
  return storage(value, type, count).setPBO(true);
};
class IndexNode extends Node {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationGlobal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else if (scope === IndexNode.DRAW) {
      propertyName = builder.getDrawIndex();
    } else if (scope === IndexNode.INVOCATION_LOCAL) {
      propertyName = builder.getInvocationLocalIndex();
    } else if (scope === IndexNode.INVOCATION_SUBGROUP) {
      propertyName = builder.getInvocationSubgroupIndex();
    } else if (scope === IndexNode.SUBGROUP) {
      propertyName = builder.getSubgroupIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
}
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
const vertexIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.VERTEX);
const instanceIndex$2 = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.INSTANCE);
const subgroupIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.SUBGROUP);
const invocationSubgroupIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);
const invocationLocalIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);
const drawIndex = /* @__PURE__ */ nodeImmutable(IndexNode, IndexNode.DRAW);
class InstanceNode extends Node {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(count, instanceMatrix, instanceColor = null) {
    super("void");
    this.count = count;
    this.instanceMatrix = instanceMatrix;
    this.instanceColor = instanceColor;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
    this.updateType = NodeUpdateType.FRAME;
    this.buffer = null;
    this.bufferColor = null;
  }
  /**
   * Tracks whether the matrix data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageMatrix() {
    const { instanceMatrix } = this;
    return instanceMatrix && instanceMatrix.isStorageInstancedBufferAttribute === true;
  }
  /**
   * Tracks whether the color data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageColor() {
    const { instanceColor } = this;
    return instanceColor && instanceColor.isStorageInstancedBufferAttribute === true;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { instanceMatrix, instanceColor, isStorageMatrix, isStorageColor } = this;
    const { count } = instanceMatrix;
    let { instanceMatrixNode, instanceColorNode } = this;
    if (instanceMatrixNode === null) {
      if (isStorageMatrix) {
        instanceMatrixNode = storage(instanceMatrix, "mat4", Math.max(count, 1)).element(instanceIndex$2);
      } else {
        if (count <= 1e3) {
          instanceMatrixNode = buffer(instanceMatrix.array, "mat4", Math.max(count, 1)).element(instanceIndex$2);
        } else {
          const interleaved = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
          this.buffer = interleaved;
          const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
          const instanceBuffers = [
            bufferFn(interleaved, "vec4", 16, 0),
            bufferFn(interleaved, "vec4", 16, 4),
            bufferFn(interleaved, "vec4", 16, 8),
            bufferFn(interleaved, "vec4", 16, 12)
          ];
          instanceMatrixNode = mat4(...instanceBuffers);
        }
      }
      this.instanceMatrixNode = instanceMatrixNode;
    }
    if (instanceColor && instanceColorNode === null) {
      if (isStorageColor) {
        instanceColorNode = storage(instanceColor, "vec3", Math.max(instanceColor.count, 1)).element(instanceIndex$2);
      } else {
        const bufferAttribute2 = new InstancedBufferAttribute(instanceColor.array, 3);
        const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
        this.bufferColor = bufferAttribute2;
        instanceColorNode = vec3$2(bufferFn(bufferAttribute2, "vec3", 3, 0));
      }
      this.instanceColorNode = instanceColorNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal$1).xyz;
    positionLocal$1.assign(instancePosition);
    if (builder.hasGeometryAttribute("normal")) {
      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
      normalLocal.assign(instanceNormal);
    }
    if (this.instanceColorNode !== null) {
      varyingProperty$1("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
  /**
   * Checks if the internal buffers require an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    if (this.buffer !== null && this.isStorageMatrix !== true) {
      this.buffer.clearUpdateRanges();
      this.buffer.updateRanges.push(...this.instanceMatrix.updateRanges);
      if (this.instanceMatrix.usage !== DynamicDrawUsage && this.instanceMatrix.version !== this.buffer.version) {
        this.buffer.version = this.instanceMatrix.version;
      }
    }
    if (this.instanceColor && this.bufferColor !== null && this.isStorageColor !== true) {
      this.bufferColor.clearUpdateRanges();
      this.bufferColor.updateRanges.push(...this.instanceColor.updateRanges);
      if (this.instanceColor.usage !== DynamicDrawUsage && this.instanceColor.version !== this.bufferColor.version) {
        this.bufferColor.version = this.instanceColor.version;
      }
    }
  }
}
const instance = /* @__PURE__ */ nodeProxy(InstanceNode).setParameterLength(2, 3);
class InstancedMeshNode extends InstanceNode {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(instancedMesh2) {
    const { count, instanceMatrix, instanceColor } = instancedMesh2;
    super(count, instanceMatrix, instanceColor);
    this.instancedMesh = instancedMesh2;
  }
}
const instancedMesh = /* @__PURE__ */ nodeProxy(InstancedMeshNode).setParameterLength(1);
class BatchNode extends Node {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.batchingIdNode === null) {
      if (builder.getDrawIndex() === null) {
        this.batchingIdNode = instanceIndex$2;
      } else {
        this.batchingIdNode = drawIndex;
      }
    }
    const getIndirectIndex = Fn$4(([id]) => {
      const size2 = int$3(textureSize(textureLoad$2(this.batchMesh._indirectTexture), 0).x).toConst();
      const x2 = int$3(id).mod(size2).toConst();
      const y2 = int$3(id).div(size2).toConst();
      return textureLoad$2(this.batchMesh._indirectTexture, ivec2$2(x2, y2)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    });
    const indirectId = getIndirectIndex(int$3(this.batchingIdNode));
    const matricesTexture = this.batchMesh._matricesTexture;
    const size = int$3(textureSize(textureLoad$2(matricesTexture), 0).x).toConst();
    const j = float$4(indirectId).mul(4).toInt().toConst();
    const x = j.mod(size).toConst();
    const y = j.div(size).toConst();
    const batchingMatrix = mat4(
      textureLoad$2(matricesTexture, ivec2$2(x, y)),
      textureLoad$2(matricesTexture, ivec2$2(x.add(1), y)),
      textureLoad$2(matricesTexture, ivec2$2(x.add(2), y)),
      textureLoad$2(matricesTexture, ivec2$2(x.add(3), y))
    );
    const colorsTexture = this.batchMesh._colorsTexture;
    if (colorsTexture !== null) {
      const getBatchingColor = Fn$4(([id]) => {
        const size2 = int$3(textureSize(textureLoad$2(colorsTexture), 0).x).toConst();
        const j2 = id;
        const x2 = j2.mod(size2).toConst();
        const y2 = j2.div(size2).toConst();
        return textureLoad$2(colorsTexture, ivec2$2(x2, y2)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      });
      const color2 = getBatchingColor(indirectId);
      varyingProperty$1("vec3", "vBatchColor").assign(color2);
    }
    const bm = mat3(batchingMatrix);
    positionLocal$1.assign(batchingMatrix.mul(positionLocal$1));
    const transformedNormal = normalLocal.div(vec3$2(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
}
const batch = /* @__PURE__ */ nodeProxy(BatchNode).setParameterLength(1);
const _frameId = /* @__PURE__ */ new WeakMap();
class SkinningNode extends Node {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute$1("skinIndex", "uvec4");
    this.skinWeightNode = attribute$1("skinWeight", "vec4");
    this.bindMatrixNode = reference("bindMatrix", "mat4");
    this.bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
    this.boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    this.positionNode = positionLocal$1;
    this.toPositionNode = positionLocal$1;
    this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = this.positionNode) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(position);
    const skinned = add$3(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    return bindMatrixInverseNode.mul(skinned).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal2 = normalLocal) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    let skinMatrix = add$3(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    return skinMatrix.transformDirection(normal2).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(builder) {
    const skinnedMesh = builder.object;
    if (this.previousBoneMatricesNode === null) {
      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
      this.previousBoneMatricesNode = referenceBuffer("skeleton.previousBoneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    }
    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(builder) {
    const mrt2 = builder.renderer.getMRT();
    return mrt2 && mrt2.has("velocity") || getDataFromObject(builder.object).useVelocity === true;
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(builder) {
    if (this.needsPreviousBoneMatrices(builder)) {
      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
    }
    const skinPosition = this.getSkinnedPosition();
    if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
    if (builder.hasGeometryAttribute("normal")) {
      const skinNormal = this.getSkinnedNormal();
      normalLocal.assign(skinNormal);
      if (builder.hasGeometryAttribute("tangent")) {
        tangentLocal.assign(skinNormal);
      }
    }
    return skinPosition;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    if (output2 !== "void") {
      return super.generate(builder, output2);
    }
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;
    if (_frameId.get(skeleton) === frame.frameId) return;
    _frameId.set(skeleton, frame.frameId);
    if (this.previousBoneMatricesNode !== null) {
      if (skeleton.previousBoneMatrices === null) {
        skeleton.previousBoneMatrices = new Float32Array(skeleton.boneMatrices);
      }
      skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
    }
    skeleton.update();
  }
}
const skinning = (skinnedMesh) => new SkinningNode(skinnedMesh);
const computeSkinning = (skinnedMesh, toPosition = null) => {
  const node = new SkinningNode(skinnedMesh);
  node.positionNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("position").array, 3), "vec3").setPBO(true).toReadOnly().element(instanceIndex$2).toVar();
  node.skinIndexNode = storage(new InstancedBufferAttribute(new Uint32Array(skinnedMesh.geometry.getAttribute("skinIndex").array), 4), "uvec4").setPBO(true).toReadOnly().element(instanceIndex$2).toVar();
  node.skinWeightNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("skinWeight").array, 4), "vec4").setPBO(true).toReadOnly().element(instanceIndex$2).toVar();
  node.bindMatrixNode = uniform$2(skinnedMesh.bindMatrix, "mat4");
  node.bindMatrixInverseNode = uniform$2(skinnedMesh.bindMatrixInverse, "mat4");
  node.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  node.toPositionNode = toPosition;
  return nodeObject(node);
};
class LoopNode extends Node {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(params = []) {
    super("void");
    this.params = params;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt(0) + index);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    const stack2 = builder.addStack();
    const fnCall = this.params[this.params.length - 1](inputs);
    properties.returnsNode = fnCall.context({ nodeLoop: fnCall });
    properties.stackNode = stack2;
    const baseParam = this.params[0];
    if (baseParam.isNode !== true && typeof baseParam.update === "function") {
      const fnUpdateCall = Fn$4(this.params[0].update)(inputs);
      properties.updateNode = fnUpdateCall.context({ nodeLoop: fnUpdateCall });
    }
    builder.removeStack();
    return properties;
  }
  setup(builder) {
    this.getProperties(builder);
    if (builder.fnCall) {
      const shaderNodeData = builder.getDataFromNode(builder.fnCall.shaderNode);
      shaderNodeData.hasLoop = true;
    }
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let isWhile = false, start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        if (param.getNodeType(builder) === "bool") {
          isWhile = true;
          type = "bool";
          end = param.build(builder, type);
        } else {
          type = "int";
          name = this.getVarName(i);
          start = "0";
          end = param.build(builder, type);
          condition = "<";
        }
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number") start = builder.generateConst(type, start);
        else if (start && start.isNode) start = start.build(builder, type);
        if (typeof end === "number") end = builder.generateConst(type, end);
        else if (end && end.isNode) end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      let loopSnippet;
      if (isWhile) {
        loopSnippet = `while ( ${end} )`;
      } else {
        const internalParam = { start, end };
        const startSnippet = internalParam.start;
        const endSnippet = internalParam.end;
        let updateSnippet;
        const deltaOperator = () => condition.includes("<") ? "+=" : "-=";
        if (update !== void 0 && update !== null) {
          switch (typeof update) {
            case "function":
              const flow = builder.flowStagesNode(properties.updateNode, "void");
              const snippet = flow.code.replace(/\t|;/g, "");
              updateSnippet = snippet;
              break;
            case "number":
              updateSnippet = name + " " + deltaOperator() + " " + builder.generateConst(type, update);
              break;
            case "string":
              updateSnippet = name + " " + update;
              break;
            default:
              if (update.isNode) {
                updateSnippet = name + " " + deltaOperator() + " " + update.build(builder);
              } else {
                error("TSL: 'Loop( { update: ... } )' is not a function, string or number.");
                updateSnippet = "break /* invalid update */";
              }
          }
        } else {
          if (type === "int" || type === "uint") {
            update = condition.includes("<") ? "++" : "--";
          } else {
            update = deltaOperator() + " 1.";
          }
          updateSnippet = name + " " + update;
        }
        const declarationSnippet = builder.getVar(type, name) + " = " + startSnippet;
        const conditionalSnippet = name + " " + condition + " " + endSnippet;
        loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      }
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + loopSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = stackNode.build(builder, "void");
    properties.returnsNode.build(builder, "void");
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
  }
}
const Loop = (...params) => new LoopNode(nodeArray(params, "int")).toStack();
const Continue = () => expression("continue").toStack();
const Break = () => expression("break").toStack();
const _morphTextures = /* @__PURE__ */ new WeakMap();
const _morphVec4 = /* @__PURE__ */ new Vector4();
const getMorph = /* @__PURE__ */ Fn$4(({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
  const texelIndex = int$3(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad$2(bufferMap, ivec2$2(x, y)).depth(depth2).xyz;
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = _morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      _morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          _morphVec4.fromBufferAttribute(morphTarget, j);
          buffer2[offset + stride + 0] = _morphVec4.x;
          buffer2[offset + stride + 1] = _morphVec4.y;
          buffer2[offset + stride + 2] = _morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          _morphVec4.fromBufferAttribute(morphNormal, j);
          buffer2[offset + stride + 4] = _morphVec4.x;
          buffer2[offset + stride + 5] = _morphVec4.y;
          buffer2[offset + stride + 6] = _morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          _morphVec4.fromBufferAttribute(morphColor, j);
          buffer2[offset + stride + 8] = _morphVec4.x;
          buffer2[offset + stride + 9] = _morphVec4.y;
          buffer2[offset + stride + 10] = _morphVec4.z;
          buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    _morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
class MorphNode extends Node {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform$2(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.hasAttribute("normal") && geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true) positionLocal$1.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int$3(size.width);
    Loop(morphTargetsCount, ({ i }) => {
      const influence = float$4(0).toVar();
      if (this.mesh.count > 1 && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad$2(this.mesh.morphTexture, ivec2$2(int$3(i).add(1), int$3(instanceIndex$2))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i).toVar());
      }
      If(influence.notEqual(0), () => {
        if (hasMorphPosition === true) {
          positionLocal$1.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i,
            offset: int$3(0)
          }));
        }
        if (hasMorphNormals === true) {
          normalLocal.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i,
            offset: int$3(1)
          }));
        }
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
}
const morphReference = /* @__PURE__ */ nodeProxy(MorphNode).setParameterLength(1);
class LightingNode extends Node {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3");
    this.isLightingNode = true;
  }
}
class AONode extends LightingNode {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    builder.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class LightingContextNode extends ContextNode {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(lightsNode);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3$2().toVar("directDiffuse"), directSpecular = vec3$2().toVar("directSpecular"), indirectDiffuse = vec3$2().toVar("indirectDiffuse"), indirectSpecular = vec3$2().toVar("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context2 = {
      radiance: vec3$2().toVar("radiance"),
      irradiance: vec3$2().toVar("irradiance"),
      iblIrradiance: vec3$2().toVar("iblIrradiance"),
      ambientOcclusion: float$4(1).toVar("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context2;
  }
  setup(builder) {
    this.value = this._value || (this._value = this.getContext());
    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
}
const lightingContext = /* @__PURE__ */ nodeProxy(LightingContextNode);
class IrradianceNode extends LightingNode {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
}
const _size$5 = /* @__PURE__ */ new Vector2();
class ViewportTextureNode extends TextureNode {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
    let defaultFramebuffer = null;
    if (framebufferTexture === null) {
      defaultFramebuffer = new FramebufferTexture();
      defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
      framebufferTexture = defaultFramebuffer;
    } else {
      defaultFramebuffer = framebufferTexture;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.defaultFramebuffer = defaultFramebuffer;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._cacheTextures = /* @__PURE__ */ new WeakMap();
  }
  /**
   * This methods returns a texture for the given render target reference.
   *
   * To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures
   * for different render contexts.
   *
   * @param {?RenderTarget} [reference=null] - The render target reference.
   * @return {Texture} The framebuffer texture.
   */
  getTextureForReference(reference2 = null) {
    let defaultFramebuffer;
    let cacheTextures;
    if (this.referenceNode) {
      defaultFramebuffer = this.referenceNode.defaultFramebuffer;
      cacheTextures = this.referenceNode._cacheTextures;
    } else {
      defaultFramebuffer = this.defaultFramebuffer;
      cacheTextures = this._cacheTextures;
    }
    if (reference2 === null) {
      return defaultFramebuffer;
    }
    if (cacheTextures.has(reference2) === false) {
      const framebufferTexture = defaultFramebuffer.clone();
      cacheTextures.set(reference2, framebufferTexture);
    }
    return cacheTextures.get(reference2);
  }
  updateReference(frame) {
    const renderTarget = frame.renderer.getRenderTarget();
    this.value = this.getTextureForReference(renderTarget);
    return this.value;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget === null) {
      renderer.getDrawingBufferSize(_size$5);
    } else {
      _size$5.set(renderTarget.width, renderTarget.height);
    }
    const framebufferTexture = this.getTextureForReference(renderTarget);
    if (framebufferTexture.image.width !== _size$5.width || framebufferTexture.image.height !== _size$5.height) {
      framebufferTexture.image.width = _size$5.width;
      framebufferTexture.image.height = _size$5.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
}
const viewportTexture = /* @__PURE__ */ nodeProxy(ViewportTextureNode).setParameterLength(0, 3);
const viewportMipTexture = /* @__PURE__ */ nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true }).setParameterLength(0, 3);
let _sharedDepthbuffer = null;
class ViewportDepthTextureNode extends ViewportTextureNode {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedDepthbuffer === null) {
      _sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, _sharedDepthbuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * depth texture.
   *
   * @return {DepthTexture} The shared depth texture.
   */
  getTextureForReference() {
    return _sharedDepthbuffer;
  }
}
const viewportDepthTexture = /* @__PURE__ */ nodeProxy(ViewportDepthTextureNode).setParameterLength(0, 2);
class ViewportDepthNode extends Node {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === ViewportDepthNode.DEPTH_BASE) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup({ camera }) {
    const { scope } = this;
    const value = this.valueNode;
    let node = null;
    if (scope === ViewportDepthNode.DEPTH_BASE) {
      if (value !== null) {
        node = depthBase().assign(value);
      }
    } else if (scope === ViewportDepthNode.DEPTH) {
      if (camera.isPerspectiveCamera) {
        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {
      if (value !== null) {
        if (camera.isPerspectiveCamera) {
          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        } else {
          node = value;
        }
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    }
    return node;
  }
}
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
const viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
const orthographicDepthToViewZ = (depth2, near, far) => near.sub(far).mul(depth2).sub(near);
const viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
const perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
const viewZToLogarithmicDepth = (viewZ, near, far) => {
  near = near.max(1e-6).toVar();
  const numerator = log2(viewZ.negate().div(near));
  const denominator = log2(far.div(near));
  return numerator.div(denominator);
};
const logarithmicDepthToViewZ = (depth2, near, far) => {
  const exponent = depth2.mul(log$1(far.div(near)));
  return float$4(Math.E).pow(exponent).mul(near).negate();
};
const depthBase = /* @__PURE__ */ nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
const depth = /* @__PURE__ */ nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
const linearDepth = /* @__PURE__ */ nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH).setParameterLength(0, 1);
const viewportLinearDepth = /* @__PURE__ */ linearDepth(viewportDepthTexture());
depth.assign = (value) => depthBase(value);
class ClippingNode extends Node {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(scope = ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { intersectionPlanes, unionPlanes } = clippingContext;
    this.hardwareClipping = builder.material.hardwareClipping;
    if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
    } else if (this.scope === ClippingNode.HARDWARE) {
      return this.setupHardwareClipping(unionPlanes, builder);
    } else {
      return this.setupDefault(intersectionPlanes, unionPlanes);
    }
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
    return Fn$4(() => {
      const distanceToPlane = float$4().toVar("distanceToPlane");
      const distanceGradient = float$4().toVar("distanceToGradient");
      const clipOpacity = float$4(1).toVar("clipOpacity");
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const intersectionClipOpacity = float$4(1).toVar("intersectionClipOpacity");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(intersectionPlanes, unionPlanes) {
    return Fn$4(() => {
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          positionView.dot(plane.xyz).greaterThan(plane.w).discard();
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const clipped = bool(true).toVar("clipped");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(unionPlanes, builder) {
    const numUnionPlanes = unionPlanes.length;
    builder.enableHardwareClipping(numUnionPlanes);
    return Fn$4(() => {
      const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
      const hw_clip_distances = builtin(builder.getClipDistance());
      Loop(numUnionPlanes, ({ i }) => {
        const plane = clippingPlanes.element(i);
        const distance2 = positionView.dot(plane.xyz).sub(plane.w).negate();
        hw_clip_distances.element(i).assign(distance2);
      });
    })();
  }
}
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
const clipping = () => new ClippingNode();
const clippingAlpha = () => new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE);
const hardwareClipping = () => new ClippingNode(ClippingNode.HARDWARE);
const ALPHA_HASH_SCALE = 0.05;
const hash2D = /* @__PURE__ */ Fn$4(([value]) => {
  return fract(mul$3(1e4, sin$1(mul$3(17, value.x).add(mul$3(0.1, value.y)))).mul(add$3(0.1, abs$2(sin$1(mul$3(13, value.y).add(value.x))))));
});
const hash3D = /* @__PURE__ */ Fn$4(([value]) => {
  return hash2D(vec2$2(hash2D(value.xy), value.z));
});
const getAlphaHashThreshold = /* @__PURE__ */ Fn$4(([position]) => {
  const maxDeriv = max$1$1(
    length(dFdx(position.xyz)),
    length(dFdy(position.xyz))
  );
  const pixScale = float$4(1).div(float$4(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar("pixScale");
  const pixScales = vec2$2(
    exp2(floor(log2(pixScale))),
    exp2(ceil(log2(pixScale)))
  );
  const alpha = vec2$2(
    hash3D(floor(pixScales.x.mul(position.xyz))),
    hash3D(floor(pixScales.y.mul(position.xyz)))
  );
  const lerpFactor = fract(log2(pixScale));
  const x = add$3(mul$3(lerpFactor.oneMinus(), alpha.x), mul$3(lerpFactor, alpha.y));
  const a = min$1$1(lerpFactor, lerpFactor.oneMinus());
  const cases = vec3$2(
    x.mul(x).div(mul$3(2, a).mul(sub$3(1, a))),
    x.sub(mul$3(0.5, a)).div(sub$3(1, a)),
    sub$3(1, sub$3(1, x).mul(sub$3(1, x)).div(mul$3(2, a).mul(sub$3(1, a))))
  );
  const threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);
  return clamp$1(threshold, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
class VertexColorNode extends AttributeNode {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(index) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const index = this.index;
    return "color" + (index > 0 ? index : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
}
const vertexColor = (index = 0) => new VertexColorNode(index);
const blendBurn = /* @__PURE__ */ Fn$4(([base, blend]) => {
  return min$1$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
const blendDodge = /* @__PURE__ */ Fn$4(([base, blend]) => {
  return min$1$1(base.div(blend.oneMinus()), 1);
}).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
const blendScreen = /* @__PURE__ */ Fn$4(([base, blend]) => {
  return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
const blendOverlay = /* @__PURE__ */ Fn$4(([base, blend]) => {
  return mix(base.mul(2).mul(blend), base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
}).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
const blendColor = /* @__PURE__ */ Fn$4(([base, blend]) => {
  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
  return vec4$3(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" }
  ]
});
const premultiplyAlpha = /* @__PURE__ */ Fn$4(([color2]) => {
  return vec4$3(color2.rgb.mul(color2.a), color2.a);
}, { color: "vec4", return: "vec4" });
const unpremultiplyAlpha = /* @__PURE__ */ Fn$4(([color2]) => {
  If(color2.a.equal(0), () => vec4$3(0));
  return vec4$3(color2.rgb.div(color2.a), color2.a);
}, { color: "vec4", return: "vec4" });
const burn = (...params) => {
  warn('TSL: "burn" has been renamed. Use "blendBurn" instead.');
  return blendBurn(params);
};
const dodge = (...params) => {
  warn('TSL: "dodge" has been renamed. Use "blendDodge" instead.');
  return blendDodge(params);
};
const screen = (...params) => {
  warn('TSL: "screen" has been renamed. Use "blendScreen" instead.');
  return blendScreen(params);
};
const overlay = (...params) => {
  warn('TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
  return blendOverlay(params);
};
class NodeMaterial extends Material {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  /**
   * Constructs a new node material.
   */
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.fog = true;
    this.lights = false;
    this.hardwareClipping = false;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.maskNode = null;
    this.positionNode = null;
    this.geometryNode = null;
    this.depthNode = null;
    this.receivedShadowPositionNode = null;
    this.castShadowPositionNode = null;
    this.receivedShadowNode = null;
    this.castShadowNode = null;
    this.outputNode = null;
    this.mrtNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
    this.contextNode = null;
    Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => {
        return this.receivedShadowPositionNode;
      },
      set: (value) => {
        warn('NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".');
        this.receivedShadowPositionNode = value;
      }
    });
  }
  /**
   * Returns an array of child nodes for this material.
   *
   * @private
   * @returns {Array<{property: string, childNode: Node}>}
   */
  _getNodeChildren() {
    const children = [];
    for (const property2 of Object.getOwnPropertyNames(this)) {
      if (property2.startsWith("_") === true) continue;
      const object = this[property2];
      if (object && object.isNode === true) {
        children.push({ property: property2, childNode: object });
      }
    }
    return children;
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    const values = [];
    for (const { property: property2, childNode } of this._getNodeChildren()) {
      values.push(hashString(property2.slice(0, -4)), childNode.getCacheKey());
    }
    return this.type + hashArray(values);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(builder) {
    this.setup(builder);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(builder) {
    return new NodeMaterialObserver(builder);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    builder.context.setupNormal = () => subBuild(this.setupNormal(builder), "NORMAL", "vec3");
    builder.context.setupPositionView = () => this.setupPositionView(builder);
    builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);
    const renderer = builder.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderer.contextNode.isContextNode === true) {
      builder.context = { ...builder.context, ...renderer.contextNode.getFlowContextData() };
    } else {
      error('NodeMaterial: "renderer.contextNode" must be an instance of `context()`.');
    }
    if (this.contextNode !== null) {
      if (this.contextNode.isContextNode === true) {
        builder.context = { ...builder.context, ...this.contextNode.getFlowContextData() };
      } else {
        error('NodeMaterial: "material.contextNode" must be an instance of `context()`.');
      }
    }
    builder.addStack();
    const mvp = subBuild(this.setupVertex(builder), "VERTEX");
    const vertexNode = this.vertexNode || mvp;
    builder.stack.outputNode = vertexNode;
    this.setupHardwareClipping(builder);
    if (this.geometryNode !== null) {
      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
    }
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true || this.depthTest === true) {
      if (renderTarget !== null) {
        if (renderTarget.depthBuffer === true) this.setupDepth(builder);
      } else {
        if (renderer.depth === true) this.setupDepth(builder);
      }
    }
    if (this.fragmentNode === null) {
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.addToStack(clippingNode);
      const basicOutput = vec4$3(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      const isCustomOutput = this.outputNode !== null;
      if (isCustomOutput) resultNode = this.outputNode;
      if (builder.context.getOutput) {
        resultNode = builder.context.getOutput(resultNode, builder);
      }
      if (renderTarget !== null) {
        const mrt2 = renderer.getMRT();
        const materialMRT = this.mrtNode;
        if (mrt2 !== null) {
          if (isCustomOutput) output.assign(resultNode);
          resultNode = mrt2;
          if (materialMRT !== null) {
            resultNode = mrt2.merge(materialMRT);
          }
        } else if (materialMRT !== null) {
          resultNode = materialMRT;
        }
      }
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4$3(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
    builder.observer = this.setupObserver(builder);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { unionPlanes, intersectionPlanes } = builder.clippingContext;
    let result = null;
    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
      const samples = builder.renderer.currentSamples;
      if (this.alphaToCoverage && samples > 1) {
        result = clippingAlpha();
      } else {
        builder.stack.addToStack(clipping());
      }
    }
    return result;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(builder) {
    this.hardwareClipping = false;
    if (builder.clippingContext === null) return;
    const candidateCount = builder.clippingContext.unionPlanes.length;
    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable("clipDistance")) {
      builder.stack.addToStack(hardwareClipping());
      this.hardwareClipping = true;
    }
    return;
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(builder) {
    const { renderer, camera } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null) {
      const mrt2 = renderer.getMRT();
      if (mrt2 && mrt2.has("depth")) {
        depthNode = mrt2.get("depth");
      } else if (renderer.logarithmicDepthBuffer === true) {
        if (camera.isPerspectiveCamera) {
          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
        } else {
          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
        }
      }
    }
    if (depthNode !== null) {
      depth.assign(depthNode).toStack();
    }
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return modelViewMatrix.mul(positionLocal$1).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return cameraProjectionMatrix.mul(positionView);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(builder) {
    builder.addStack();
    this.setupPosition(builder);
    builder.context.vertex = builder.removeStack();
    return modelViewProjection;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(builder) {
    const { object, geometry } = builder;
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object).toStack();
    }
    if (object.isSkinnedMesh === true) {
      skinning(object).toStack();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal$1.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object.isBatchedMesh) {
      batch(object).toStack();
    }
    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {
      instancedMesh(object).toStack();
    }
    if (this.positionNode !== null) {
      positionLocal$1.assign(subBuild(this.positionNode, "POSITION", "vec3"));
    }
    return positionLocal$1;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor(builder) {
    const { object, geometry } = builder;
    if (this.maskNode !== null) {
      bool(this.maskNode).not().discard();
    }
    let colorNode = this.colorNode ? vec4$3(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = colorNode.mul(vertexColor());
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty$1("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    if (object.isBatchedMesh && object._colorsTexture) {
      const batchColor = varyingProperty$1("vec3", "vBatchColor");
      colorNode = batchColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float$4(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    let alphaTestNode = null;
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      alphaTestNode = this.alphaTestNode !== null ? float$4(this.alphaTestNode) : materialAlphaTest;
      if (this.alphaToCoverage === true) {
        diffuseColor.a = smoothstep(alphaTestNode, alphaTestNode.add(fwidth(diffuseColor.a)), diffuseColor.a);
        diffuseColor.a.lessThanEqual(0).discard();
      } else {
        diffuseColor.a.lessThanEqual(alphaTestNode).discard();
      }
    }
    if (this.alphaHash === true) {
      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal$1)).discard();
    }
    if (builder.isOpaque()) {
      diffuseColor.a.assign(1);
    }
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
  }
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === true ? vec3$2(0) : diffuseColor.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? vec3$2(this.normalNode) : materialNormal;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? materialReference("envMap", "cubeTexture") : materialReference("envMap", "texture");
    }
    return node;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new IrradianceNode(materialLightMap);
    }
    return node;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(builder) {
    const materialLightsNode = [];
    const envNode = this.setupEnvironment(builder);
    if (envNode && envNode.isLightingNode) {
      materialLightsNode.push(envNode);
    }
    const lightMapNode = this.setupLightMap(builder);
    if (lightMapNode && lightMapNode.isLightingNode) {
      materialLightsNode.push(lightMapNode);
    }
    let aoNode = this.aoNode;
    if (aoNode === null && builder.material.aoMap) {
      aoNode = materialAO;
    }
    if (builder.context.getAO) {
      aoNode = builder.context.getAO(aoNode, builder);
    }
    if (aoNode) {
      materialLightsNode.push(new AONode(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
    }
    return lightsN;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {
  }
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = this.setupOutgoingLight(builder);
    if (lightsNode && lightsNode.getScope().hasLights) {
      const lightingModel = this.setupLightingModel(builder) || null;
      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3$2(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      emissive.assign(vec3$2(emissiveNode ? emissiveNode : materialEmissive));
      outgoingLightNode = outgoingLightNode.add(emissive);
    }
    return outgoingLightNode;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode) {
      output.assign(outputNode);
      outputNode = vec4$3(fogNode.toVar());
    }
    return outputNode;
  }
  /**
   * Setups premultiplied alpha.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupPremultipliedAlpha(builder, outputNode) {
    return premultiplyAlpha(outputNode);
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(builder, outputNode) {
    if (this.fog === true) {
      outputNode = this.setupFog(builder, outputNode);
    }
    if (this.premultipliedAlpha === true) {
      outputNode = this.setupPremultipliedAlpha(builder, outputNode);
    }
    return outputNode;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone) this[property2] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    data.inputNodes = {};
    for (const { property: property2, childNode } of this._getNodeChildren()) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.aoNode = source.aoNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.maskNode = source.maskNode;
    this.positionNode = source.positionNode;
    this.geometryNode = source.geometryNode;
    this.depthNode = source.depthNode;
    this.receivedShadowPositionNode = source.receivedShadowPositionNode;
    this.castShadowPositionNode = source.castShadowPositionNode;
    this.receivedShadowNode = source.receivedShadowNode;
    this.castShadowNode = source.castShadowNode;
    this.outputNode = source.outputNode;
    this.mrtNode = source.mrtNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    this.contextNode = source.contextNode;
    return super.copy(source);
  }
}
let _sharedFramebuffer = null;
class ViewportSharedTextureNode extends ViewportTextureNode {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  /**
   * Constructs a new viewport shared texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * framebuffer texture.
   *
   * @return {FramebufferTexture} The shared framebuffer texture.
   */
  getTextureForReference() {
    return _sharedFramebuffer;
  }
  updateReference() {
    return this;
  }
}
const viewportSharedTexture = /* @__PURE__ */ nodeProxy(ViewportSharedTextureNode).setParameterLength(0, 2);
const equirectUV = /* @__PURE__ */ Fn$4(([dir = positionWorldDirection]) => {
  const u = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
  const v = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
  return vec2$2(u, v);
});
const F_Schlick = /* @__PURE__ */ Fn$4(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
const BRDF_Lambert = /* @__PURE__ */ Fn$4((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
const getGeometryRoughness = /* @__PURE__ */ Fn$4((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    return float$4(0);
  }
  const dxy = normalViewGeometry.dFdx().abs().max(normalViewGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
const getRoughness = /* @__PURE__ */ Fn$4((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
const V_GGX_SmithCorrelated = /* @__PURE__ */ Fn$4(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div$2(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
const V_GGX_SmithCorrelated_Anisotropic = /* @__PURE__ */ Fn$4(({ alphaT: alphaT2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3$2(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3$2(alphaT2.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v = div$2(0.5, gv.add(gl));
  return v;
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
const D_GGX = /* @__PURE__ */ Fn$4(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
const RECIPROCAL_PI = /* @__PURE__ */ float$4(1 / Math.PI);
const D_GGX_Anisotropic = /* @__PURE__ */ Fn$4(({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {
  const a2 = alphaT2.mul(alphaB);
  const v = vec3$2(alphaB.mul(dotTH), alphaT2.mul(dotBH), a2.mul(dotNH));
  const v2 = v.dot(v);
  const w22 = a2.div(v2);
  return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
const BRDF_GGX = /* @__PURE__ */ Fn$4(({ lightDirection, f0, f90, roughness: roughness2, f, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView$1.dot(lightDirection).clamp();
  const dotNV = normalView$1.dot(positionViewDirection).clamp();
  const dotNH = normalView$1.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick({ f0, f90, dotVH });
  let V, D;
  if (defined(USE_IRIDESCENCE)) {
    F = iridescence.mix(F, f);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V = V_GGX_SmithCorrelated_Anisotropic({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
    D = D_GGX({ alpha, dotNH });
  }
  return F.mul(V).mul(D);
});
const DATA = new Uint16Array([
  12469,
  15057,
  12620,
  14925,
  13266,
  14620,
  13807,
  14376,
  14323,
  13990,
  14545,
  13625,
  14713,
  13328,
  14840,
  12882,
  14931,
  12528,
  14996,
  12233,
  15039,
  11829,
  15066,
  11525,
  15080,
  11295,
  15085,
  10976,
  15082,
  10705,
  15073,
  10495,
  13880,
  14564,
  13898,
  14542,
  13977,
  14430,
  14158,
  14124,
  14393,
  13732,
  14556,
  13410,
  14702,
  12996,
  14814,
  12596,
  14891,
  12291,
  14937,
  11834,
  14957,
  11489,
  14958,
  11194,
  14943,
  10803,
  14921,
  10506,
  14893,
  10278,
  14858,
  9960,
  14484,
  14039,
  14487,
  14025,
  14499,
  13941,
  14524,
  13740,
  14574,
  13468,
  14654,
  13106,
  14743,
  12678,
  14818,
  12344,
  14867,
  11893,
  14889,
  11509,
  14893,
  11180,
  14881,
  10751,
  14852,
  10428,
  14812,
  10128,
  14765,
  9754,
  14712,
  9466,
  14764,
  13480,
  14764,
  13475,
  14766,
  13440,
  14766,
  13347,
  14769,
  13070,
  14786,
  12713,
  14816,
  12387,
  14844,
  11957,
  14860,
  11549,
  14868,
  11215,
  14855,
  10751,
  14825,
  10403,
  14782,
  10044,
  14729,
  9651,
  14666,
  9352,
  14599,
  9029,
  14967,
  12835,
  14966,
  12831,
  14963,
  12804,
  14954,
  12723,
  14936,
  12564,
  14917,
  12347,
  14900,
  11958,
  14886,
  11569,
  14878,
  11247,
  14859,
  10765,
  14828,
  10401,
  14784,
  10011,
  14727,
  9600,
  14660,
  9289,
  14586,
  8893,
  14508,
  8533,
  15111,
  12234,
  15110,
  12234,
  15104,
  12216,
  15092,
  12156,
  15067,
  12010,
  15028,
  11776,
  14981,
  11500,
  14942,
  11205,
  14902,
  10752,
  14861,
  10393,
  14812,
  9991,
  14752,
  9570,
  14682,
  9252,
  14603,
  8808,
  14519,
  8445,
  14431,
  8145,
  15209,
  11449,
  15208,
  11451,
  15202,
  11451,
  15190,
  11438,
  15163,
  11384,
  15117,
  11274,
  15055,
  10979,
  14994,
  10648,
  14932,
  10343,
  14871,
  9936,
  14803,
  9532,
  14729,
  9218,
  14645,
  8742,
  14556,
  8381,
  14461,
  8020,
  14365,
  7603,
  15273,
  10603,
  15272,
  10607,
  15267,
  10619,
  15256,
  10631,
  15231,
  10614,
  15182,
  10535,
  15118,
  10389,
  15042,
  10167,
  14963,
  9787,
  14883,
  9447,
  14800,
  9115,
  14710,
  8665,
  14615,
  8318,
  14514,
  7911,
  14411,
  7507,
  14279,
  7198,
  15314,
  9675,
  15313,
  9683,
  15309,
  9712,
  15298,
  9759,
  15277,
  9797,
  15229,
  9773,
  15166,
  9668,
  15084,
  9487,
  14995,
  9274,
  14898,
  8910,
  14800,
  8539,
  14697,
  8234,
  14590,
  7790,
  14479,
  7409,
  14367,
  7067,
  14178,
  6621,
  15337,
  8619,
  15337,
  8631,
  15333,
  8677,
  15325,
  8769,
  15305,
  8871,
  15264,
  8940,
  15202,
  8909,
  15119,
  8775,
  15022,
  8565,
  14916,
  8328,
  14804,
  8009,
  14688,
  7614,
  14569,
  7287,
  14448,
  6888,
  14321,
  6483,
  14088,
  6171,
  15350,
  7402,
  15350,
  7419,
  15347,
  7480,
  15340,
  7613,
  15322,
  7804,
  15287,
  7973,
  15229,
  8057,
  15148,
  8012,
  15046,
  7846,
  14933,
  7611,
  14810,
  7357,
  14682,
  7069,
  14552,
  6656,
  14421,
  6316,
  14251,
  5948,
  14007,
  5528,
  15356,
  5942,
  15356,
  5977,
  15353,
  6119,
  15348,
  6294,
  15332,
  6551,
  15302,
  6824,
  15249,
  7044,
  15171,
  7122,
  15070,
  7050,
  14949,
  6861,
  14818,
  6611,
  14679,
  6349,
  14538,
  6067,
  14398,
  5651,
  14189,
  5311,
  13935,
  4958,
  15359,
  4123,
  15359,
  4153,
  15356,
  4296,
  15353,
  4646,
  15338,
  5160,
  15311,
  5508,
  15263,
  5829,
  15188,
  6042,
  15088,
  6094,
  14966,
  6001,
  14826,
  5796,
  14678,
  5543,
  14527,
  5287,
  14377,
  4985,
  14133,
  4586,
  13869,
  4257,
  15360,
  1563,
  15360,
  1642,
  15358,
  2076,
  15354,
  2636,
  15341,
  3350,
  15317,
  4019,
  15273,
  4429,
  15203,
  4732,
  15105,
  4911,
  14981,
  4932,
  14836,
  4818,
  14679,
  4621,
  14517,
  4386,
  14359,
  4156,
  14083,
  3795,
  13808,
  3437,
  15360,
  122,
  15360,
  137,
  15358,
  285,
  15355,
  636,
  15344,
  1274,
  15322,
  2177,
  15281,
  2765,
  15215,
  3223,
  15120,
  3451,
  14995,
  3569,
  14846,
  3567,
  14681,
  3466,
  14511,
  3305,
  14344,
  3121,
  14037,
  2800,
  13753,
  2467,
  15360,
  0,
  15360,
  1,
  15359,
  21,
  15355,
  89,
  15346,
  253,
  15325,
  479,
  15287,
  796,
  15225,
  1148,
  15133,
  1492,
  15008,
  1749,
  14856,
  1882,
  14685,
  1886,
  14506,
  1783,
  14324,
  1608,
  13996,
  1398,
  13702,
  1183
]);
let lut = null;
const DFGLUT = /* @__PURE__ */ Fn$4(({ roughness: roughness2, dotNV }) => {
  if (lut === null) {
    lut = new DataTexture(DATA, 16, 16, RGFormat, HalfFloatType);
    lut.name = "DFG_LUT";
    lut.minFilter = LinearFilter;
    lut.magFilter = LinearFilter;
    lut.wrapS = ClampToEdgeWrapping;
    lut.wrapT = ClampToEdgeWrapping;
    lut.generateMipmaps = false;
    lut.needsUpdate = true;
  }
  const uv2 = vec2$2(roughness2, dotNV);
  return texture$2(lut, uv2).rg;
});
const Schlick_to_F0 = /* @__PURE__ */ Fn$4(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3$2(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
const bC = 1 / 6;
const w0 = (a) => mul$3(bC, mul$3(a, mul$3(a, a.negate().add(3)).sub(3)).add(1));
const w1 = (a) => mul$3(bC, mul$3(a, mul$3(a, mul$3(3, a).sub(6))).add(4));
const w2 = (a) => mul$3(bC, mul$3(a, mul$3(a, mul$3(-3, a).add(3)).add(3)).add(1));
const w3 = (a) => mul$3(bC, pow(a, 3));
const g0 = (a) => w0(a).add(w1(a));
const g1 = (a) => w2(a).add(w3(a));
const h0 = (a) => add$3(-1, w1(a).div(w0(a).add(w1(a))));
const h1 = (a) => add$3(1, w3(a).div(w2(a).add(w3(a))));
const bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul$3(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2$2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2$2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2$2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2$2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add$3(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
  const b = g1(fuv.y).mul(add$3(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
  return a.add(b);
};
const textureBicubicLevel = /* @__PURE__ */ Fn$4(([textureNode, lodNode]) => {
  const fLodSize = vec2$2(textureNode.size(int$3(lodNode)));
  const cLodSize = vec2$2(textureNode.size(int$3(lodNode.add(1))));
  const fLodSizeInv = div$2(1, fLodSize);
  const cLodSizeInv = div$2(1, cLodSize);
  const fSample = bicubic(textureNode, vec4$3(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4$3(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
});
const textureBicubic = /* @__PURE__ */ Fn$4(([textureNode, strength]) => {
  const lod = strength.mul(maxMipLevel(textureNode));
  return textureBicubicLevel(textureNode, lod);
});
vec3$2(0.04);
float$4(1);
const cubeUV_r0 = /* @__PURE__ */ float$4(1);
const cubeUV_m0 = /* @__PURE__ */ float$4(-2);
const cubeUV_r1 = /* @__PURE__ */ float$4(0.8);
const cubeUV_m1 = /* @__PURE__ */ float$4(-1);
const cubeUV_r4 = /* @__PURE__ */ float$4(0.4);
const cubeUV_m4 = /* @__PURE__ */ float$4(2);
const cubeUV_r5 = /* @__PURE__ */ float$4(0.305);
const cubeUV_m5 = /* @__PURE__ */ float$4(3);
const cubeUV_r6 = /* @__PURE__ */ float$4(0.21);
const cubeUV_m6 = /* @__PURE__ */ float$4(4);
const cubeUV_minMipLevel = /* @__PURE__ */ float$4(4);
const cubeUV_minTileSize = /* @__PURE__ */ float$4(16);
const getFace = /* @__PURE__ */ Fn$4(([direction]) => {
  const absDirection = vec3$2(abs$2(direction)).toVar();
  const face = float$4(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(select$3(direction.x.greaterThan(0), 0, 3));
    }).Else(() => {
      face.assign(select$3(direction.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(select$3(direction.z.greaterThan(0), 2, 5));
    }).Else(() => {
      face.assign(select$3(direction.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
const getUV = /* @__PURE__ */ Fn$4(([direction, face]) => {
  const uv2 = vec2$2().toVar();
  If(face.equal(0), () => {
    uv2.assign(vec2$2(direction.z, direction.y).div(abs$2(direction.x)));
  }).ElseIf(face.equal(1), () => {
    uv2.assign(vec2$2(direction.x.negate(), direction.z.negate()).div(abs$2(direction.y)));
  }).ElseIf(face.equal(2), () => {
    uv2.assign(vec2$2(direction.x.negate(), direction.y).div(abs$2(direction.z)));
  }).ElseIf(face.equal(3), () => {
    uv2.assign(vec2$2(direction.z.negate(), direction.y).div(abs$2(direction.x)));
  }).ElseIf(face.equal(4), () => {
    uv2.assign(vec2$2(direction.x.negate(), direction.z).div(abs$2(direction.y)));
  }).Else(() => {
    uv2.assign(vec2$2(direction.x, direction.y).div(abs$2(direction.z)));
  });
  return mul$3(0.5, uv2.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
const roughnessToMip = /* @__PURE__ */ Fn$4(([roughness2]) => {
  const mip = float$4(0).toVar();
  If(roughness2.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).ElseIf(roughness2.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).Else(() => {
    mip.assign(float$4(-2).mul(log2(mul$3(1.16, roughness2))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
const getDirection = /* @__PURE__ */ Fn$4(([uv_immutable, face]) => {
  const uv2 = uv_immutable.toVar();
  uv2.assign(mul$3(2, uv2).sub(1));
  const direction = vec3$2(uv2, 1).toVar();
  If(face.equal(0), () => {
    direction.assign(direction.zyx);
  }).ElseIf(face.equal(1), () => {
    direction.assign(direction.xzy);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(2), () => {
    direction.x.mulAssign(-1);
  }).ElseIf(face.equal(3), () => {
    direction.assign(direction.zyx);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(4), () => {
    direction.assign(direction.xzy);
    direction.xy.mulAssign(-1);
  }).ElseIf(face.equal(5), () => {
    direction.z.mulAssign(-1);
  });
  return direction;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
const textureCubeUV = /* @__PURE__ */ Fn$4(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness2 = float$4(roughness_immutable);
  const sampleDir = vec3$2(sampleDir_immutable);
  const mip = clamp$1(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3$2(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3$2(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix(color0, color1, mipF));
  });
  return color0;
});
const bilinearCubeUV = /* @__PURE__ */ Fn$4(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float$4(mipInt_immutable).toVar();
  const direction = vec3$2(direction_immutable);
  const face = float$4(getFace(direction)).toVar();
  const filterInt = float$4(max$1$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max$1$1(mipInt, cubeUV_minMipLevel));
  const faceSize = float$4(exp2(mipInt)).toVar();
  const uv2 = vec2$2(getUV(direction, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv2.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv2.x.addAssign(face.mul(faceSize));
  uv2.x.addAssign(filterInt.mul(mul$3(3, cubeUV_minTileSize)));
  uv2.y.addAssign(mul$3(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
  uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.sample(uv2).grad(vec2$2(), vec2$2());
});
const getSample = /* @__PURE__ */ Fn$4(({ envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos$1(theta);
  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin$1(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
const blur = /* @__PURE__ */ Fn$4(({ n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3$2(select$3(latitudinal, poleAxis, cross$1(poleAxis, outputDirection))).toVar();
  If(axis.equal(vec3$2(0)), () => {
    axis.assign(vec3$2(outputDirection.z, 0, outputDirection.x.negate()));
  });
  axis.assign(normalize$1(axis));
  const gl_FragColor = vec3$2().toVar();
  gl_FragColor.addAssign(weights.element(0).mul(getSample({ theta: 0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  Loop({ start: int$3(1), end: n }, ({ i }) => {
    If(i.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float$4(dTheta.mul(float$4(i))).toVar();
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4$3(gl_FragColor, 1);
});
const radicalInverse_VdC = /* @__PURE__ */ Fn$4(([bits_immutable]) => {
  const bits2 = uint$3(bits_immutable).toVar();
  bits2.assign(bits2.shiftLeft(uint$3(16)).bitOr(bits2.shiftRight(uint$3(16))));
  bits2.assign(bits2.bitAnd(uint$3(1431655765)).shiftLeft(uint$3(1)).bitOr(bits2.bitAnd(uint$3(2863311530)).shiftRight(uint$3(1))));
  bits2.assign(bits2.bitAnd(uint$3(858993459)).shiftLeft(uint$3(2)).bitOr(bits2.bitAnd(uint$3(3435973836)).shiftRight(uint$3(2))));
  bits2.assign(bits2.bitAnd(uint$3(252645135)).shiftLeft(uint$3(4)).bitOr(bits2.bitAnd(uint$3(4042322160)).shiftRight(uint$3(4))));
  bits2.assign(bits2.bitAnd(uint$3(16711935)).shiftLeft(uint$3(8)).bitOr(bits2.bitAnd(uint$3(4278255360)).shiftRight(uint$3(8))));
  return float$4(bits2).mul(23283064365386963e-26);
});
const hammersley = /* @__PURE__ */ Fn$4(([i, N2]) => {
  return vec2$2(float$4(i).div(float$4(N2)), radicalInverse_VdC(i));
});
const importanceSampleGGX_VNDF = /* @__PURE__ */ Fn$4(([Xi, V_immutable, roughness_immutable]) => {
  const V = vec3$2(V_immutable).toVar();
  const roughness2 = float$4(roughness_immutable);
  const alpha = roughness2.mul(roughness2).toVar();
  const Vh = normalize$1(vec3$2(alpha.mul(V.x), alpha.mul(V.y), V.z)).toVar();
  const lensq = Vh.x.mul(Vh.x).add(Vh.y.mul(Vh.y));
  const T1 = select$3(lensq.greaterThan(0), vec3$2(Vh.y.negate(), Vh.x, 0).div(sqrt$3(lensq)), vec3$2(1, 0, 0)).toVar();
  const T2 = cross$1(Vh, T1).toVar();
  const r = sqrt$3(Xi.x);
  const phi = mul$3(2, 3.14159265359).mul(Xi.y);
  const t1 = r.mul(cos$1(phi)).toVar();
  const t2 = r.mul(sin$1(phi)).toVar();
  const s = mul$3(0.5, Vh.z.add(1));
  t2.assign(s.oneMinus().mul(sqrt$3(t1.mul(t1).oneMinus())).add(s.mul(t2)));
  const Nh = T1.mul(t1).add(T2.mul(t2)).add(Vh.mul(sqrt$3(max$1$1(0, t1.mul(t1).add(t2.mul(t2)).oneMinus()))));
  return normalize$1(vec3$2(alpha.mul(Nh.x), alpha.mul(Nh.y), max$1$1(0, Nh.z)));
});
const ggxConvolution = /* @__PURE__ */ Fn$4(({ roughness: roughness2, mipInt, envMap, N_immutable, GGX_SAMPLES: GGX_SAMPLES2, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const N2 = vec3$2(N_immutable).toVar();
  const prefilteredColor = vec3$2(0).toVar();
  const totalWeight = float$4(0).toVar();
  If(roughness2.lessThan(1e-3), () => {
    prefilteredColor.assign(bilinearCubeUV(envMap, N2, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP));
  }).Else(() => {
    const up = select$3(abs$2(N2.z).lessThan(0.999), vec3$2(0, 0, 1), vec3$2(1, 0, 0));
    const tangent = normalize$1(cross$1(up, N2)).toVar();
    const bitangent = cross$1(N2, tangent).toVar();
    Loop({ start: uint$3(0), end: GGX_SAMPLES2 }, ({ i }) => {
      const Xi = hammersley(i, GGX_SAMPLES2);
      const H_tangent = importanceSampleGGX_VNDF(Xi, vec3$2(0, 0, 1), roughness2);
      const H = normalize$1(tangent.mul(H_tangent.x).add(bitangent.mul(H_tangent.y)).add(N2.mul(H_tangent.z)));
      const L = normalize$1(H.mul(dot$3(N2, H).mul(2)).sub(N2));
      const NdotL = max$1$1(dot$3(N2, L), 0);
      If(NdotL.greaterThan(0), () => {
        const sampleColor = bilinearCubeUV(envMap, L, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
        prefilteredColor.addAssign(sampleColor.mul(NdotL));
        totalWeight.addAssign(NdotL);
      });
    });
    If(totalWeight.greaterThan(0), () => {
      prefilteredColor.assign(prefilteredColor.div(totalWeight));
    });
  });
  return vec4$3(prefilteredColor, 1);
});
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const GGX_SAMPLES = 512;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
const _cubeCamera = /* @__PURE__ */ new PerspectiveCamera(90, 1);
const _clearColor$2 = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
const _origin = /* @__PURE__ */ new Vector3();
const _uniformsMap = /* @__PURE__ */ new WeakMap();
const _faceLib = [
  3,
  1,
  5,
  0,
  4,
  2
];
const _direction = /* @__PURE__ */ getDirection(uv$1(), attribute$1("faceIndex")).normalize();
const _outputDirection = /* @__PURE__ */ vec3$2(_direction.x, _direction.y, _direction.z);
class PMREMGenerator {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._ggxMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromScene}
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
    const {
      size = 256,
      position = _origin,
      renderTarget = null
    } = options;
    this._setSize(size);
    if (this._hasInitialized === false) {
      warn('PMREMGenerator: ".fromScene()" called before the backend is initialized. Try using "await renderer.init()" instead.');
      const cubeUVRenderTarget2 = renderTarget || this._allocateTarget();
      options.renderTarget = cubeUVRenderTarget2;
      this.fromSceneAsync(scene, sigma, near, far, options);
      return cubeUVRenderTarget2;
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    cubeUVRenderTarget.depthBuffer = true;
    this._init(cubeUVRenderTarget);
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @deprecated
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
    warnOnce('PMREMGenerator: ".fromSceneAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this.fromScene(scene, sigma, near, far, options);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) {
      warn('PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using "await renderer.init()" instead.');
      this._setSizeFromTexture(equirectangular);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(equirectangular, renderTarget = null) {
    warnOnce('PMREMGenerator: ".fromEquirectangularAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) {
      warn("PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.");
      this._setSizeFromTexture(cubemap);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromCubemapAsync(cubemap, renderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(cubemap, renderTarget = null) {
    warnOnce('PMREMGenerator: ".fromCubemapAsync()" is deprecated. Use "await renderer.init()" instead.');
    await this._renderer.init();
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      await this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      await this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSizeFromTexture(texture2) {
    if (texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {
      this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || texture2.image[0].image.width);
    } else {
      this._setSize(texture2.image.width / 4);
    }
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._ggxMaterial !== null) this._ggxMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodMeshes.length; i++) {
      this._lodMeshes[i].geometry.dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    this._setSizeFromTexture(texture2);
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    this._init(cubeUVRenderTarget);
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTarget() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const cubeUVRenderTarget = _createRenderTarget(width, height);
    return cubeUVRenderTarget;
  }
  _init(renderTarget) {
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(renderTarget.width, renderTarget.height);
      const { _lodMax } = this;
      ({ lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, renderTarget.width, renderTarget.height);
      this._ggxMaterial = _getGGXShader(_lodMax, renderTarget.width, renderTarget.height);
    }
  }
  async _compileMaterial(material) {
    const mesh = new Mesh(new BufferGeometry(), material);
    await this._renderer.compile(mesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [1, 1, 1, 1, -1, 1];
    const forwardSign = [1, -1, 1, -1, 1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    renderer.getClearColor(_clearColor$2);
    renderer.autoClear = false;
    if (this._backgroundBox === null) {
      this._backgroundBox = new Mesh(
        new BoxGeometry(),
        new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        })
      );
    }
    const backgroundBox = this._backgroundBox;
    const backgroundMaterial = backgroundBox.material;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor$2);
      useSolidColor = true;
    }
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.clear();
    if (useSolidColor) {
      renderer.render(backgroundBox, cubeCamera);
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x + forwardSign[i], position.y, position.z);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y + forwardSign[i], position.z);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.render(scene, cubeCamera);
    }
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture2);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture2);
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    material.fragmentNode.value = texture2;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodMeshes.length;
    for (let i = 1; i < n; i++) {
      this._applyGGXFilter(cubeUVRenderTarget, i - 1, i);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
   * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
   * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
   * applies incremental roughness filtering to avoid over-blurring.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget
   * @param {number} lodIn - Source LOD level to read from
   * @param {number} lodOut - Target LOD level to write to
   */
  _applyGGXFilter(cubeUVRenderTarget, lodIn, lodOut) {
    const renderer = this._renderer;
    const pingPongRenderTarget = this._pingPongRenderTarget;
    const ggxMaterial = this._ggxMaterial;
    const ggxMesh = this._lodMeshes[lodOut];
    ggxMesh.material = ggxMaterial;
    const ggxUniforms = _uniformsMap.get(ggxMaterial);
    const targetRoughness = lodOut / (this._lodMeshes.length - 1);
    const sourceRoughness = lodIn / (this._lodMeshes.length - 1);
    const incrementalRoughness = Math.sqrt(targetRoughness * targetRoughness - sourceRoughness * sourceRoughness);
    const blurStrength = 0 + targetRoughness * 1.25;
    const adjustedRoughness = incrementalRoughness * blurStrength;
    const { _lodMax } = this;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    cubeUVRenderTarget.texture.frame = (cubeUVRenderTarget.texture.frame || 0) + 1;
    ggxUniforms.envMap.value = cubeUVRenderTarget.texture;
    ggxUniforms.roughness.value = adjustedRoughness;
    ggxUniforms.mipInt.value = _lodMax - lodIn;
    _setViewport(pingPongRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(pingPongRenderTarget);
    renderer.render(ggxMesh, _flatCamera);
    pingPongRenderTarget.texture.frame = (pingPongRenderTarget.texture.frame || 0) + 1;
    ggxUniforms.envMap.value = pingPongRenderTarget.texture;
    ggxUniforms.roughness.value = 0;
    ggxUniforms.mipInt.value = _lodMax - lodOut;
    _setViewport(cubeUVRenderTarget, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(ggxMesh, _flatCamera);
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * Used for initial scene blur in fromScene() method when sigma > 0.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = _uniformsMap.get(blurMaterial);
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min2 = -texelSize;
    const max2 = 1 + texelSize;
    const uv1 = [min2, min2, max2, min2, max2, max2, min2, min2, max2, max2, min2, max2];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates, positionSize * vertices * faceIdx);
      uv2.set(uv1, uvSize * vertices * faceIdx);
      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodMeshes, sizeLods, sigmas };
}
function _createRenderTarget(width, height) {
  const params = {
    magFilter: LinearFilter,
    minFilter: LinearFilter,
    generateMipmaps: false,
    type: HalfFloatType,
    format: RGBAFormat,
    colorSpace: LinearSRGBColorSpace
    //depthBuffer: false
  };
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getMaterial(type) {
  const material = new NodeMaterial();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  material.name = `PMREM_${type}`;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform$2(new Vector3(0, 1, 0));
  const dTheta = uniform$2(0);
  const n = float$4(MAX_SAMPLES);
  const latitudinal = uniform$2(0);
  const samples = uniform$2(1);
  const envMap = texture$2();
  const mipInt = uniform$2(0);
  const CUBEUV_TEXEL_WIDTH = float$4(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float$4(1 / height);
  const CUBEUV_MAX_MIP = float$4(lodMax);
  const materialUniforms = {
    n,
    latitudinal,
    weights,
    poleAxis,
    outputDirection: _outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial("blur");
  material.fragmentNode = blur({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getGGXShader(lodMax, width, height) {
  const envMap = texture$2();
  const roughness2 = uniform$2(0);
  const mipInt = uniform$2(0);
  const CUBEUV_TEXEL_WIDTH = float$4(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float$4(1 / height);
  const CUBEUV_MAX_MIP = float$4(lodMax);
  const materialUniforms = {
    envMap,
    roughness: roughness2,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial("ggx");
  material.fragmentNode = ggxConvolution({
    ...materialUniforms,
    N_immutable: _outputDirection,
    GGX_SAMPLES: uint$3(GGX_SAMPLES)
  });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial("cubemap");
  material.fragmentNode = cubeTexture(envTexture, _outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial("equirect");
  material.fragmentNode = texture$2(envTexture, equirectUV(_outputDirection), 0);
  return material;
}
const _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture2, renderer, generator) {
  const cache2 = _getCache(renderer);
  let cacheTexture = cache2.get(texture2);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture2.pmremVersion) {
    const image = texture2.image;
    if (texture2.isCubeTexture) {
      if (isCubeMapReady(image)) {
        cacheTexture = generator.fromCubemap(texture2, cacheTexture);
      } else {
        return null;
      }
    } else {
      if (isEquirectangularMapReady(image)) {
        cacheTexture = generator.fromEquirectangular(texture2, cacheTexture);
      } else {
        return null;
      }
    }
    cacheTexture.pmremVersion = texture2.pmremVersion;
    cache2.set(texture2, cacheTexture);
  }
  return cacheTexture.texture;
}
function _getCache(renderer) {
  let rendererCache = _cache.get(renderer);
  if (rendererCache === void 0) {
    rendererCache = /* @__PURE__ */ new WeakMap();
    _cache.set(renderer, rendererCache);
  }
  return rendererCache;
}
class PMREMNode extends TempNode {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    const defaultTexture = new Texture2();
    defaultTexture.isRenderTargetTexture = true;
    this._texture = texture$2(defaultTexture);
    this._width = uniform$2(0);
    this._height = uniform$2(0);
    this._maxMip = uniform$2(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(texture2) {
    const cubeUVSize = _generateCubeUVSize(texture2.image.height);
    this._texture.value = texture2;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore(frame) {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture2 = this._value;
    if (pmremVersion !== texture2.pmremVersion) {
      if (texture2.isPMREMTexture === true) {
        pmrem = texture2;
      } else {
        pmrem = _getPMREMFromTexture(texture2, frame.renderer, this._generator);
      }
      if (pmrem !== null) {
        this._pmrem = pmrem;
        this.updateFromTexture(pmrem);
      }
    }
  }
  setup(builder) {
    if (this._generator === null) {
      this._generator = new PMREMGenerator(builder.renderer);
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this, builder);
    }
    uvNode = materialEnvRotation.mul(vec3$2(uvNode.x, uvNode.y.negate(), uvNode.z));
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
  dispose() {
    super.dispose();
    if (this._generator !== null) this._generator.dispose();
  }
}
function isCubeMapReady(image) {
  if (image === null || image === void 0) return false;
  let count = 0;
  const length2 = 6;
  for (let i = 0; i < length2; i++) {
    if (image[i] !== void 0) count++;
  }
  return count === length2;
}
function isEquirectangularMapReady(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
const pmremTexture = /* @__PURE__ */ nodeProxy(PMREMNode).setParameterLength(1, 3);
const matcapUV = /* @__PURE__ */ Fn$4(() => {
  const x = vec3$2(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
  const y = positionViewDirection.cross(x);
  return vec2$2(x.dot(normalView), y.dot(normalView)).mul(0.495).add(0.5);
}).once(["NORMAL", "VERTEX"])().toVar("matcapUV");
class RotateNode extends TempNode {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4$3(1, 0, 0, 0), vec4$3(0, cos$1(rotation.x), sin$1(rotation.x).negate(), 0), vec4$3(0, sin$1(rotation.x), cos$1(rotation.x), 0), vec4$3(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4$3(cos$1(rotation.y), 0, sin$1(rotation.y), 0), vec4$3(0, 1, 0, 0), vec4$3(sin$1(rotation.y).negate(), 0, cos$1(rotation.y), 0), vec4$3(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4$3(cos$1(rotation.z), sin$1(rotation.z).negate(), 0, 0), vec4$3(sin$1(rotation.z), cos$1(rotation.z), 0, 0), vec4$3(0, 0, 1, 0), vec4$3(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4$3(positionNode, 1)).xyz;
    }
  }
}
const rotate = /* @__PURE__ */ nodeProxy(RotateNode).setParameterLength(2);
property("vec3");
property("vec3");
property("vec3");
class ChainMap {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMaps = {};
  }
  /**
   * Returns the Weak Map for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {WeakMap} The weak map.
   */
  _getWeakMap(keys) {
    const length2 = keys.length;
    let weakMap = this.weakMaps[length2];
    if (weakMap === void 0) {
      weakMap = /* @__PURE__ */ new WeakMap();
      this.weakMaps[length2] = weakMap;
    }
    return weakMap;
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(keys) {
    let map = this._getWeakMap(keys);
    for (let i = 0; i < keys.length - 1; i++) {
      map = map.get(keys[i]);
      if (map === void 0) return void 0;
    }
    return map.get(keys[keys.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(keys, value) {
    let map = this._getWeakMap(keys);
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (map.has(key) === false) map.set(key, /* @__PURE__ */ new WeakMap());
      map = map.get(key);
    }
    map.set(keys[keys.length - 1], value);
    return this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(keys) {
    let map = this._getWeakMap(keys);
    for (let i = 0; i < keys.length - 1; i++) {
      map = map.get(keys[i]);
      if (map === void 0) return false;
    }
    return map.delete(keys[keys.length - 1]);
  }
}
class ParameterNode extends PropertyNode {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  /**
   * Gets the type of a member variable in the parameter node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {string} name - The name of the member variable.
   * @returns {string}
   */
  getMemberType(builder, name) {
    const type = this.getNodeType(builder);
    const struct2 = builder.getStructTypeNode(type);
    let memberType;
    if (struct2 !== null) {
      memberType = struct2.getMemberType(builder, name);
    } else {
      error(`TSL: Member "${name}" not found in struct "${type}".`);
      memberType = "float";
    }
    return memberType;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const parameter = (type, name) => new ParameterNode(type, name);
class StackNode extends Node {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this._expressionNode = null;
    this._currentNode = null;
    this.isStackNode = true;
  }
  getElementType(builder) {
    return this.hasOutput ? this.outputNode.getElementType(builder) : "void";
  }
  getNodeType(builder) {
    return this.hasOutput ? this.outputNode.getNodeType(builder) : "void";
  }
  getMemberType(builder, name) {
    return this.hasOutput ? this.outputNode.getMemberType(builder, name) : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @param {number} [index=this.nodes.length] - The index where the node should be added.
   * @return {StackNode} A reference to this stack node.
   */
  addToStack(node, index = this.nodes.length) {
    if (node.isNode !== true) {
      error("TSL: Invalid node added to stack.");
      return this;
    }
    this.nodes.splice(index, 0, node);
    return this;
  }
  /**
   * Adds a node to the stack before the current node.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  addToStackBefore(node) {
    const index = this._currentNode ? this.nodes.indexOf(this._currentNode) : 0;
    return this.addToStack(node, index);
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = select$3(boolNode, methodNode);
    return this.addToStack(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = select$3(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(expression2) {
    this._expressionNode = nodeObject(expression2);
    return this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...params) {
    const caseNodes = [];
    if (params.length >= 2) {
      for (let i = 0; i < params.length - 1; i++) {
        caseNodes.push(this._expressionNode.equal(nodeObject(params[i])));
      }
    } else {
      error("TSL: Invalid parameter length. Case() requires at least two parameters.");
    }
    const method = params[params.length - 1];
    const methodNode = new ShaderNode(method);
    let caseNode = caseNodes[0];
    for (let i = 1; i < caseNodes.length; i++) {
      caseNode = caseNode.or(caseNodes[i]);
    }
    const condNode = select$3(caseNode, methodNode);
    if (this._currentCond === null) {
      this._currentCond = condNode;
      return this.addToStack(this._currentCond);
    } else {
      this._currentCond.elseNode = condNode;
      this._currentCond = condNode;
      return this;
    }
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(method) {
    this.Else(method);
    return this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      if (childNode.isVarNode && childNode.isIntent(builder)) {
        if (childNode.isAssign(builder) !== true) {
          continue;
        }
      }
      nodeProperties["node" + index++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  get hasOutput() {
    return this.outputNode && this.outputNode.isNode;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack$3();
    const buildStage = builder.buildStage;
    setCurrentStack$3(this);
    builder.setActiveStack(this);
    const buildNode = (node) => {
      this._currentNode = node;
      if (node.isVarNode && node.isIntent(builder)) {
        if (node.isAssign(builder) !== true) {
          return;
        }
      }
      if (buildStage === "setup") {
        node.build(builder);
      } else if (buildStage === "analyze") {
        node.build(builder, this);
      } else if (buildStage === "generate") {
        const stages = builder.getDataFromNode(node, "any").stages;
        const parents = stages && stages[builder.shaderStage];
        if (node.isVarNode && parents && parents.length === 1 && parents[0] && parents[0].isStackNode) {
          return;
        }
        node.build(builder, "void");
      }
    };
    const nodes = [...this.nodes];
    for (const node of nodes) {
      buildNode(node);
    }
    this._currentNode = null;
    const newNodes = this.nodes.filter((node) => nodes.indexOf(node) === -1);
    for (const node of newNodes) {
      buildNode(node);
    }
    let result;
    if (this.hasOutput) {
      result = this.outputNode.build(builder, ...params);
    } else {
      result = super.build(builder, ...params);
    }
    setCurrentStack$3(previousStack);
    builder.removeActiveStack(this);
    return result;
  }
}
const stack = /* @__PURE__ */ nodeProxy(StackNode).setParameterLength(0, 1);
function getMembersLayout(members) {
  return Object.entries(members).map(([name, value]) => {
    if (typeof value === "string") {
      return { name, type: value, atomic: false };
    }
    return { name, type: value.type, atomic: value.atomic || false };
  });
}
class StructTypeNode extends Node {
  static get type() {
    return "StructTypeNode";
  }
  /**
   * Creates an instance of StructTypeNode.
   *
   * @param {Object} membersLayout - The layout of the members for the struct.
   * @param {?string} [name=null] - The optional name of the struct.
   */
  constructor(membersLayout, name = null) {
    super("struct");
    this.membersLayout = getMembersLayout(membersLayout);
    this.name = name;
    this.isStructLayoutNode = true;
  }
  /**
   * Returns the length of the struct.
   * The length is calculated by summing the lengths of the struct's members.
   *
   * @returns {number} The length of the struct.
   */
  getLength() {
    const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
    let maxAlignment = 1;
    let offset = 0;
    for (const member of this.membersLayout) {
      const type = member.type;
      const itemSize = getMemoryLengthFromType(type);
      const alignment = getAlignmentFromType(type) / BYTES_PER_ELEMENT;
      maxAlignment = Math.max(maxAlignment, alignment);
      const chunkOffset = offset % maxAlignment;
      const overhang = chunkOffset % alignment;
      if (overhang !== 0) {
        offset += alignment - overhang;
      }
      offset += itemSize;
    }
    return Math.ceil(offset / maxAlignment) * maxAlignment;
  }
  getMemberType(builder, name) {
    const member = this.membersLayout.find((m) => m.name === name);
    return member ? member.type : "void";
  }
  getNodeType(builder) {
    const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    return structType.name;
  }
  setup(builder) {
    builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    builder.addInclude(this);
  }
  generate(builder) {
    return this.getNodeType(builder);
  }
}
class StructNode extends Node {
  static get type() {
    return "StructNode";
  }
  constructor(structTypeNode, values) {
    super("vec3");
    this.structTypeNode = structTypeNode;
    this.values = values;
    this.isStructNode = true;
  }
  getNodeType(builder) {
    return this.structTypeNode.getNodeType(builder);
  }
  getMemberType(builder, name) {
    return this.structTypeNode.getMemberType(builder, name);
  }
  generate(builder) {
    const nodeVar = builder.getVarFromNode(this);
    const structType = nodeVar.type;
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(`${propertyName} = ${builder.generateStruct(structType, this.structTypeNode.membersLayout, this.values)}`, this);
    return nodeVar.name;
  }
}
const struct = (membersLayout, name = null) => {
  const structLayout = new StructTypeNode(membersLayout, name);
  const struct2 = (...params) => {
    let values = null;
    if (params.length > 0) {
      if (params[0].isNode) {
        values = {};
        const names = Object.keys(membersLayout);
        for (let i = 0; i < params.length; i++) {
          values[names[i]] = params[i];
        }
      } else {
        values = params[0];
      }
    }
    return new StructNode(structLayout, values);
  };
  struct2.layout = structLayout;
  struct2.isStruct = true;
  return struct2;
};
class OutputStructNode extends Node {
  static get type() {
    return "OutputStructNode";
  }
  /**
   * Constructs a new output struct node. The constructor can be invoked with an
   * arbitrary number of nodes representing the members.
   *
   * @param {...Node} members - A parameter list of nodes.
   */
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.membersLayout === void 0) {
      const members = this.members;
      const membersLayout = [];
      for (let i = 0; i < members.length; i++) {
        const name = "m" + i;
        const type = members[i].getNodeType(builder);
        membersLayout.push({ name, type, index: i });
      }
      properties.membersLayout = membersLayout;
      properties.structType = builder.getOutputStructTypeFromNode(this, properties.membersLayout);
    }
    return properties.structType.name;
  }
  generate(builder) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
    }
    return propertyName;
  }
}
const outputStruct = /* @__PURE__ */ nodeProxy(OutputStructNode);
function getTextureIndex(textures, name) {
  for (let i = 0; i < textures.length; i++) {
    if (textures[i].name === name) {
      return i;
    }
  }
  return -1;
}
class MRTNode extends OutputStructNode {
  static get type() {
    return "MRTNode";
  }
  /**
   * Constructs a new output struct node.
   *
   * @param {Object<string, Node>} outputNodes - The MRT outputs.
   */
  constructor(outputNodes) {
    super();
    this.outputNodes = outputNodes;
    this.isMRTNode = true;
  }
  /**
   * Returns `true` if the MRT node has an output with the given name.
   *
   * @param {string} name - The name of the output.
   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
   */
  has(name) {
    return this.outputNodes[name] !== void 0;
  }
  /**
   * Returns the output node for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {Node} The output node.
   */
  get(name) {
    return this.outputNodes[name];
  }
  /**
   * Merges the outputs of the given MRT node with the outputs of this node.
   *
   * @param {MRTNode} mrtNode - The MRT to merge.
   * @return {MRTNode} A new MRT node with merged outputs..
   */
  merge(mrtNode) {
    const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
    return mrt(outputs);
  }
  setup(builder) {
    const outputNodes = this.outputNodes;
    const mrt2 = builder.renderer.getRenderTarget();
    const members = [];
    const textures = mrt2.textures;
    for (const name in outputNodes) {
      const index = getTextureIndex(textures, name);
      members[index] = vec4$3(outputNodes[name]);
    }
    this.members = members;
    return super.setup(builder);
  }
}
const mrt = /* @__PURE__ */ nodeProxy(MRTNode);
class BitcastNode extends TempNode {
  static get type() {
    return "BitcastNode";
  }
  /**
   * Constructs a new bitcast node.
   *
   * @param {Node} valueNode - The value to convert.
   * @param {string} conversionType - The type to convert to.
   * @param {?string} [inputType = null] - The expected input data type of the bitcast operation.
   */
  constructor(valueNode, conversionType, inputType = null) {
    super();
    this.valueNode = valueNode;
    this.conversionType = conversionType;
    this.inputType = inputType;
    this.isBitcastNode = true;
  }
  getNodeType(builder) {
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueLength = builder.getTypeLength(valueType);
      return builder.getTypeFromLength(valueLength, this.conversionType);
    }
    return this.conversionType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    let inputType = "";
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueTypeLength = builder.getTypeLength(valueType);
      inputType = valueTypeLength === 1 ? this.inputType : builder.changeComponentType(valueType, this.inputType);
    } else {
      inputType = this.valueNode.getNodeType(builder);
    }
    return `${builder.getBitcastMethod(type, inputType)}( ${this.valueNode.build(builder, inputType)} )`;
  }
}
const bitcast = /* @__PURE__ */ nodeProxyIntent(BitcastNode).setParameterLength(2);
const floatBitsToInt = (value) => new BitcastNode(value, "int", "float");
const floatBitsToUint = (value) => new BitcastNode(value, "uint", "float");
const intBitsToFloat = (value) => new BitcastNode(value, "float", "int");
const uintBitsToFloat = (value) => new BitcastNode(value, "float", "uint");
const registeredBitcountFunctions = {};
class BitcountNode extends MathNode {
  static get type() {
    return "BitcountNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {'countTrailingZeros'|'countLeadingZeros'|'countOneBits'} method - The method name.
   * @param {Node} aNode - The first input.
   */
  constructor(method, aNode) {
    super(method, aNode);
    this.isBitcountNode = true;
  }
  /**
   * Casts the input value of the function to an integer if necessary.
   *
   * @private
   * @param {Node<uint>|Node<int>} inputNode - The input value.
   * @param {Node<uint>} outputNode - The output value.
   * @param {string} elementType - The type of the input value.
   */
  _resolveElementType(inputNode, outputNode, elementType) {
    if (elementType === "int") {
      outputNode.assign(bitcast(inputNode, "uint"));
    } else {
      outputNode.assign(inputNode);
    }
  }
  _returnDataNode(inputType) {
    switch (inputType) {
      case "uint": {
        return uint$3;
      }
      case "int": {
        return int$3;
      }
      case "uvec2": {
        return uvec2;
      }
      case "uvec3": {
        return uvec3;
      }
      case "uvec4": {
        return uvec4;
      }
      case "ivec2": {
        return ivec2$2;
      }
      case "ivec3": {
        return ivec3$3;
      }
      case "ivec4": {
        return ivec4;
      }
    }
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countTrailingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createTrailingZerosBaseLayout(method, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn$4(([value]) => {
      const v = uint$3(0);
      this._resolveElementType(value, v, elementType);
      const f = float$4(v.bitAnd(negate(v)));
      const uintBits = floatBitsToUint(f);
      const numTrailingZeros = uintBits.shiftRight(23).sub(127);
      return outputConvertNode(numTrailingZeros);
    }).setLayout({
      name: method,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countLeadingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createLeadingZerosBaseLayout(method, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn$4(([value]) => {
      If(value.equal(uint$3(0)), () => {
        return uint$3(32);
      });
      const v = uint$3(0);
      const n = uint$3(0);
      this._resolveElementType(value, v, elementType);
      If(v.shiftRight(16).equal(0), () => {
        n.addAssign(16);
        v.shiftLeftAssign(16);
      });
      If(v.shiftRight(24).equal(0), () => {
        n.addAssign(8);
        v.shiftLeftAssign(8);
      });
      If(v.shiftRight(28).equal(0), () => {
        n.addAssign(4);
        v.shiftLeftAssign(4);
      });
      If(v.shiftRight(30).equal(0), () => {
        n.addAssign(2);
        v.shiftLeftAssign(2);
      });
      If(v.shiftRight(31).equal(0), () => {
        n.addAssign(1);
      });
      return outputConvertNode(n);
    }).setLayout({
      name: method,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countOneBits.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createOneBitsBaseLayout(method, elementType) {
    const outputConvertNode = this._returnDataNode(elementType);
    const fnDef = Fn$4(([value]) => {
      const v = uint$3(0);
      this._resolveElementType(value, v, elementType);
      v.assign(v.sub(v.shiftRight(uint$3(1)).bitAnd(uint$3(1431655765))));
      v.assign(v.bitAnd(uint$3(858993459)).add(v.shiftRight(uint$3(2)).bitAnd(uint$3(858993459))));
      const numBits = v.add(v.shiftRight(uint$3(4))).bitAnd(uint$3(252645135)).mul(uint$3(16843009)).shiftRight(uint$3(24));
      return outputConvertNode(numBits);
    }).setLayout({
      name: method,
      type: elementType,
      inputs: [
        { name: "value", type: elementType }
      ]
    });
    return fnDef;
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of the specified bitcount function.
   * including considerations for component-wise bitcounts on vector type inputs.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} inputType - The type of the input value.
   * @param {number} typeLength - The vec length of the input value.
   * @param {Function} baseFn - The base function that operates on an individual component of the vector.
   * @returns {Function} - The alias function for the specified bitcount method.
   */
  _createMainLayout(method, inputType, typeLength, baseFn) {
    const outputConvertNode = this._returnDataNode(inputType);
    const fnDef = Fn$4(([value]) => {
      if (typeLength === 1) {
        return outputConvertNode(baseFn(value));
      } else {
        const vec = outputConvertNode(0);
        const components = ["x", "y", "z", "w"];
        for (let i = 0; i < typeLength; i++) {
          const component = components[i];
          vec[component].assign(baseFn(value[component]));
        }
        return vec;
      }
    }).setLayout({
      name: method,
      type: inputType,
      inputs: [
        { name: "value", type: inputType }
      ]
    });
    return fnDef;
  }
  setup(builder) {
    const { method, aNode } = this;
    const { renderer } = builder;
    if (renderer.backend.isWebGPUBackend) {
      return super.setup(builder);
    }
    const inputType = this.getInputType(builder);
    const elementType = builder.getElementType(inputType);
    const typeLength = builder.getTypeLength(inputType);
    const baseMethod = `${method}_base_${elementType}`;
    const newMethod = `${method}_${inputType}`;
    let baseFn = registeredBitcountFunctions[baseMethod];
    if (baseFn === void 0) {
      switch (method) {
        case BitcountNode.COUNT_LEADING_ZEROS: {
          baseFn = this._createLeadingZerosBaseLayout(baseMethod, elementType);
          break;
        }
        case BitcountNode.COUNT_TRAILING_ZEROS: {
          baseFn = this._createTrailingZerosBaseLayout(baseMethod, elementType);
          break;
        }
        case BitcountNode.COUNT_ONE_BITS: {
          baseFn = this._createOneBitsBaseLayout(baseMethod, elementType);
          break;
        }
      }
      registeredBitcountFunctions[baseMethod] = baseFn;
    }
    let fn = registeredBitcountFunctions[newMethod];
    if (fn === void 0) {
      fn = this._createMainLayout(newMethod, inputType, typeLength, baseFn);
      registeredBitcountFunctions[newMethod] = fn;
    }
    const output2 = Fn$4(() => {
      return fn(
        aNode
      );
    });
    return output2();
  }
}
BitcountNode.COUNT_TRAILING_ZEROS = "countTrailingZeros";
BitcountNode.COUNT_LEADING_ZEROS = "countLeadingZeros";
BitcountNode.COUNT_ONE_BITS = "countOneBits";
const countTrailingZeros = /* @__PURE__ */ nodeProxyIntent(BitcountNode, BitcountNode.COUNT_TRAILING_ZEROS).setParameterLength(1);
const countLeadingZeros = /* @__PURE__ */ nodeProxyIntent(BitcountNode, BitcountNode.COUNT_LEADING_ZEROS).setParameterLength(1);
const countOneBits = /* @__PURE__ */ nodeProxyIntent(BitcountNode, BitcountNode.COUNT_ONE_BITS).setParameterLength(1);
const hash = /* @__PURE__ */ Fn$4(([seed]) => {
  const state = seed.toUint().mul(747796405).add(2891336453);
  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
  const result = word.shiftRight(22).bitXor(word);
  return result.toFloat().mul(1 / 2 ** 32);
});
const parabola = (x, k) => pow(mul$3(4, x.mul(sub$3(1, x))), k);
const gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2), k).div(2) : sub$3(1, parabola(mul$3(sub$3(1, x), 2), k).div(2));
const pcurve = (x, a, b) => pow(div$2(pow(x, a), add$3(pow(x, a), pow(sub$3(1, x), b))), 1 / a);
const sinc = (x, k) => sin$1(PI$1.mul(k.mul(x).sub(1))).div(PI$1.mul(k.mul(x).sub(1)));
class PackFloatNode extends TempNode {
  static get type() {
    return "PackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @param {Node} vectorNode - The vector node to be packed
   */
  constructor(encoding, vectorNode) {
    super();
    this.vectorNode = vectorNode;
    this.encoding = encoding;
    this.isPackFloatNode = true;
  }
  getNodeType() {
    return "uint";
  }
  generate(builder) {
    const inputType = this.vectorNode.getNodeType(builder);
    return `${builder.getFloatPackingMethod(this.encoding)}(${this.vectorNode.build(builder, inputType)})`;
  }
}
const packSnorm2x16 = /* @__PURE__ */ nodeProxyIntent(PackFloatNode, "snorm").setParameterLength(1);
const packUnorm2x16 = /* @__PURE__ */ nodeProxyIntent(PackFloatNode, "unorm").setParameterLength(1);
const packHalf2x16 = /* @__PURE__ */ nodeProxyIntent(PackFloatNode, "float16").setParameterLength(1);
class UnpackFloatNode extends TempNode {
  static get type() {
    return "UnpackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the integer values are mapped to the float range
   * @param {Node} uintNode - The uint node to be unpacked
   */
  constructor(encoding, uintNode) {
    super();
    this.uintNode = uintNode;
    this.encoding = encoding;
    this.isUnpackFloatNode = true;
  }
  getNodeType() {
    return "vec2";
  }
  generate(builder) {
    const inputType = this.uintNode.getNodeType(builder);
    return `${builder.getFloatUnpackingMethod(this.encoding)}(${this.uintNode.build(builder, inputType)})`;
  }
}
const unpackSnorm2x16 = /* @__PURE__ */ nodeProxyIntent(UnpackFloatNode, "snorm").setParameterLength(1);
const unpackUnorm2x16 = /* @__PURE__ */ nodeProxyIntent(UnpackFloatNode, "unorm").setParameterLength(1);
const unpackHalf2x16$1 = /* @__PURE__ */ nodeProxyIntent(UnpackFloatNode, "float16").setParameterLength(1);
const tri = /* @__PURE__ */ Fn$4(([x]) => {
  return x.fract().sub(0.5).abs();
}).setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
const tri3 = /* @__PURE__ */ Fn$4(([p]) => {
  return vec3$2(tri(p.z.add(tri(p.y.mul(1)))), tri(p.z.add(tri(p.x.mul(1)))), tri(p.y.add(tri(p.x.mul(1)))));
}).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
const triNoise3D = /* @__PURE__ */ Fn$4(([position, speed, time2]) => {
  const p = vec3$2(position).toVar();
  const z = float$4(1.4).toVar();
  const rz = float$4(0).toVar();
  const bp = vec3$2(p).toVar();
  Loop({ start: float$4(0), end: float$4(3), type: "float", condition: "<=" }, () => {
    const dg = vec3$2(tri3(bp.mul(2))).toVar();
    p.addAssign(dg.add(time2.mul(float$4(0.1).mul(speed))));
    bp.mulAssign(1.8);
    z.mulAssign(1.5);
    p.mulAssign(1.2);
    const t = float$4(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
    rz.addAssign(t.div(z));
    bp.addAssign(0.14);
  });
  return rz;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" },
    { name: "speed", type: "float" },
    { name: "time", type: "float" }
  ]
});
class FunctionOverloadingNode extends Node {
  static get type() {
    return "FunctionOverloadingNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @param {...Node} parametersNodes - A list of parameter nodes.
   */
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFn = null;
    this.global = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the function's return type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const candidateFn = this.getCandidateFn(builder);
    return candidateFn.shaderNode.layout.type;
  }
  /**
   * Returns the candidate function for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {FunctionNode} The candidate function.
   */
  getCandidateFn(builder) {
    const params = this.parametersNodes;
    let candidateFn = this._candidateFn;
    if (candidateFn === null) {
      let bestCandidateFn = null;
      let bestScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let currentScore = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              currentScore++;
            }
          }
          if (currentScore > bestScore) {
            bestCandidateFn = functionNode;
            bestScore = currentScore;
          }
        }
      }
      this._candidateFn = candidateFn = bestCandidateFn;
    }
    return candidateFn;
  }
  /**
   * Sets up the node for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The setup node.
   */
  setup(builder) {
    const candidateFn = this.getCandidateFn(builder);
    return candidateFn(...this.parametersNodes);
  }
}
const overloadingBaseFn = /* @__PURE__ */ nodeProxy(FunctionOverloadingNode);
const overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
const time = /* @__PURE__ */ uniform$2(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.time);
const deltaTime = /* @__PURE__ */ uniform$2(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.deltaTime);
const frameId = /* @__PURE__ */ uniform$2(0, "uint").setGroup(renderGroup).onRenderUpdate((frame) => frame.frameId);
const oscSine = (t = time) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
const oscSquare = (t = time) => t.fract().round();
const oscTriangle = (t = time) => t.add(0.5).fract().mul(2).sub(1).abs();
const oscSawtooth = (t = time) => t.fract();
function replaceDefaultUV(callback, node = null) {
  return context(node, { getUV: callback });
}
const rotateUV = /* @__PURE__ */ Fn$4(([uv2, rotation, center = vec2$2(0.5)]) => {
  return rotate(uv2.sub(center), rotation).add(center);
});
const spherizeUV = /* @__PURE__ */ Fn$4(([uv2, strength, center = vec2$2(0.5)]) => {
  const delta = uv2.sub(center);
  const delta2 = delta.dot(delta);
  const delta4 = delta2.mul(delta2);
  const deltaOffset = delta4.mul(strength);
  return uv2.add(delta.mul(deltaOffset));
});
const billboarding = /* @__PURE__ */ Fn$4(({ position = null, horizontal = true, vertical = false }) => {
  let worldMatrix;
  if (position !== null) {
    worldMatrix = modelWorldMatrix.toVar();
    worldMatrix[3][0] = position.x;
    worldMatrix[3][1] = position.y;
    worldMatrix[3][2] = position.z;
  } else {
    worldMatrix = modelWorldMatrix;
  }
  const modelViewMatrix2 = cameraViewMatrix.mul(worldMatrix);
  if (defined(horizontal)) {
    modelViewMatrix2[0][0] = modelWorldMatrix[0].length();
    modelViewMatrix2[0][1] = 0;
    modelViewMatrix2[0][2] = 0;
  }
  if (defined(vertical)) {
    modelViewMatrix2[1][0] = 0;
    modelViewMatrix2[1][1] = modelWorldMatrix[1].length();
    modelViewMatrix2[1][2] = 0;
  }
  modelViewMatrix2[2][0] = 0;
  modelViewMatrix2[2][1] = 0;
  modelViewMatrix2[2][2] = 1;
  return cameraProjectionMatrix.mul(modelViewMatrix2).mul(positionLocal$1);
});
const viewportSafeUV = /* @__PURE__ */ Fn$4(([uv2 = null]) => {
  const depth2 = linearDepth();
  const depthDiff = linearDepth(viewportDepthTexture(uv2)).sub(depth2);
  const finalUV = depthDiff.lessThan(0).select(screenUV, uv2);
  return finalUV;
});
class SpriteSheetUVNode extends Node {
  static get type() {
    return "SpriteSheetUVNode";
  }
  /**
   * Constructs a new sprite sheet uv node.
   *
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   */
  constructor(countNode, uvNode = uv$1(), frameNode = float$4(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2$2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
}
const spritesheetUV = /* @__PURE__ */ nodeProxy(SpriteSheetUVNode).setParameterLength(3);
const triplanarTextures = /* @__PURE__ */ Fn$4(([textureXNode, textureYNode = null, textureZNode = null, scaleNode = float$4(1), positionNode = positionLocal$1, normalNode = normalLocal]) => {
  let bf = normalNode.abs().normalize();
  bf = bf.div(bf.dot(vec3$2(1)));
  const tx = positionNode.yz.mul(scaleNode);
  const ty = positionNode.zx.mul(scaleNode);
  const tz = positionNode.xy.mul(scaleNode);
  const textureX = textureXNode.value;
  const textureY = textureYNode !== null ? textureYNode.value : textureX;
  const textureZ = textureZNode !== null ? textureZNode.value : textureX;
  const cx = texture$2(textureX, tx).mul(bf.x);
  const cy = texture$2(textureY, ty).mul(bf.y);
  const cz = texture$2(textureZ, tz).mul(bf.z);
  return add$3(cx, cy, cz);
});
const triplanarTexture = (...params) => triplanarTextures(...params);
const _reflectorPlane = new Plane();
const _normal = new Vector3();
const _reflectorWorldPosition = new Vector3();
const _cameraWorldPosition = new Vector3();
const _rotationMatrix = new Matrix4();
const _lookAtPosition = new Vector3(0, 0, -1);
const clipPlane = new Vector4();
const _view = new Vector3();
const _target = new Vector3();
const _q = new Vector4();
const _size$2 = new Vector2();
const _defaultRT = new RenderTarget();
const _defaultUV = screenUV.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
let _inReflector = false;
class ReflectorNode extends TextureNode {
  static get type() {
    return "ReflectorNode";
  }
  /**
   * Constructs a new reflector node.
   *
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   */
  constructor(parameters = {}) {
    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
    this._depthNode = null;
    this.setUpdateMatrix(false);
  }
  /**
   * A reference to the internal reflector node.
   *
   * @type {ReflectorBaseNode}
   */
  get reflector() {
    return this._reflectorBaseNode;
  }
  /**
   * A reference to 3D object the reflector is linked to.
   *
   * @type {Object3D}
   */
  get target() {
    return this._reflectorBaseNode.target;
  }
  /**
   * Returns a node representing the mirror's depth. That can be used
   * to implement more advanced reflection effects like distance attenuation.
   *
   * @return {Node} The depth node.
   */
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== true) {
        throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
      }
      this._depthNode = nodeObject(new ReflectorNode({
        defaultTexture: _defaultRT.depthTexture,
        reflector: this._reflectorBaseNode
      }));
    }
    return this._depthNode;
  }
  setup(builder) {
    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.reflectorNode);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    newNode._reflectorBaseNode = this._reflectorBaseNode;
    return newNode;
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    this._reflectorBaseNode.dispose();
  }
}
class ReflectorBaseNode extends Node {
  static get type() {
    return "ReflectorBaseNode";
  }
  /**
   * Constructs a new reflector base node.
   *
   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   */
  constructor(textureNode, parameters = {}) {
    super();
    const {
      target = new Object3D(),
      resolutionScale = 1,
      generateMipmaps = false,
      bounces = true,
      depth: depth2 = false,
      samples = 0
    } = parameters;
    this.textureNode = textureNode;
    this.target = target;
    this.resolutionScale = resolutionScale;
    if (parameters.resolution !== void 0) {
      warnOnce('ReflectorNode: The "resolution" parameter has been renamed to "resolutionScale".');
      this.resolutionScale = parameters.resolution;
    }
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.depth = depth2;
    this.samples = samples;
    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new Map();
    this.forceUpdate = false;
    this.hasOutput = false;
  }
  /**
   * Updates the resolution of the internal render target.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target to resize.
   * @param {Renderer} renderer - The renderer that is used to determine the new size.
   */
  _updateResolution(renderTarget, renderer) {
    const resolution = this.resolutionScale;
    renderer.getDrawingBufferSize(_size$2);
    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    for (const renderTarget of this.renderTargets.values()) {
      renderTarget.dispose();
    }
  }
  /**
   * Returns a virtual camera for the given camera. The virtual camera is used to
   * render the scene from the reflector's view so correct reflections can be produced.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {Camera} The corresponding virtual camera.
   */
  getVirtualCamera(camera) {
    let virtualCamera = this.virtualCameras.get(camera);
    if (virtualCamera === void 0) {
      virtualCamera = camera.clone();
      this.virtualCameras.set(camera, virtualCamera);
    }
    return virtualCamera;
  }
  /**
   * Returns a render target for the given camera. The reflections are rendered
   * into this render target.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {RenderTarget} The render target.
   */
  getRenderTarget(camera) {
    let renderTarget = this.renderTargets.get(camera);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType, samples: this.samples });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      if (this.depth === true) {
        renderTarget.depthTexture = new DepthTexture();
      }
      this.renderTargets.set(camera, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame) {
    if (this.bounces === false && _inReflector) return false;
    _inReflector = true;
    const { scene, camera, renderer, material } = frame;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer.getDrawingBufferSize(_size$2);
    this._updateResolution(renderTarget, renderer);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal.set(0, 0, 1);
    _normal.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    const isFacingAway = _view.dot(_normal) > 0;
    let needsClear = false;
    if (isFacingAway === true && this.forceUpdate === false) {
      if (this.hasOutput === false) {
        _inReflector = false;
        return;
      }
      needsClear = true;
    }
    _view.reflect(_normal).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target.reflect(_normal).negate();
    _target.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal);
    virtualCamera.lookAt(_target);
    virtualCamera.near = camera.near;
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.textureNode.value = renderTarget.texture;
    if (this.depth === true) {
      this.textureNode.getDepthNode().value = renderTarget.depthTexture;
    }
    material.visible = false;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    const currentAutoClear = renderer.autoClear;
    renderer.setMRT(null);
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = true;
    const previousName = scene.name;
    scene.name = (scene.name || "Scene") + " [ Reflector ]";
    if (needsClear) {
      renderer.clear();
      this.hasOutput = false;
    } else {
      renderer.render(scene, virtualCamera);
      this.hasOutput = true;
    }
    scene.name = previousName;
    renderer.setMRT(currentMRT);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.autoClear = currentAutoClear;
    material.visible = true;
    _inReflector = false;
    this.forceUpdate = false;
  }
  /**
   * The resolution scale.
   *
   * @deprecated
   * @type {number}
   * @default {1}
   */
  get resolution() {
    warnOnce('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    return this.resolutionScale;
  }
  set resolution(value) {
    warnOnce('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    this.resolutionScale = value;
  }
}
const reflector = (parameters) => new ReflectorNode(parameters);
const _camera = /* @__PURE__ */ new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class QuadGeometry extends BufferGeometry {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(flipY = false) {
    super();
    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv2, 2));
  }
}
const _geometry = /* @__PURE__ */ new QuadGeometry();
class QuadMesh extends Mesh {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera;
    this.isQuadMesh = true;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @deprecated
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(renderer) {
    warnOnce('QuadMesh: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.');
    await renderer.init();
    renderer.render(this, _camera);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(renderer) {
    renderer.render(this, _camera);
  }
}
const _size$1 = /* @__PURE__ */ new Vector2();
class RTTNode extends TextureNode {
  static get type() {
    return "RTTNode";
  }
  /**
   * Constructs a new RTT node.
   *
   * @param {Node} node - The node to render a texture with.
   * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {?number} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   */
  constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
    const renderTarget = new RenderTarget(width, height, options);
    super(renderTarget.texture, uv$1());
    this.isRTTNode = true;
    this.node = node;
    this.width = width;
    this.height = height;
    this.pixelRatio = 1;
    this.renderTarget = renderTarget;
    this.textureNeedsUpdate = true;
    this.autoUpdate = true;
    this._rttNode = null;
    this._quadMesh = new QuadMesh(new NodeMaterial());
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  /**
   * Whether the internal render target should automatically be resized or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get autoResize() {
    return this.width === null;
  }
  setup(builder) {
    this._rttNode = this.node.context(builder.getSharedContext());
    this._quadMesh.material.name = "RTT";
    this._quadMesh.material.needsUpdate = true;
    return super.setup(builder);
  }
  /**
   * Sets the size of the internal render target
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(width, height) {
    this.width = width;
    this.height = height;
    const effectiveWidth = width * this.pixelRatio;
    const effectiveHeight = height * this.pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    this.textureNeedsUpdate = true;
  }
  /**
   * Sets the pixel ratio. This will also resize the render target.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this.pixelRatio = pixelRatio;
    this.setSize(this.width, this.height);
  }
  updateBefore({ renderer }) {
    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
    this.textureNeedsUpdate = false;
    if (this.autoResize === true) {
      const pixelRatio = renderer.getPixelRatio();
      const size = renderer.getSize(_size$1);
      const effectiveWidth = Math.floor(size.width * pixelRatio);
      const effectiveHeight = Math.floor(size.height * pixelRatio);
      if (effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height) {
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
        this.textureNeedsUpdate = true;
      }
    }
    let name = "RTT";
    if (this.node.name) {
      name = this.node.name + " [ " + name + " ]";
    }
    this._quadMesh.material.fragmentNode = this._rttNode;
    this._quadMesh.name = name;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.setRenderTarget(this.renderTarget);
    this._quadMesh.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
  }
  clone() {
    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    newNode.referenceNode = this;
    return newNode;
  }
}
const rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));
const convertToTexture = (node, ...params) => {
  if (node.isSampleNode || node.isTextureNode) return node;
  if (node.isPassNode) return node.getTextureNode();
  return rtt(node, ...params);
};
const getViewPosition = /* @__PURE__ */ Fn$4(([screenPosition, depth2, projectionMatrixInverse], builder) => {
  let clipSpacePosition;
  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
    screenPosition = vec2$2(screenPosition.x, screenPosition.y.oneMinus()).mul(2).sub(1);
    clipSpacePosition = vec4$3(vec3$2(screenPosition, depth2), 1);
  } else {
    clipSpacePosition = vec4$3(vec3$2(screenPosition.x, screenPosition.y.oneMinus(), depth2).mul(2).sub(1), 1);
  }
  const viewSpacePosition = vec4$3(projectionMatrixInverse.mul(clipSpacePosition));
  return viewSpacePosition.xyz.div(viewSpacePosition.w);
});
const getScreenPosition = /* @__PURE__ */ Fn$4(([viewPosition, projectionMatrix]) => {
  const sampleClipPos = projectionMatrix.mul(vec4$3(viewPosition, 1));
  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
  return vec2$2(sampleUv.x, sampleUv.y.oneMinus());
});
const getNormalFromDepth = /* @__PURE__ */ Fn$4(([uv2, depthTexture, projectionMatrixInverse]) => {
  const size = textureSize(textureLoad$2(depthTexture));
  const p = ivec2$2(uv2.mul(size)).toVar();
  const c0 = textureLoad$2(depthTexture, p).toVar();
  const l2 = textureLoad$2(depthTexture, p.sub(ivec2$2(2, 0))).toVar();
  const l1 = textureLoad$2(depthTexture, p.sub(ivec2$2(1, 0))).toVar();
  const r1 = textureLoad$2(depthTexture, p.add(ivec2$2(1, 0))).toVar();
  const r2 = textureLoad$2(depthTexture, p.add(ivec2$2(2, 0))).toVar();
  const b22 = textureLoad$2(depthTexture, p.add(ivec2$2(0, 2))).toVar();
  const b1 = textureLoad$2(depthTexture, p.add(ivec2$2(0, 1))).toVar();
  const t1 = textureLoad$2(depthTexture, p.sub(ivec2$2(0, 1))).toVar();
  const t2 = textureLoad$2(depthTexture, p.sub(ivec2$2(0, 2))).toVar();
  const dl = abs$2(sub$3(float$4(2).mul(l1).sub(l2), c0)).toVar();
  const dr = abs$2(sub$3(float$4(2).mul(r1).sub(r2), c0)).toVar();
  const db = abs$2(sub$3(float$4(2).mul(b1).sub(b22), c0)).toVar();
  const dt = abs$2(sub$3(float$4(2).mul(t1).sub(t2), c0)).toVar();
  const ce = getViewPosition(uv2, c0, projectionMatrixInverse).toVar();
  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv2.sub(vec2$2(float$4(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv2.add(vec2$2(float$4(1).div(size.x), 0)), r1, projectionMatrixInverse)));
  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv2.add(vec2$2(0, float$4(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv2.sub(vec2$2(0, float$4(1).div(size.y))), t1, projectionMatrixInverse)));
  return normalize$1(cross$1(dpdx, dpdy));
});
const interleavedGradientNoise = Fn$4(([position]) => {
  return fract(float$4(52.9829189).mul(fract(dot$3(position, vec2$2(0.06711056, 583715e-8)))));
}).setLayout({
  name: "interleavedGradientNoise",
  type: "float",
  inputs: [
    { name: "position", type: "vec2" }
  ]
});
const vogelDiskSample = Fn$4(([sampleIndex, samplesCount, phi]) => {
  const goldenAngle = float$4(2.399963229728653);
  const r = sqrt$3(float$4(sampleIndex).add(0.5).div(float$4(samplesCount)));
  const theta = float$4(sampleIndex).mul(goldenAngle).add(phi);
  return vec2$2(cos$1(theta), sin$1(theta)).mul(r);
}).setLayout({
  name: "vogelDiskSample",
  type: "vec2",
  inputs: [
    { name: "sampleIndex", type: "int" },
    { name: "samplesCount", type: "int" },
    { name: "phi", type: "float" }
  ]
});
class SampleNode extends Node {
  /**
   * Returns the type of the node.
   *
   * @type {string}
   * @readonly
   * @static
   */
  static get type() {
    return "SampleNode";
  }
  /**
   * Creates an instance of SampleNode.
   *
   * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
   * @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.
   */
  constructor(callback, uvNode = null) {
    super();
    this.callback = callback;
    this.uvNode = uvNode;
    this.isSampleNode = true;
  }
  /**
   * Sets up the node by sampling with the default UV accessor.
   *
   * @returns {Node} The result of the callback function when called with the UV node.
   */
  setup() {
    return this.sample(uv$1());
  }
  /**
   * Calls the callback function with the provided UV node.
   *
   * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
   * @returns {Node} The result of the callback function.
   */
  sample(uv2) {
    return this.callback(uv2);
  }
}
const sample = (callback, uv2 = null) => new SampleNode(callback, nodeObject(uv2));
class EventNode extends Node {
  static get type() {
    return "EventNode";
  }
  /**
   * Creates an EventNode.
   *
   * @param {string} eventType - The type of event
   * @param {Function} callback - The callback to execute on update.
   */
  constructor(eventType, callback) {
    super("void");
    this.eventType = eventType;
    this.callback = callback;
    if (eventType === EventNode.OBJECT) {
      this.updateType = NodeUpdateType.OBJECT;
    } else if (eventType === EventNode.MATERIAL) {
      this.updateType = NodeUpdateType.RENDER;
    } else if (eventType === EventNode.BEFORE_OBJECT) {
      this.updateBeforeType = NodeUpdateType.OBJECT;
    } else if (eventType === EventNode.BEFORE_MATERIAL) {
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  update(frame) {
    this.callback(frame);
  }
  updateBefore(frame) {
    this.callback(frame);
  }
}
EventNode.OBJECT = "object";
EventNode.MATERIAL = "material";
EventNode.BEFORE_OBJECT = "beforeObject";
EventNode.BEFORE_MATERIAL = "beforeMaterial";
const createEvent = (type, callback) => new EventNode(type, callback).toStack();
const OnObjectUpdate = (callback) => createEvent(EventNode.OBJECT, callback);
const OnMaterialUpdate = (callback) => createEvent(EventNode.MATERIAL, callback);
const OnBeforeObjectUpdate = (callback) => createEvent(EventNode.BEFORE_OBJECT, callback);
const OnBeforeMaterialUpdate = (callback) => createEvent(EventNode.BEFORE_MATERIAL, callback);
class StorageInstancedBufferAttribute extends InstancedBufferAttribute {
  /**
   * Constructs a new storage instanced buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count, itemSize, typeClass = Float32Array) {
    const array2 = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
    super(array2, itemSize);
    this.isStorageInstancedBufferAttribute = true;
  }
}
class StorageBufferAttribute extends BufferAttribute {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count, itemSize, typeClass = Float32Array) {
    const array2 = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
    super(array2, itemSize);
    this.isStorageBufferAttribute = true;
  }
}
const attributeArray$2 = (count, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageBufferAttribute(count, itemSize, typedArray);
  const node = storage(buffer2, type, count);
  return node;
};
const instancedArray = (count, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer2 = new StorageInstancedBufferAttribute(count, itemSize, typedArray);
  const node = storage(buffer2, type, count);
  return node;
};
class PointUVNode extends Node {
  static get type() {
    return "PointUVNode";
  }
  /**
   * Constructs a new point uv node.
   */
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const pointUV = /* @__PURE__ */ nodeImmutable(PointUVNode);
const _e1 = /* @__PURE__ */ new Euler();
const _m1 = /* @__PURE__ */ new Matrix4();
class SceneNode extends Node {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(scope = SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene);
    } else if (scope === SceneNode.BACKGROUND_ROTATION) {
      output2 = uniform$2("mat4").setName("backgroundRotation").setGroup(renderGroup).onRenderUpdate(() => {
        const background = scene.background;
        if (background !== null && background.isTexture && background.mapping !== UVMapping) {
          _e1.copy(scene.backgroundRotation);
          _e1.x *= -1;
          _e1.y *= -1;
          _e1.z *= -1;
          _m1.makeRotationFromEuler(_e1);
        } else {
          _m1.identity();
        }
        return _m1;
      });
    } else {
      error("SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
}
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
const backgroundBlurriness = /* @__PURE__ */ nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
const backgroundIntensity = /* @__PURE__ */ nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
const backgroundRotation = /* @__PURE__ */ nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);
class StorageTextureNode extends TextureNode {
  static get type() {
    return "StorageTextureNode";
  }
  /**
   * Constructs a new storage texture node.
   *
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
   */
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.mipLevel = 0;
    this.isStorageTextureNode = true;
    this.access = NodeAccess.WRITE_ONLY;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'storageTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
    return properties;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageTextureNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Sets the mip level to write to.
   *
   * @param {number} level - The mip level.
   * @return {StorageTextureNode} A reference to this node.
   */
  setMipLevel(level) {
    this.mipLevel = level;
    return this;
  }
  /**
   * Generates the code snippet of the storage node. If no `storeNode`
   * is defined, the texture node is generated as normal texture.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output2) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output2);
    }
    return snippet;
  }
  /**
   * Convenience method for configuring a read/write node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadWrite() {
    return this.setAccess(NodeAccess.READ_WRITE);
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Convenience method for configuring a write-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toWriteOnly() {
    return this.setAccess(NodeAccess.WRITE_ONLY);
  }
  /**
   * Generates the code snippet of the storage texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode, depthNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, this.value.is3DTexture === true ? "uvec3" : "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, depthSnippet, storeSnippet);
    builder.addLineFlowCode(snippet, this);
  }
  clone() {
    const newNode = super.clone();
    newNode.storeNode = this.storeNode;
    newNode.mipLevel = this.mipLevel;
    return newNode;
  }
}
const storageTexture = /* @__PURE__ */ nodeProxy(StorageTextureNode).setParameterLength(1, 3);
const textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null) node.toStack();
  return node;
};
const normal = Fn$4(({ texture: texture2, uv: uv2 }) => {
  const epsilon = 1e-4;
  const ret = vec3$2().toVar();
  If(uv2.x.lessThan(epsilon), () => {
    ret.assign(vec3$2(1, 0, 0));
  }).ElseIf(uv2.y.lessThan(epsilon), () => {
    ret.assign(vec3$2(0, 1, 0));
  }).ElseIf(uv2.z.lessThan(epsilon), () => {
    ret.assign(vec3$2(0, 0, 1));
  }).ElseIf(uv2.x.greaterThan(1 - epsilon), () => {
    ret.assign(vec3$2(-1, 0, 0));
  }).ElseIf(uv2.y.greaterThan(1 - epsilon), () => {
    ret.assign(vec3$2(0, -1, 0));
  }).ElseIf(uv2.z.greaterThan(1 - epsilon), () => {
    ret.assign(vec3$2(0, 0, -1));
  }).Else(() => {
    const step2 = 0.01;
    const x = texture2.sample(uv2.add(vec3$2(-step2, 0, 0))).r.sub(texture2.sample(uv2.add(vec3$2(step2, 0, 0))).r);
    const y = texture2.sample(uv2.add(vec3$2(0, -step2, 0))).r.sub(texture2.sample(uv2.add(vec3$2(0, step2, 0))).r);
    const z = texture2.sample(uv2.add(vec3$2(0, 0, -step2))).r.sub(texture2.sample(uv2.add(vec3$2(0, 0, step2))).r);
    ret.assign(vec3$2(x, y, z));
  });
  return ret.normalize();
});
class Texture3DNode extends TextureNode {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return vec3$2(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.isFlipY() && (texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true)) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(int$3(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
      }
    }
    return uvNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec3" : "ivec3");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
}
const texture3D = /* @__PURE__ */ nodeProxy(Texture3DNode).setParameterLength(1, 3);
const texture3DLoad = (...params) => texture3D(...params).setSampler(false);
const texture3DLevel = (value, uvNode, levelNode) => texture3D(value, uvNode).level(levelNode);
class UserDataNode extends ReferenceNode {
  static get type() {
    return "UserDataNode";
  }
  /**
   * Constructs a new user data node.
   *
   * @param {string} property - The property name that should be referenced by the node.
   * @param {string} inputType - The node data type of the reference.
   * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   */
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  /**
   * Overwritten to make sure {@link ReferenceNode#reference} points to the correct
   * `userData` field.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
   * @return {Object} A reference to the `userData` field.
   */
  updateReference(state) {
    this.reference = this.userData !== null ? this.userData : state.object.userData;
    return this.reference;
  }
}
const userData = (name, inputType, userData2) => new UserDataNode(name, inputType, userData2);
const _objectData = /* @__PURE__ */ new WeakMap();
class VelocityNode extends TempNode {
  static get type() {
    return "VelocityNode";
  }
  /**
   * Constructs a new vertex color node.
   */
  constructor() {
    super("vec2");
    this.projectionMatrix = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateAfterType = NodeUpdateType.OBJECT;
    this.previousModelWorldMatrix = uniform$2(new Matrix4());
    this.previousProjectionMatrix = uniform$2(new Matrix4()).setGroup(renderGroup);
    this.previousCameraViewMatrix = uniform$2(new Matrix4());
  }
  /**
   * Sets the given projection matrix.
   *
   * @param {Matrix4} projectionMatrix - The projection matrix to set.
   */
  setProjectionMatrix(projectionMatrix) {
    this.projectionMatrix = projectionMatrix;
  }
  /**
   * Updates velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ frameId: frameId2, camera, object }) {
    const previousModelMatrix = getPreviousMatrix(object);
    this.previousModelWorldMatrix.value.copy(previousModelMatrix);
    const cameraData = getData(camera);
    if (cameraData.frameId !== frameId2) {
      cameraData.frameId = frameId2;
      if (cameraData.previousProjectionMatrix === void 0) {
        cameraData.previousProjectionMatrix = new Matrix4();
        cameraData.previousCameraViewMatrix = new Matrix4();
        cameraData.currentProjectionMatrix = new Matrix4();
        cameraData.currentCameraViewMatrix = new Matrix4();
        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
      } else {
        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
      }
      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
    }
  }
  /**
   * Overwritten to updated velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateAfter({ object }) {
    getPreviousMatrix(object).copy(object.matrixWorld);
  }
  /**
   * Implements the velocity computation based on the previous and current vertex data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec2>} The motion vector.
   */
  setup() {
    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform$2(this.projectionMatrix);
    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal$1);
    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
    const velocity2 = sub$3(ndcPositionCurrent, ndcPositionPrevious);
    return velocity2;
  }
}
function getData(object) {
  let objectData = _objectData.get(object);
  if (objectData === void 0) {
    objectData = {};
    _objectData.set(object, objectData);
  }
  return objectData;
}
function getPreviousMatrix(object, index = 0) {
  const objectData = getData(object);
  let matrix = objectData[index];
  if (matrix === void 0) {
    objectData[index] = matrix = new Matrix4();
    objectData[index].copy(object.matrixWorld);
  }
  return matrix;
}
const velocity = /* @__PURE__ */ nodeImmutable(VelocityNode);
const grayscale = /* @__PURE__ */ Fn$4(([color2]) => {
  return luminance(color2.rgb);
});
const saturation = /* @__PURE__ */ Fn$4(([color2, adjustment = float$4(1)]) => {
  return adjustment.mix(luminance(color2.rgb), color2.rgb);
});
const vibrance = /* @__PURE__ */ Fn$4(([color2, adjustment = float$4(1)]) => {
  const average = add$3(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2.rgb, mx, amt);
});
const hue = /* @__PURE__ */ Fn$4(([color2, adjustment = float$4(1)]) => {
  const k = vec3$2(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3$2(color2.rgb.mul(cosAngle).add(k.cross(color2.rgb).mul(adjustment.sin()).add(k.mul(dot$3(k, color2.rgb).mul(cosAngle.oneMinus())))));
});
const luminance = (color2, luminanceCoefficients = vec3$2(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot$3(color2, luminanceCoefficients);
const cdl = /* @__PURE__ */ Fn$4(([
  color2,
  slope = vec3$2(1),
  offset = vec3$2(0),
  power = vec3$2(1),
  saturation2 = float$4(1),
  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
  luminanceCoefficients = vec3$2(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))
]) => {
  const luma = color2.rgb.dot(vec3$2(luminanceCoefficients));
  const v = max$1$1(color2.rgb.mul(slope).add(offset), 0).toVar();
  const pv = v.pow(power).toVar();
  If(v.r.greaterThan(0), () => {
    v.r.assign(pv.r);
  });
  If(v.g.greaterThan(0), () => {
    v.g.assign(pv.g);
  });
  If(v.b.greaterThan(0), () => {
    v.b.assign(pv.b);
  });
  v.assign(luma.add(v.sub(luma).mul(saturation2)));
  return vec4$3(v.rgb, color2.a);
});
class PosterizeNode extends TempNode {
  static get type() {
    return "PosterizeNode";
  }
  /**
   * Constructs a new posterize node.
   *
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   */
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
}
const posterize = /* @__PURE__ */ nodeProxy(PosterizeNode).setParameterLength(2);
const _size = /* @__PURE__ */ new Vector2();
class PassTextureNode extends TextureNode {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(passNode, texture2) {
    super(texture2);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class PassMultipleTextureNode extends PassTextureNode {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(passNode, textureName, previousTexture = false) {
    super(passNode, null);
    this.textureName = textureName;
    this.previousTexture = previousTexture;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(builder) {
    this.updateTexture();
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.passNode, this.textureName, this.previousTexture);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    return newNode;
  }
}
class PassNode extends TempNode {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(scope, scene, camera, options = {}) {
    super("vec4");
    this.scope = scope;
    this.scene = scene;
    this.camera = camera;
    this.options = options;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture = new DepthTexture();
    depthTexture.isRenderTargetTexture = true;
    depthTexture.name = "depth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options });
    renderTarget.texture.name = "output";
    renderTarget.depthTexture = depthTexture;
    this.renderTarget = renderTarget;
    this.overrideMaterial = null;
    this.transparent = true;
    this.opaque = true;
    this.contextNode = null;
    this._contextNodeCache = null;
    this._textures = {
      output: renderTarget.texture,
      depth: depthTexture
    };
    this._textureNodes = {};
    this._linearDepthNodes = {};
    this._viewZNodes = {};
    this._previousTextures = {};
    this._previousTextureNodes = {};
    this._cameraNear = uniform$2(0);
    this._cameraFar = uniform$2(0);
    this._mrt = null;
    this._layers = null;
    this._resolutionScale = 1;
    this._viewport = null;
    this._scissor = null;
    this.isPassNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.global = true;
  }
  /**
   * Sets the resolution scale for the pass.
   * The resolution scale is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolutionScale - The resolution scale to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolutionScale(resolutionScale) {
    this._resolutionScale = resolutionScale;
    return this;
  }
  /**
   * Gets the current resolution scale of the pass.
   *
   * @return {number} The current resolution scale. A value of `1` means full resolution.
   */
  getResolutionScale() {
    return this._resolutionScale;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   * @deprecated since r181. Use {@link PassNode#setResolutionScale `setResolutionScale()`} instead.
   */
  setResolution(resolution) {
    warn("PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead.");
    return this.setResolutionScale(resolution);
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   * @deprecated since r181. Use {@link PassNode#getResolutionScale `getResolutionScale()`} instead.
   */
  getResolution() {
    warn("PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead.");
    return this.getResolutionScale();
  }
  /**
   * Sets the layer configuration that should be used when rendering the pass.
   *
   * @param {Layers} layers - The layers object to set.
   * @return {PassNode} A reference to this pass.
   */
  setLayers(layers) {
    this._layers = layers;
    return this;
  }
  /**
   * Gets the current layer configuration of the pass.
   *
   * @return {?Layers} .
   */
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(mrt2) {
    this._mrt = mrt2;
    return this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(name) {
    let texture2 = this._textures[name];
    if (texture2 === void 0) {
      const refTexture = this.renderTarget.texture;
      texture2 = refTexture.clone();
      texture2.name = name;
      this._textures[name] = texture2;
      this.renderTarget.textures.push(texture2);
    }
    return texture2;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(name) {
    let texture2 = this._previousTextures[name];
    if (texture2 === void 0) {
      texture2 = this.getTexture(name).clone();
      this._previousTextures[name] = texture2;
    }
    return texture2;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(name) {
    const prevTexture = this._previousTextures[name];
    if (prevTexture !== void 0) {
      const texture2 = this._textures[name];
      const index = this.renderTarget.textures.indexOf(texture2);
      this.renderTarget.textures[index] = prevTexture;
      this._textures[name] = prevTexture;
      this._previousTextures[name] = texture2;
      this._textureNodes[name].updateTexture();
      this._previousTextureNodes[name].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(name = "output") {
    let textureNode = this._textureNodes[name];
    if (textureNode === void 0) {
      textureNode = new PassMultipleTextureNode(this, name);
      textureNode.updateTexture();
      this._textureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(name = "output") {
    let textureNode = this._previousTextureNodes[name];
    if (textureNode === void 0) {
      if (this._textureNodes[name] === void 0) this.getTextureNode(name);
      textureNode = new PassMultipleTextureNode(this, name, true);
      textureNode.updateTexture();
      this._previousTextureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(name = "depth") {
    let viewZNode = this._viewZNodes[name];
    if (viewZNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear2, cameraFar2);
    }
    return viewZNode;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(name = "depth") {
    let linearDepthNode = this._linearDepthNodes[name];
    if (linearDepthNode === void 0) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      const viewZNode = this.getViewZNode(name);
      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear2, cameraFar2);
    }
    return linearDepthNode;
  }
  /**
   * Precompiles the pass.
   *
   * Note that this method must be called after the pass configuration is complete.
   * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   * @see {@link Renderer#compileAsync}
   */
  async compileAsync(renderer) {
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    renderer.setRenderTarget(this.renderTarget);
    renderer.setMRT(this._mrt);
    await renderer.compileAsync(this.scene, this.camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
  }
  setup({ renderer }) {
    this.renderTarget.samples = this.options.samples === void 0 ? renderer.samples : this.options.samples;
    this.renderTarget.texture.type = renderer.getOutputBufferType();
    return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const { scene } = this;
    let camera;
    let pixelRatio;
    const outputRenderTarget = renderer.getOutputRenderTarget();
    if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
      pixelRatio = 1;
      camera = renderer.xr.getCamera();
      renderer.xr.updateCamera(camera);
      _size.set(outputRenderTarget.width, outputRenderTarget.height);
    } else {
      camera = this.camera;
      pixelRatio = renderer.getPixelRatio();
      renderer.getSize(_size);
    }
    this._pixelRatio = pixelRatio;
    this.setSize(_size.width, _size.height);
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    const currentAutoClear = renderer.autoClear;
    const currentTransparent = renderer.transparent;
    const currentOpaque = renderer.opaque;
    const currentMask = camera.layers.mask;
    const currentContextNode = renderer.contextNode;
    const currentOverrideMaterial = scene.overrideMaterial;
    this._cameraNear.value = camera.near;
    this._cameraFar.value = camera.far;
    if (this._layers !== null) {
      camera.layers.mask = this._layers.mask;
    }
    for (const name in this._previousTextures) {
      this.toggleTexture(name);
    }
    if (this.overrideMaterial !== null) {
      scene.overrideMaterial = this.overrideMaterial;
    }
    renderer.setRenderTarget(this.renderTarget);
    renderer.setMRT(this._mrt);
    renderer.autoClear = true;
    renderer.transparent = this.transparent;
    renderer.opaque = this.opaque;
    if (this.contextNode !== null) {
      if (this._contextNodeCache === null || this._contextNodeCache.version !== this.version) {
        this._contextNodeCache = {
          version: this.version,
          context: context({ ...renderer.contextNode.getFlowContextData(), ...this.contextNode.getFlowContextData() })
        };
      }
      renderer.contextNode = this._contextNodeCache.context;
    }
    const currentSceneName = scene.name;
    scene.name = this.name ? this.name : scene.name;
    renderer.render(scene, camera);
    scene.name = currentSceneName;
    scene.overrideMaterial = currentOverrideMaterial;
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
    renderer.autoClear = currentAutoClear;
    renderer.transparent = currentTransparent;
    renderer.opaque = currentOpaque;
    renderer.contextNode = currentContextNode;
    camera.layers.mask = currentMask;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = Math.floor(this._width * this._pixelRatio * this._resolutionScale);
    const effectiveHeight = Math.floor(this._height * this._pixelRatio * this._resolutionScale);
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
    if (this._viewport !== null) this.renderTarget.viewport.copy(this._viewport);
  }
  /**
   * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
   * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x, y, width, height) {
    if (x === null) {
      this._scissor = null;
    } else {
      if (this._scissor === null) this._scissor = new Vector4();
      if (x.isVector4) {
        this._scissor.copy(x);
      } else {
        this._scissor.set(x, y, width, height);
      }
      this._scissor.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
    }
  }
  /**
   * This method allows to define the pass's viewport. By default, the viewport is kept in sync
   * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   */
  setViewport(x, y, width, height) {
    if (x === null) {
      this._viewport = null;
    } else {
      if (this._viewport === null) this._viewport = new Vector4();
      if (x.isVector4) {
        this._viewport.copy(x);
      } else {
        this._viewport.set(x, y, width, height);
      }
      this._viewport.multiplyScalar(this._pixelRatio * this._resolutionScale).floor();
    }
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
}
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
const pass = (scene, camera, options) => new PassNode(PassNode.COLOR, scene, camera, options);
const passTexture = (pass2, texture2) => new PassTextureNode(pass2, texture2);
const depthPass = (scene, camera, options) => new PassNode(PassNode.DEPTH, scene, camera, options);
class ToonOutlinePassNode extends PassNode {
  static get type() {
    return "ToonOutlinePassNode";
  }
  /**
   * Constructs a new outline pass node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Node} colorNode - Defines the outline's color.
   * @param {Node} thicknessNode - Defines the outline's thickness.
   * @param {Node} alphaNode - Defines the outline's alpha.
   */
  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {
    super(PassNode.COLOR, scene, camera);
    this.colorNode = colorNode;
    this.thicknessNode = thicknessNode;
    this.alphaNode = alphaNode;
    this._materialCache = /* @__PURE__ */ new WeakMap();
    this.name = "Outline Pass";
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {
      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
        if (material.wireframe === false) {
          const outlineMaterial = this._getOutlineMaterial(material);
          renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);
        }
      }
      renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);
    });
    super.updateBefore(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
  }
  /**
   * Creates the material used for outline rendering.
   *
   * @private
   * @return {NodeMaterial} The outline material.
   */
  _createMaterial() {
    const material = new NodeMaterial();
    material.isMeshToonOutlineMaterial = true;
    material.name = "Toon_Outline";
    material.side = BackSide;
    const outlineNormal = normalLocal.negate();
    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
    const ratio = float$4(1);
    const pos = mvp.mul(vec4$3(positionLocal$1, 1));
    const pos2 = mvp.mul(vec4$3(positionLocal$1.add(outlineNormal), 1));
    const norm = normalize$1(pos.sub(pos2));
    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
    material.colorNode = vec4$3(this.colorNode, this.alphaNode);
    return material;
  }
  /**
   * For the given toon material, this method returns a corresponding
   * outline material.
   *
   * @private
   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
   * @return {NodeMaterial} The outline material.
   */
  _getOutlineMaterial(originalMaterial) {
    let outlineMaterial = this._materialCache.get(originalMaterial);
    if (outlineMaterial === void 0) {
      outlineMaterial = this._createMaterial();
      this._materialCache.set(originalMaterial, outlineMaterial);
    }
    return outlineMaterial;
  }
}
const toonOutlinePass = (scene, camera, color2 = new Color(0, 0, 0), thickness2 = 3e-3, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color2), nodeObject(thickness2), nodeObject(alpha)));
const linearToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  return color2.mul(exposure).clamp();
}).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
const reinhardToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
}).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
const cineonToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
const RRTAndODTFit = /* @__PURE__ */ Fn$4(([color2]) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
const acesFilmicToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit(color2);
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
const LINEAR_REC2020_TO_LINEAR_SRGB = /* @__PURE__ */ mat3(vec3$2(1.6605, -0.1246, -0.0182), vec3$2(-0.5876, 1.1329, -0.1006), vec3$2(-0.0728, -83e-4, 1.1187));
const LINEAR_SRGB_TO_LINEAR_REC2020 = /* @__PURE__ */ mat3(vec3$2(0.6274, 0.0691, 0.0164), vec3$2(0.3293, 0.9195, 0.088), vec3$2(0.0433, 0.0113, 0.8956));
const agxDefaultContrastApprox = /* @__PURE__ */ Fn$4(([x_immutable]) => {
  const x = vec3$2(x_immutable).toVar();
  const x2 = vec3$2(x.mul(x)).toVar();
  const x4 = vec3$2(x2.mul(x2)).toVar();
  return float$4(15.5).mul(x4.mul(x2)).sub(mul$3(40.14, x4.mul(x))).add(mul$3(31.96, x4).sub(mul$3(6.868, x2.mul(x))).add(mul$3(0.4298, x2).add(mul$3(0.1191, x).sub(232e-5))));
});
const agxToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  const colortone = vec3$2(color2).toVar();
  const AgXInsetMatrix = mat3(vec3$2(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3$2(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3$2(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3$2(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3$2(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3$2(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float$4(-12.47393);
  const AgxMaxEv = float$4(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max$1$1(colortone, 1e-10));
  colortone.assign(log2(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp$1(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow(max$1$1(vec3$2(0), colortone), vec3$2(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp$1(colortone, 0, 1));
  return colortone;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
const neutralToneMapping = /* @__PURE__ */ Fn$4(([color2, exposure]) => {
  const StartCompression = float$4(0.8 - 0.04);
  const Desaturation = float$4(0.15);
  color2 = color2.mul(exposure);
  const x = min$1$1(color2.r, min$1$1(color2.g, color2.b));
  const offset = select$3(x.lessThan(0.08), x.sub(mul$3(6.25, x.mul(x))), 0.04);
  color2.subAssign(offset);
  const peak = max$1$1(color2.r, max$1$1(color2.g, color2.b));
  If(peak.lessThan(StartCompression), () => {
    return color2;
  });
  const d = sub$3(1, StartCompression);
  const newPeak = sub$3(1, d.mul(d).div(peak.add(d.sub(StartCompression))));
  color2.mulAssign(newPeak.div(peak));
  const g = sub$3(1, div$2(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
  return mix(color2, vec3$2(newPeak), g);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class CodeNode extends Node {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.global = true;
    this.code = code2;
    this.includes = includes;
    this.language = language;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
}
const code = /* @__PURE__ */ nodeProxy(CodeNode).setParameterLength(1, 3);
const js = (src, includes) => code(src, includes, "js");
const wgsl = (src, includes) => code(src, includes, "wgsl");
const glsl = (src, includes) => code(src, includes, "glsl");
class FunctionNode extends CodeNode {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code2 = "", includes = [], language = "") {
    super(code2, includes, language);
  }
  /**
   * Returns the type of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type.
   */
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  /**
   * Returns the type of a member of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    const type = this.getNodeType(builder);
    const structType = builder.getStructTypeNode(type);
    return structType.getMemberType(builder, name);
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    const code2 = this.getNodeFunction(builder).getCode(propertyName);
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
}
const nativeFn = (code2, includes = [], language = "") => {
  for (let i = 0; i < includes.length; i++) {
    const include = includes[i];
    if (typeof include === "function") {
      includes[i] = include.functionNode;
    }
  }
  const functionNode = new FunctionNode(code2, includes, language);
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
const glslFn = (code2, includes) => nativeFn(code2, includes, "glsl");
const wgslFn = (code2, includes) => nativeFn(code2, includes, "wgsl");
class ScriptableValueNode extends Node {
  static get type() {
    return "ScriptableValueNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {any} [value=null] - The value.
   */
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outputType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  /**
   * Whether this node represents an output or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  /**
   * The node's value.
   *
   * @type {any}
   */
  get value() {
    return this._value;
  }
  /**
   * Dispatches the `refresh` event.
   */
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  /**
   * The `value` property usually represents a node or even binary data in form of array buffers.
   * In this case, this method tries to return the actual value behind the complex type.
   *
   * @return {any} The value.
   */
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  /**
   * Overwritten since the node type is inferred from the value.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float$4();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
}
const scriptableValue = /* @__PURE__ */ nodeProxy(ScriptableValueNode).setParameterLength(1);
class Resources extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
}
class Parameters {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id) {
    return this.scriptableNode.getInputLayout(id);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
}
const ScriptableNodeResources = new Resources();
class ScriptableNode extends Node {
  static get type() {
    return "ScriptableNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {?CodeNode} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   */
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue(null);
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  /**
   * The source code of the scriptable node.
   *
   * @type {string}
   */
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  /**
   * Sets the reference of a local script variable.
   *
   * @param {string} name - The variable name.
   * @param {Object} value - The reference to set.
   * @return {Resources} The resource map
   */
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  /**
   * Gets the value of a local script variable.
   *
   * @param {string} name - The variable name.
   * @return {Object} The value.
   */
  getLocal(name) {
    return this._local.get(name);
  }
  /**
   * Event listener for the `refresh` event.
   */
  onRefresh() {
    this._refresh();
  }
  /**
   * Returns an input from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the input.
   * @return {Object} The element entry.
   */
  getInputLayout(id) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id || element2.name === id)) {
        return element2;
      }
    }
  }
  /**
   * Returns an output from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the output.
   * @return {Object} The element entry.
   */
  getOutputLayout(id) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id || element2.name === id)) {
        return element2;
      }
    }
  }
  /**
   * Defines a script output for the given name and value.
   *
   * @param {string} name - The name of the output.
   * @param {Node} value - The node value.
   * @return {ScriptableNode} A reference to this node.
   */
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  /**
   * Returns a script output for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {ScriptableValueNode} The node value.
   */
  getOutput(name) {
    return this._outputs[name];
  }
  /**
   * Returns a parameter for the given name
   *
   * @param {string} name - The name of the parameter.
   * @return {ScriptableValueNode} The node value.
   */
  getParameter(name) {
    return this.parameters[name];
  }
  /**
   * Sets a value for the given parameter name.
   *
   * @param {string} name - The parameter name.
   * @param {any} value - The parameter value.
   * @return {ScriptableNode} A reference to this node.
   */
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  /**
   * Returns the value of this node which is the value of
   * the default output.
   *
   * @return {Node} The value.
   */
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  /**
   * Deletes a parameter from the script.
   *
   * @param {string} name - The parameter to remove.
   * @return {ScriptableNode} A reference to this node.
   */
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  /**
   * Deletes all parameters from the script.
   *
   * @return {ScriptableNode} A reference to this node.
   */
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {any} The result of the function call.
   */
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  /**
   * Asynchronously calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {Promise<any>} The result of the function call.
   */
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  /**
   * Overwritten since the node types is inferred from the script's output.
   *
   * @param {NodeBuilder} builder - The current node builder
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  /**
   * Refreshes the script node.
   *
   * @param {?string} [output=null] - An optional output.
   */
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  /**
   * Returns an object representation of the script.
   *
   * @return {Object} The result object.
   */
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id, value) => this.setOutput(id, value);
    const parameters = new Parameters(this);
    const THREE2 = ScriptableNodeResources.get("THREE");
    const TSL2 = ScriptableNodeResources.get("TSL");
    const method = this.getMethod();
    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE2, TSL2];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id) === void 0) this.setParameter(id, null);
            this.getParameter(id).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id) === void 0) this.setOutput(id, null);
            this.getOutput(id).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  /**
   * Returns the layout of the script.
   *
   * @return {Object} The script's layout.
   */
  getLayout() {
    return this.getObject().layout;
  }
  /**
   * Returns default node output of the script.
   *
   * @return {Node} The default node output.
   */
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float$4();
  }
  /**
   * Returns default output of the script.
   *
   * @return {ScriptableValueNode} The default output.
   */
  getDefaultOutput() {
    return this._exec()._output;
  }
  /**
   * Returns a function created from the node's script.
   *
   * @return {Function} The function representing the node's code.
   */
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(force) {
    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
    for (const param in this.parameters) {
      values.push(this.parameters[param].getCacheKey(force));
    }
    return hashArray(values);
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  /**
   * Executes the `main` function of the script.
   *
   * @private
   * @return {ScriptableNode} A reference to this node.
   */
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  /**
   * Executes the refresh.
   *
   * @private
   */
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
}
const scriptable = /* @__PURE__ */ nodeProxy(ScriptableNode).setParameterLength(1, 2);
function getViewZNode(builder) {
  let viewZ;
  const getViewZ = builder.context.getViewZ;
  if (getViewZ !== void 0) {
    viewZ = getViewZ(this);
  }
  return (viewZ || positionView.z).negate();
}
const rangeFogFactor = Fn$4(([near, far], builder) => {
  const viewZ = getViewZNode(builder);
  return smoothstep(near, far, viewZ);
});
const densityFogFactor = Fn$4(([density], builder) => {
  const viewZ = getViewZNode(builder);
  return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
});
const fog = Fn$4(([color2, factor]) => {
  return vec4$3(factor.toFloat().mix(output.rgb, color2.toVec3()), output.a);
});
function rangeFog(color2, near, far) {
  warn('TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.');
  return fog(color2, rangeFogFactor(near, far));
}
function densityFog(color2, density) {
  warn('TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.');
  return fog(color2, densityFogFactor(density));
}
let min$2 = null;
let max$2 = null;
class RangeNode extends Node {
  static get type() {
    return "RangeNode";
  }
  /**
   * Constructs a new range node.
   *
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   */
  constructor(minNode = float$4(), maxNode = float$4()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  /**
   * Returns the vector length which is computed based on the range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The vector length.
   */
  getVectorLength(builder) {
    const minNode = this.getConstNode(this.minNode);
    const maxNode = this.getConstNode(this.maxNode);
    const minLength = builder.getTypeLength(getValueType(minNode.value));
    const maxLength = builder.getTypeLength(getValueType(maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  /**
   * This method is overwritten since the node type is inferred from range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  /**
   * Returns a constant node from the given node by traversing it.
   *
   * @param {Node} node - The node to traverse.
   * @returns {Node} The constant node, if found.
   */
  getConstNode(node) {
    let output2 = null;
    node.traverse((n) => {
      if (n.isConstNode === true) {
        output2 = n;
      }
    });
    if (output2 === null) {
      throw new Error('THREE.TSL: No "ConstNode" found in node graph.');
    }
    return output2;
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.count > 1) {
      const minNode = this.getConstNode(this.minNode);
      const maxNode = this.getConstNode(this.maxNode);
      const minValue = minNode.value;
      const maxValue = maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min$2 = min$2 || new Vector4();
      max$2 = max$2 || new Vector4();
      min$2.setScalar(0);
      max$2.setScalar(0);
      if (minLength === 1) min$2.setScalar(minValue);
      else if (minValue.isColor) min$2.set(minValue.r, minValue.g, minValue.b, 1);
      else min$2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max$2.setScalar(maxValue);
      else if (maxValue.isColor) max$2.set(maxValue.r, maxValue.g, maxValue.b, 1);
      else max$2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array2 = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min$2.getComponent(index);
        const maxElementValue = max$2.getComponent(index);
        array2[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      if (object.count <= 4096) {
        output2 = buffer(array2, "vec4", object.count).element(instanceIndex$2).convert(nodeType);
      } else {
        const bufferAttribute2 = new InstancedBufferAttribute(array2, 4);
        builder.geometry.setAttribute("__range" + this.id, bufferAttribute2);
        output2 = instancedBufferAttribute(bufferAttribute2).convert(nodeType);
      }
    } else {
      output2 = float$4(0);
    }
    return output2;
  }
}
const range = /* @__PURE__ */ nodeProxy(RangeNode).setParameterLength(2);
class ComputeBuiltinNode extends Node {
  static get type() {
    return "ComputeBuiltinNode";
  }
  /**
   * Constructs a new compute builtin node.
   *
   * @param {string} builtinName - The built-in name.
   * @param {string} nodeType - The node type.
   */
  constructor(builtinName, nodeType) {
    super(nodeType);
    this._builtinName = builtinName;
  }
  /**
   * This method is overwritten since hash is derived from the built-in name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    return this.getBuiltinName(builder);
  }
  /**
   * This method is overwritten since the node type is simply derived from `nodeType`..
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.nodeType;
  }
  /**
   * Sets the builtin name.
   *
   * @param {string} builtinName - The built-in name.
   * @return {ComputeBuiltinNode} A reference to this node.
   */
  setBuiltinName(builtinName) {
    this._builtinName = builtinName;
    return this;
  }
  /**
   * Returns the builtin name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The builtin name.
   */
  getBuiltinName() {
    return this._builtinName;
  }
  /**
   * Whether the current node builder has the builtin or not.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the builder has the builtin or not.
   */
  hasBuiltin(builder) {
    return builder.hasBuiltin(this._builtinName);
  }
  generate(builder, output2) {
    const builtinName = this.getBuiltinName(builder);
    const nodeType = this.getNodeType(builder);
    if (builder.shaderStage === "compute") {
      return builder.format(builtinName, nodeType, output2);
    } else {
      warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._builtinName = this._builtinName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._builtinName = data._builtinName;
  }
}
const computeBuiltin = (name, nodeType) => new ComputeBuiltinNode(name, nodeType);
const numWorkgroups = /* @__PURE__ */ computeBuiltin("numWorkgroups", "uvec3");
const workgroupId = /* @__PURE__ */ computeBuiltin("workgroupId", "uvec3");
const globalId = /* @__PURE__ */ computeBuiltin("globalId", "uvec3");
const localId = /* @__PURE__ */ computeBuiltin("localId", "uvec3");
const subgroupSize = /* @__PURE__ */ computeBuiltin("subgroupSize", "uint");
class BarrierNode extends Node {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  generate(builder) {
    const { scope } = this;
    const { renderer } = builder;
    if (renderer.backend.isWebGLBackend === true) {
      builder.addFlowCode(`	// ${scope}Barrier 
`);
    } else {
      builder.addLineFlowCode(`${scope}Barrier()`, this);
    }
  }
}
const barrier = nodeProxy(BarrierNode);
const workgroupBarrier = () => barrier("workgroup").toStack();
const storageBarrier = () => barrier("storage").toStack();
const textureBarrier = () => barrier("texture").toStack();
class WorkgroupInfoElementNode extends ArrayElementNode {
  /**
   * Constructs a new workgroup info element node.
   *
   * @param {Node} workgroupInfoNode - The workgroup info node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(workgroupInfoNode, indexNode) {
    super(workgroupInfoNode, indexNode);
    this.isWorkgroupInfoElementNode = true;
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    snippet = super.generate(builder);
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
}
class WorkgroupInfoNode extends Node {
  /**
   * Constructs a new buffer scoped to type scope.
   *
   * @param {string} scope - TODO.
   * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
   * @param {number} [bufferCount=0] - The number of elements in the buffer.
   */
  constructor(scope, bufferType, bufferCount = 0) {
    super(bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.isWorkgroupInfoNode = true;
    this.elementType = bufferType;
    this.scope = scope;
    this.name = "";
  }
  /**
   * Sets the name of this node.
   *
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the name/label of this node.
   *
   * @deprecated
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  label(name) {
    warn('TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the scope of this node.
   *
   * @param {string} scope - The scope to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setScope(scope) {
    this.scope = scope;
    return this;
  }
  /**
   * The data type of the array buffer.
   *
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Overwrites the default implementation since the input type
   * is inferred from the scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return `${this.scope}Array`;
  }
  /**
   * This method can be used to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {WorkgroupInfoElementNode} A reference to an element.
   */
  element(indexNode) {
    return new WorkgroupInfoElementNode(this, indexNode);
  }
  generate(builder) {
    const name = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
    return builder.getScopedArray(name, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
  }
}
const workgroupArray = (type, count) => new WorkgroupInfoNode("Workgroup", type, count);
class AtomicFunctionNode extends Node {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(method, pointerNode, valueNode) {
    super("uint");
    this.method = method;
    this.pointerNode = pointerNode;
    this.valueNode = valueNode;
    this.parents = true;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.pointerNode.getNodeType(builder);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getInputType(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const parents = properties.parents;
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.pointerNode;
    const b = this.valueNode;
    const params = [];
    params.push(`&${a.build(builder, inputType)}`);
    if (b !== null) {
      params.push(b.build(builder, inputType));
    }
    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(", ")} )`;
    const isVoid = parents ? parents.length === 1 && parents[0].isStackNode === true : false;
    if (isVoid) {
      builder.addLineFlowCode(methodSnippet, this);
    } else {
      if (properties.constNode === void 0) {
        properties.constNode = expression(methodSnippet, type).toConst();
      }
      return properties.constNode.build(builder);
    }
  }
}
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
const atomicNode = nodeProxy(AtomicFunctionNode);
const atomicFunc = (method, pointerNode, valueNode) => {
  return atomicNode(method, pointerNode, valueNode).toStack();
};
const atomicLoad = (pointerNode) => atomicFunc(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
const atomicStore = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
const atomicAdd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
const atomicSub = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
const atomicMax = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
const atomicMin = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
const atomicAnd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
const atomicOr = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
const atomicXor = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
class SubgroupFunctionNode extends TempNode {
  static get type() {
    return "SubgroupFunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} method - The subgroup/wave intrinsic method to construct.
   * @param {Node} [aNode=null] - The method's first argument.
   * @param {Node} [bNode=null] - The method's second argument.
   */
  constructor(method, aNode = null, bNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getInputType(builder) {
    const aType = this.aNode ? this.aNode.getNodeType(builder) : null;
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    if (aLen > bLen) {
      return aType;
    } else {
      return bType;
    }
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === SubgroupFunctionNode.SUBGROUP_ELECT) {
      return "bool";
    } else if (method === SubgroupFunctionNode.SUBGROUP_BALLOT) {
      return "uvec4";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const params = [];
    if (method === SubgroupFunctionNode.SUBGROUP_BROADCAST || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE || method === SubgroupFunctionNode.QUAD_BROADCAST) {
      const bType = b.getNodeType(builder);
      params.push(
        a.build(builder, type),
        b.build(builder, bType === "float" ? "int" : type)
      );
    } else if (method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN || method === SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP) {
      params.push(
        a.build(builder, type),
        b.build(builder, "uint")
      );
    } else {
      if (a !== null) params.push(a.build(builder, inputType));
      if (b !== null) params.push(b.build(builder, inputType));
    }
    const paramsString = params.length === 0 ? "()" : `( ${params.join(", ")} )`;
    return builder.format(`${builder.getMethod(method, type)}${paramsString}`, type, output2);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
}
SubgroupFunctionNode.SUBGROUP_ELECT = "subgroupElect";
SubgroupFunctionNode.SUBGROUP_BALLOT = "subgroupBallot";
SubgroupFunctionNode.SUBGROUP_ADD = "subgroupAdd";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD = "subgroupInclusiveAdd";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND = "subgroupExclusiveAdd";
SubgroupFunctionNode.SUBGROUP_MUL = "subgroupMul";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL = "subgroupInclusiveMul";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL = "subgroupExclusiveMul";
SubgroupFunctionNode.SUBGROUP_AND = "subgroupAnd";
SubgroupFunctionNode.SUBGROUP_OR = "subgroupOr";
SubgroupFunctionNode.SUBGROUP_XOR = "subgroupXor";
SubgroupFunctionNode.SUBGROUP_MIN = "subgroupMin";
SubgroupFunctionNode.SUBGROUP_MAX = "subgroupMax";
SubgroupFunctionNode.SUBGROUP_ALL = "subgroupAll";
SubgroupFunctionNode.SUBGROUP_ANY = "subgroupAny";
SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST = "subgroupBroadcastFirst";
SubgroupFunctionNode.QUAD_SWAP_X = "quadSwapX";
SubgroupFunctionNode.QUAD_SWAP_Y = "quadSwapY";
SubgroupFunctionNode.QUAD_SWAP_DIAGONAL = "quadSwapDiagonal";
SubgroupFunctionNode.SUBGROUP_BROADCAST = "subgroupBroadcast";
SubgroupFunctionNode.SUBGROUP_SHUFFLE = "subgroupShuffle";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR = "subgroupShuffleXor";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP = "subgroupShuffleUp";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN = "subgroupShuffleDown";
SubgroupFunctionNode.QUAD_BROADCAST = "quadBroadcast";
const subgroupElect = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ELECT).setParameterLength(0);
const subgroupBallot = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BALLOT).setParameterLength(1);
const subgroupAdd = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ADD).setParameterLength(1);
const subgroupInclusiveAdd = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD).setParameterLength(1);
const subgroupExclusiveAdd = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND).setParameterLength(1);
const subgroupMul = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MUL).setParameterLength(1);
const subgroupInclusiveMul = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL).setParameterLength(1);
const subgroupExclusiveMul = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL).setParameterLength(1);
const subgroupAnd = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_AND).setParameterLength(1);
const subgroupOr = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_OR).setParameterLength(1);
const subgroupXor = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_XOR).setParameterLength(1);
const subgroupMin = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MIN).setParameterLength(1);
const subgroupMax = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MAX).setParameterLength(1);
const subgroupAll = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ALL).setParameterLength(0);
const subgroupAny = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ANY).setParameterLength(0);
const subgroupBroadcastFirst = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST).setParameterLength(2);
const quadSwapX = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_X).setParameterLength(1);
const quadSwapY = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_Y).setParameterLength(1);
const quadSwapDiagonal = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_DIAGONAL).setParameterLength(1);
const subgroupBroadcast = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST).setParameterLength(2);
const subgroupShuffle = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE).setParameterLength(2);
const subgroupShuffleXor = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR).setParameterLength(2);
const subgroupShuffleUp = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP).setParameterLength(2);
const subgroupShuffleDown = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN).setParameterLength(2);
const quadBroadcast = /* @__PURE__ */ nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_BROADCAST).setParameterLength(1);
let uniformsLib;
function getLightData(light) {
  uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
  let uniforms = uniformsLib.get(light);
  if (uniforms === void 0) uniformsLib.set(light, uniforms = {});
  return uniforms;
}
function lightShadowMatrix(light) {
  const data = getLightData(light);
  return data.shadowMatrix || (data.shadowMatrix = uniform$2("mat4").setGroup(renderGroup).onRenderUpdate((frame) => {
    if (light.castShadow !== true || frame.renderer.shadowMap.enabled === false) {
      if (light.shadow.camera.coordinateSystem !== frame.camera.coordinateSystem) {
        light.shadow.camera.coordinateSystem = frame.camera.coordinateSystem;
        light.shadow.camera.updateProjectionMatrix();
      }
      light.shadow.updateMatrices(light);
    }
    return light.shadow.matrix;
  }));
}
function lightProjectionUV(light, position = positionWorld) {
  const spotLightCoord = lightShadowMatrix(light).mul(position);
  const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
  return projectionUV;
}
function lightPosition(light) {
  const data = getLightData(light);
  return data.position || (data.position = uniform$2(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.matrixWorld)));
}
function lightTargetPosition(light) {
  const data = getLightData(light);
  return data.targetPosition || (data.targetPosition = uniform$2(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.target.matrixWorld)));
}
function lightViewPosition(light) {
  const data = getLightData(light);
  return data.viewPosition || (data.viewPosition = uniform$2(new Vector3()).setGroup(renderGroup).onRenderUpdate(({ camera }, self2) => {
    self2.value = self2.value || new Vector3();
    self2.value.setFromMatrixPosition(light.matrixWorld);
    self2.value.applyMatrix4(camera.matrixWorldInverse);
  }));
}
const lightTargetDirection = (light) => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
const sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
const getLightNodeById = (id, lightNodes) => {
  for (const lightNode of lightNodes) {
    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
      return lightNode;
    }
  }
  return null;
};
const _lightsNodeRef = /* @__PURE__ */ new WeakMap();
const _hashData = [];
class LightsNode extends Node {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3");
    this.totalDiffuseNode = property("vec3", "totalDiffuse");
    this.totalSpecularNode = property("vec3", "totalSpecular");
    this.outgoingLightNode = property("vec3", "outgoingLight");
    this._lights = [];
    this._lightNodes = null;
    this._lightNodesHash = null;
    this.global = true;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const lights2 = this._lights;
    for (let i = 0; i < lights2.length; i++) {
      const light = lights2[i];
      _hashData.push(light.id);
      _hashData.push(light.castShadow ? 1 : 0);
      if (light.isSpotLight === true) {
        const hashMap = light.map !== null ? light.map.id : -1;
        const hashColorNode = light.colorNode ? light.colorNode.getCacheKey() : -1;
        _hashData.push(hashMap, hashColorNode);
      }
    }
    const cacheKey = hashArray(_hashData);
    _hashData.length = 0;
    return cacheKey;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(builder) {
    if (this._lightNodesHash === null) {
      if (this._lightNodes === null) this.setupLightsNode(builder);
      const hash5 = [];
      for (const lightNode of this._lightNodes) {
        hash5.push(lightNode.getHash());
      }
      this._lightNodesHash = "lights-" + hash5.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(builder) {
    const properties = builder.getNodeProperties(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
    properties.outputNode.build(builder);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(builder) {
    const lightNodes = [];
    const previousLightNodes = this._lightNodes;
    const lights2 = sortLights(this._lights);
    const nodeLibrary = builder.renderer.library;
    for (const light of lights2) {
      if (light.isNode) {
        lightNodes.push(nodeObject(light));
      } else {
        let lightNode = null;
        if (previousLightNodes !== null) {
          lightNode = getLightNodeById(light.id, previousLightNodes);
        }
        if (lightNode === null) {
          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
          if (lightNodeClass === null) {
            warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
            continue;
          }
          let lightNode2 = null;
          if (!_lightsNodeRef.has(light)) {
            lightNode2 = new lightNodeClass(light);
            _lightsNodeRef.set(light, lightNode2);
          } else {
            lightNode2 = _lightsNodeRef.get(light);
          }
          lightNodes.push(lightNode2);
        }
      }
    }
    this._lightNodes = lightNodes;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.direct({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  setupDirectRectAreaLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.directRectArea({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(builder, lightNodes) {
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getLightNodes(builder) {
    if (this._lightNodes === null) this.setupLightsNode(builder);
    return this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(builder) {
    const currentLightsNode = builder.lightsNode;
    builder.lightsNode = this;
    let outgoingLightNode = this.outgoingLightNode;
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    const properties = builder.getNodeProperties(this);
    if (lightingModel) {
      const { totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      properties.nodes = stack2.nodes;
      lightingModel.start(builder);
      const { backdrop, backdropAlpha } = context2;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3$2(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3$2(backdrop);
        }
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    } else {
      properties.nodes = [];
    }
    builder.lightsNode = currentLightsNode;
    return outgoingLightNode;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(lights2) {
    this._lights = lights2;
    this._lightNodes = null;
    this._lightNodesHash = null;
    return this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
}
const lights = (lights2 = []) => new LightsNode().setLights(lights2);
class ShadowBaseNode extends Node {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(light) {
    super();
    this.light = light;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.isShadowBaseNode = true;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: context2, material }) {
    shadowPositionWorld.assign(material.receivedShadowPositionNode || context2.shadowPositionWorld || positionWorld);
  }
}
const shadowPositionWorld = /* @__PURE__ */ property("vec3", "shadowPositionWorld");
function saveRendererState(renderer, state = {}) {
  state.toneMapping = renderer.toneMapping;
  state.toneMappingExposure = renderer.toneMappingExposure;
  state.outputColorSpace = renderer.outputColorSpace;
  state.renderTarget = renderer.getRenderTarget();
  state.activeCubeFace = renderer.getActiveCubeFace();
  state.activeMipmapLevel = renderer.getActiveMipmapLevel();
  state.renderObjectFunction = renderer.getRenderObjectFunction();
  state.pixelRatio = renderer.getPixelRatio();
  state.mrt = renderer.getMRT();
  state.clearColor = renderer.getClearColor(state.clearColor || new Color());
  state.clearAlpha = renderer.getClearAlpha();
  state.autoClear = renderer.autoClear;
  state.scissorTest = renderer.getScissorTest();
  return state;
}
function resetRendererState(renderer, state) {
  state = saveRendererState(renderer, state);
  renderer.setMRT(null);
  renderer.setRenderObjectFunction(null);
  renderer.setClearColor(0, 1);
  renderer.autoClear = true;
  return state;
}
function restoreRendererState(renderer, state) {
  renderer.toneMapping = state.toneMapping;
  renderer.toneMappingExposure = state.toneMappingExposure;
  renderer.outputColorSpace = state.outputColorSpace;
  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
  renderer.setRenderObjectFunction(state.renderObjectFunction);
  renderer.setPixelRatio(state.pixelRatio);
  renderer.setMRT(state.mrt);
  renderer.setClearColor(state.clearColor, state.clearAlpha);
  renderer.autoClear = state.autoClear;
  renderer.setScissorTest(state.scissorTest);
}
function saveSceneState(scene, state = {}) {
  state.background = scene.background;
  state.backgroundNode = scene.backgroundNode;
  state.overrideMaterial = scene.overrideMaterial;
  return state;
}
function resetSceneState(scene, state) {
  state = saveSceneState(scene, state);
  scene.background = null;
  scene.backgroundNode = null;
  scene.overrideMaterial = null;
  return state;
}
function restoreSceneState(scene, state) {
  scene.background = state.background;
  scene.backgroundNode = state.backgroundNode;
  scene.overrideMaterial = state.overrideMaterial;
}
function resetRendererAndSceneState(renderer, scene, state) {
  state = resetRendererState(renderer, state);
  state = resetSceneState(scene, state);
  return state;
}
function restoreRendererAndSceneState(renderer, scene, state) {
  restoreRendererState(renderer, state);
  restoreSceneState(scene, state);
}
const shadowMaterialLib = /* @__PURE__ */ new WeakMap();
const BasicShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, shadowCoord, depthLayer }) => {
  let basic = texture$2(depthTexture, shadowCoord.xy).setName("t_basic");
  if (depthTexture.isArrayTexture) {
    basic = basic.depth(depthLayer);
  }
  return basic.compare(shadowCoord.z);
});
const PCFShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
  const depthCompare = (uv2, compare) => {
    let depth2 = texture$2(depthTexture, uv2);
    if (depthTexture.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    return depth2.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
  const texelSize = vec2$2(1).div(mapSize);
  const radiusScaled = radius.mul(texelSize.x);
  const phi = interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718);
  return add$3(
    depthCompare(shadowCoord.xy.add(vogelDiskSample(0, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(1, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(2, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(3, 5, phi).mul(radiusScaled)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vogelDiskSample(4, 5, phi).mul(radiusScaled)), shadowCoord.z)
  ).mul(1 / 5);
});
const PCFSoftShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, shadowCoord, shadow: shadow2, depthLayer }) => {
  const depthCompare = (uv3, compare) => {
    let depth2 = texture$2(depthTexture, uv3);
    if (depthTexture.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    return depth2.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const texelSize = vec2$2(1).div(mapSize);
  const dx = texelSize.x;
  const dy = texelSize.y;
  const uv2 = shadowCoord.xy;
  const f = fract(uv2.mul(mapSize).add(0.5));
  uv2.subAssign(f.mul(texelSize));
  return add$3(
    depthCompare(uv2, shadowCoord.z),
    depthCompare(uv2.add(vec2$2(dx, 0)), shadowCoord.z),
    depthCompare(uv2.add(vec2$2(0, dy)), shadowCoord.z),
    depthCompare(uv2.add(texelSize), shadowCoord.z),
    mix(
      depthCompare(uv2.add(vec2$2(dx.negate(), 0)), shadowCoord.z),
      depthCompare(uv2.add(vec2$2(dx.mul(2), 0)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv2.add(vec2$2(dx.negate(), dy)), shadowCoord.z),
      depthCompare(uv2.add(vec2$2(dx.mul(2), dy)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv2.add(vec2$2(0, dy.negate())), shadowCoord.z),
      depthCompare(uv2.add(vec2$2(0, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      depthCompare(uv2.add(vec2$2(dx, dy.negate())), shadowCoord.z),
      depthCompare(uv2.add(vec2$2(dx, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      mix(
        depthCompare(uv2.add(vec2$2(dx.negate(), dy.negate())), shadowCoord.z),
        depthCompare(uv2.add(vec2$2(dx.mul(2), dy.negate())), shadowCoord.z),
        f.x
      ),
      mix(
        depthCompare(uv2.add(vec2$2(dx.negate(), dy.mul(2))), shadowCoord.z),
        depthCompare(uv2.add(vec2$2(dx.mul(2), dy.mul(2))), shadowCoord.z),
        f.x
      ),
      f.y
    )
  ).mul(1 / 9);
});
const VSMShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, shadowCoord, depthLayer }) => {
  let distribution = texture$2(depthTexture).sample(shadowCoord.xy);
  if (depthTexture.isArrayTexture) {
    distribution = distribution.depth(depthLayer);
  }
  distribution = distribution.rg;
  const mean = distribution.x;
  const variance = max$1$1(1e-7, distribution.y.mul(distribution.y));
  const hardShadow = step(shadowCoord.z, mean);
  If(hardShadow.equal(1), () => {
    return float$4(1);
  });
  const d = shadowCoord.z.sub(mean);
  let p_max = variance.div(variance.add(d.mul(d)));
  p_max = clamp$1(sub$3(p_max, 0.3).div(0.65));
  return max$1$1(hardShadow, p_max);
});
const linearDistance = /* @__PURE__ */ Fn$4(([position, cameraNear2, cameraFar2]) => {
  let dist = positionWorld.sub(position).length();
  dist = dist.sub(cameraNear2).div(cameraFar2.sub(cameraNear2));
  dist = dist.saturate();
  return dist;
});
const linearShadowDistance = (light) => {
  const camera = light.shadow.camera;
  const nearDistance = reference("near", "float", camera).setGroup(renderGroup);
  const farDistance = reference("far", "float", camera).setGroup(renderGroup);
  const referencePosition = objectPosition(light);
  return linearDistance(referencePosition, nearDistance, farDistance);
};
const getShadowMaterial = (light) => {
  let material = shadowMaterialLib.get(light);
  if (material === void 0) {
    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
    material = new NodeMaterial();
    material.colorNode = vec4$3(0, 0, 0, 1);
    material.depthNode = depthNode;
    material.isShadowPassMaterial = true;
    material.name = "ShadowMaterial";
    material.fog = false;
    shadowMaterialLib.set(light, material);
  }
  return material;
};
const disposeShadowMaterial = (light) => {
  const material = shadowMaterialLib.get(light);
  if (material !== void 0) {
    material.dispose();
    shadowMaterialLib.delete(light);
  }
};
const _shadowRenderObjectLibrary = /* @__PURE__ */ new ChainMap();
const _shadowRenderObjectKeys = [];
const getShadowRenderObjectFunction = (renderer, shadow2, shadowType, useVelocity) => {
  _shadowRenderObjectKeys[0] = renderer;
  _shadowRenderObjectKeys[1] = shadow2;
  let renderObjectFunction = _shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);
  if (renderObjectFunction === void 0 || (renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity)) {
    renderObjectFunction = (object, scene, _camera2, geometry, material, group, ...params) => {
      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {
        if (useVelocity) {
          getDataFromObject(object).useVelocity = true;
        }
        object.onBeforeShadow(renderer, object, _camera2, shadow2.camera, geometry, scene.overrideMaterial, group);
        renderer.renderObject(object, scene, _camera2, geometry, material, group, ...params);
        object.onAfterShadow(renderer, object, _camera2, shadow2.camera, geometry, scene.overrideMaterial, group);
      }
    };
    renderObjectFunction.shadowType = shadowType;
    renderObjectFunction.useVelocity = useVelocity;
    _shadowRenderObjectLibrary.set(_shadowRenderObjectKeys, renderObjectFunction);
  }
  _shadowRenderObjectKeys[0] = null;
  _shadowRenderObjectKeys[1] = null;
  return renderObjectFunction;
};
const VSMPassVertical = /* @__PURE__ */ Fn$4(({ samples, radius, size, shadowPass, depthLayer }) => {
  const mean = float$4(0).toVar("meanVertical");
  const squaredMean = float$4(0).toVar("squareMeanVertical");
  const uvStride = samples.lessThanEqual(float$4(1)).select(float$4(0), float$4(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float$4(1)).select(float$4(0), float$4(-1));
  Loop({ start: int$3(0), end: int$3(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float$4(i).mul(uvStride));
    let depth2 = shadowPass.sample(add$3(screenCoordinate.xy, vec2$2(0, uvOffset).mul(radius)).div(size));
    if (shadowPass.value.isArrayTexture) {
      depth2 = depth2.depth(depthLayer);
    }
    depth2 = depth2.x;
    mean.addAssign(depth2);
    squaredMean.addAssign(depth2.mul(depth2));
  });
  mean.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt$3(squaredMean.sub(mean.mul(mean)).max(0));
  return vec2$2(mean, std_dev);
});
const VSMPassHorizontal = /* @__PURE__ */ Fn$4(({ samples, radius, size, shadowPass, depthLayer }) => {
  const mean = float$4(0).toVar("meanHorizontal");
  const squaredMean = float$4(0).toVar("squareMeanHorizontal");
  const uvStride = samples.lessThanEqual(float$4(1)).select(float$4(0), float$4(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float$4(1)).select(float$4(0), float$4(-1));
  Loop({ start: int$3(0), end: int$3(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float$4(i).mul(uvStride));
    let distribution = shadowPass.sample(add$3(screenCoordinate.xy, vec2$2(uvOffset, 0).mul(radius)).div(size));
    if (shadowPass.value.isArrayTexture) {
      distribution = distribution.depth(depthLayer);
    }
    mean.addAssign(distribution.x);
    squaredMean.addAssign(add$3(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
  });
  mean.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt$3(squaredMean.sub(mean.mul(mean)).max(0));
  return vec2$2(mean, std_dev);
});
const _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];
let _rendererState;
const _quadMesh = /* @__PURE__ */ new QuadMesh();
class ShadowNode extends ShadowBaseNode {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light);
    this.shadow = shadow2 || light.shadow;
    this.shadowMap = null;
    this.vsmShadowMapVertical = null;
    this.vsmShadowMapHorizontal = null;
    this.vsmMaterialVertical = null;
    this.vsmMaterialHorizontal = null;
    this._node = null;
    this._currentShadowType = null;
    this._cameraFrameId = /* @__PURE__ */ new WeakMap();
    this.isShadowNode = true;
    this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow2, depthLayer }) {
    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
    const shadowNode = filterFn({ depthTexture, shadowCoord, shadow: shadow2, depthLayer });
    return frustumTest.select(shadowNode, float$4(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    const { shadow: shadow2 } = this;
    const { renderer } = builder;
    const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
    let shadowCoord = shadowPosition;
    let coordZ;
    if (shadow2.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      coordZ = shadowCoord.z;
      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
    } else {
      const w = shadowCoord.w;
      shadowCoord = shadowCoord.xy.div(w);
      const cameraNearLocal = reference("near", "float", shadow2.camera).setGroup(renderGroup);
      const cameraFarLocal = reference("far", "float", shadow2.camera).setGroup(renderGroup);
      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);
    }
    shadowCoord = vec3$2(
      shadowCoord.x,
      shadowCoord.y.oneMinus(),
      // follow webgpu standards
      coordZ.add(bias)
    );
    return shadowCoord;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return _shadowFilterLib[type];
  }
  setupRenderTarget(shadow2, builder) {
    const depthTexture = new DepthTexture(shadow2.mapSize.width, shadow2.mapSize.height);
    depthTexture.name = "ShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height);
    shadowMap.texture.name = "ShadowMap";
    shadowMap.texture.type = shadow2.mapType;
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(builder) {
    const { renderer, camera } = builder;
    const { light, shadow: shadow2 } = this;
    const shadowMapType = renderer.shadowMap.type;
    const { depthTexture, shadowMap } = this.setupRenderTarget(shadow2, builder);
    shadow2.camera.coordinateSystem = camera.coordinateSystem;
    shadow2.camera.updateProjectionMatrix();
    if (shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      depthTexture.compareFunction = null;
      if (shadowMap.depth > 1) {
        if (!shadowMap._vsmShadowMapVertical) {
          shadowMap._vsmShadowMapVertical = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapVertical.texture.name = "VSMVertical";
        }
        this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
        if (!shadowMap._vsmShadowMapHorizontal) {
          shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapHorizontal.texture.name = "VSMHorizontal";
        }
        this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
      } else {
        this.vsmShadowMapVertical = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
        this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow2.mapSize.width, shadow2.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
      }
      let shadowPassVertical = texture$2(depthTexture);
      if (depthTexture.isArrayTexture) {
        shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
      }
      let shadowPassHorizontal = texture$2(this.vsmShadowMapVertical.texture);
      if (depthTexture.isArrayTexture) {
        shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
      }
      const samples = reference("blurSamples", "float", shadow2).setGroup(renderGroup);
      const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
      const size = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
      material.fragmentNode = VSMPassVertical({ samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMVertical";
      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
      material.fragmentNode = VSMPassHorizontal({ samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMHorizontal";
    }
    const shadowIntensity = reference("intensity", "float", shadow2).setGroup(renderGroup);
    const normalBias = reference("normalBias", "float", shadow2).setGroup(renderGroup);
    const shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(normalWorld.mul(normalBias)));
    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
    const filterFn = shadow2.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
    if (filterFn === null) {
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    }
    const shadowDepthTexture = shadowMapType === VSMShadowMap && shadow2.isPointLightShadow !== true ? this.vsmShadowMapHorizontal.texture : depthTexture;
    const shadowNode = this.setupShadowFilter(builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow: shadow2, depthLayer: this.depthLayer });
    let shadowColor;
    if (shadowMap.texture.isCubeTexture) {
      shadowColor = cubeTexture(shadowMap.texture, shadowCoord.xyz);
    } else {
      shadowColor = texture$2(shadowMap.texture, shadowCoord);
      if (depthTexture.isArrayTexture) {
        shadowColor = shadowColor.depth(this.depthLayer);
      }
    }
    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
    this.shadowMap = shadowMap;
    this.shadow.map = shadowMap;
    const inspectName = `${this.light.type} Shadow [ ${this.light.name || "ID: " + this.light.id} ]`;
    return shadowOutput.toInspector(`${inspectName} / Color`, () => {
      if (this.shadowMap.texture.isCubeTexture) {
        return cubeTexture(this.shadowMap.texture);
      }
      return texture$2(this.shadowMap.texture);
    }).toInspector(`${inspectName} / Depth`, () => {
      if (this.shadowMap.texture.isCubeTexture) {
        return cubeTexture(this.shadowMap.texture).r.oneMinus();
      }
      return textureLoad$2(this.shadowMap.depthTexture, uv$1().mul(textureSize(texture$2(this.shadowMap.depthTexture)))).r.oneMinus();
    });
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(builder) {
    if (builder.renderer.shadowMap.enabled === false) return;
    return Fn$4(() => {
      const currentShadowType = builder.renderer.shadowMap.type;
      if (this._currentShadowType !== currentShadowType) {
        this._reset();
        this._node = null;
      }
      let node = this._node;
      this.setupShadowPosition(builder);
      if (node === null) {
        this._node = node = this.setupShadow(builder);
        this._currentShadowType = currentShadowType;
      }
      if (builder.material.shadowNode) {
        warn('NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
      }
      if (builder.material.receivedShadowNode) {
        node = builder.material.receivedShadowNode(node);
      }
      return node;
    })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer, scene } = frame;
    shadow2.updateMatrices(light);
    shadowMap.setSize(shadow2.mapSize.width, shadow2.mapSize.height, shadowMap.depth);
    const currentSceneName = scene.name;
    scene.name = `Shadow Map [ ${light.name || "ID: " + light.id} ]`;
    renderer.render(scene, shadow2.camera);
    scene.name = currentSceneName;
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(frame) {
    const { shadowMap, light, shadow: shadow2 } = this;
    const { renderer, scene, camera } = frame;
    const shadowType = renderer.shadowMap.type;
    const depthVersion = shadowMap.depthTexture.version;
    this._depthVersionCached = depthVersion;
    const _shadowCameraLayer = shadow2.camera.layers.mask;
    if ((shadow2.camera.layers.mask & 4294967294) === 0) {
      shadow2.camera.layers.mask = camera.layers.mask;
    }
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    const currentMRT = renderer.getMRT();
    const useVelocity = currentMRT ? currentMRT.has("velocity") : false;
    _rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);
    scene.overrideMaterial = getShadowMaterial(light);
    renderer.setRenderObjectFunction(getShadowRenderObjectFunction(renderer, shadow2, shadowType, useVelocity));
    renderer.setClearColor(0, 0);
    renderer.setRenderTarget(shadowMap);
    this.renderShadow(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    if (shadowType === VSMShadowMap && shadow2.isPointLightShadow !== true) {
      this.vsmPass(renderer);
    }
    shadow2.camera.layers.mask = _shadowCameraLayer;
    restoreRendererAndSceneState(renderer, scene, _rendererState);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(renderer) {
    const { shadow: shadow2 } = this;
    const depth2 = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(shadow2.mapSize.width, shadow2.mapSize.height, depth2);
    this.vsmShadowMapHorizontal.setSize(shadow2.mapSize.width, shadow2.mapSize.height, depth2);
    renderer.setRenderTarget(this.vsmShadowMapVertical);
    _quadMesh.material = this.vsmMaterialVertical;
    _quadMesh.render(renderer);
    renderer.setRenderTarget(this.vsmShadowMapHorizontal);
    _quadMesh.material = this.vsmMaterialHorizontal;
    _quadMesh.render(renderer);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this._reset();
    super.dispose();
  }
  /**
   * Resets the resouce state of this shadow node.
   *
   * @private
   */
  _reset() {
    this._currentShadowType = null;
    disposeShadowMaterial(this.light);
    if (this.shadowMap) {
      this.shadowMap.dispose();
      this.shadowMap = null;
    }
    if (this.vsmShadowMapVertical !== null) {
      this.vsmShadowMapVertical.dispose();
      this.vsmShadowMapVertical = null;
      this.vsmMaterialVertical.dispose();
      this.vsmMaterialVertical = null;
    }
    if (this.vsmShadowMapHorizontal !== null) {
      this.vsmShadowMapHorizontal.dispose();
      this.vsmShadowMapHorizontal = null;
      this.vsmMaterialHorizontal.dispose();
      this.vsmMaterialHorizontal = null;
    }
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(frame) {
    const { shadow: shadow2 } = this;
    let needsUpdate = shadow2.needsUpdate || shadow2.autoUpdate;
    if (needsUpdate) {
      if (this._cameraFrameId[frame.camera] === frame.frameId) {
        needsUpdate = false;
      }
      this._cameraFrameId[frame.camera] = frame.frameId;
    }
    if (needsUpdate) {
      this.updateShadow(frame);
      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
        shadow2.needsUpdate = false;
      }
    }
  }
}
const shadow = (light, shadow2) => new ShadowNode(light, shadow2);
const _clearColor$1 = /* @__PURE__ */ new Color();
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
const _cubeDirectionsWebGPU = [
  /* @__PURE__ */ new Vector3(1, 0, 0),
  /* @__PURE__ */ new Vector3(-1, 0, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 1, 0),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, 0, -1)
];
const _cubeUpsWebGPU = [
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 0, -1),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0)
];
const _cubeDirectionsWebGL = [
  /* @__PURE__ */ new Vector3(1, 0, 0),
  /* @__PURE__ */ new Vector3(-1, 0, 0),
  /* @__PURE__ */ new Vector3(0, 1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, 0, -1)
];
const _cubeUpsWebGL = [
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, 0, -1),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0)
];
const BasicPointShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, bd3D, dp }) => {
  return cubeTexture(depthTexture, bd3D).compare(dp);
});
const PointShadowFilter = /* @__PURE__ */ Fn$4(({ depthTexture, bd3D, dp, shadow: shadow2 }) => {
  const radius = reference("radius", "float", shadow2).setGroup(renderGroup);
  const mapSize = reference("mapSize", "vec2", shadow2).setGroup(renderGroup);
  const texelSize = radius.div(mapSize.x);
  const absDir = abs$2(bd3D);
  const tangent = normalize$1(cross$1(bd3D, absDir.x.greaterThan(absDir.z).select(vec3$2(0, 1, 0), vec3$2(1, 0, 0))));
  const bitangent = cross$1(bd3D, tangent);
  const phi = interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718);
  const sample0 = vogelDiskSample(0, 5, phi);
  const sample1 = vogelDiskSample(1, 5, phi);
  const sample2 = vogelDiskSample(2, 5, phi);
  const sample3 = vogelDiskSample(3, 5, phi);
  const sample4 = vogelDiskSample(4, 5, phi);
  return cubeTexture(depthTexture, bd3D.add(tangent.mul(sample0.x).add(bitangent.mul(sample0.y)).mul(texelSize))).compare(dp).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample1.x).add(bitangent.mul(sample1.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample2.x).add(bitangent.mul(sample2.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample3.x).add(bitangent.mul(sample3.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture, bd3D.add(tangent.mul(sample4.x).add(bitangent.mul(sample4.y)).mul(texelSize))).compare(dp)).mul(1 / 5);
});
const pointShadowFilter = /* @__PURE__ */ Fn$4(({ filterFn, depthTexture, shadowCoord, shadow: shadow2 }) => {
  const lightToPosition = shadowCoord.xyz.toVar();
  const lightToPositionLength = lightToPosition.length();
  const cameraNearLocal = uniform$2("float").setGroup(renderGroup).onRenderUpdate(() => shadow2.camera.near);
  const cameraFarLocal = uniform$2("float").setGroup(renderGroup).onRenderUpdate(() => shadow2.camera.far);
  const bias = reference("bias", "float", shadow2).setGroup(renderGroup);
  const result = float$4(1).toVar();
  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)), () => {
    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar();
    dp.addAssign(bias);
    const bd3D = lightToPosition.normalize();
    result.assign(filterFn({ depthTexture, bd3D, dp, shadow: shadow2 }));
  });
  return result;
});
class PointShadowNode extends ShadowNode {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(light, shadow2 = null) {
    super(light, shadow2);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    return shadowPosition;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's depth texture.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow2 }) {
    return pointShadowFilter({ filterFn, depthTexture, shadowCoord, shadow: shadow2 });
  }
  /**
   * Overwrites the default implementation to create a CubeRenderTarget with CubeDepthTexture.
   *
   * @param {LightShadow} shadow - The light shadow object.
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Object} An object containing the shadow map and depth texture.
   */
  setupRenderTarget(shadow2, builder) {
    const depthTexture = new CubeDepthTexture(shadow2.mapSize.width);
    depthTexture.name = "PointShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createCubeRenderTarget(shadow2.mapSize.width);
    shadowMap.texture.name = "PointShadowMap";
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow2, shadowMap, light } = this;
    const { renderer, scene } = frame;
    const camera = shadow2.camera;
    const shadowMatrix = shadow2.matrix;
    const isWebGPU = renderer.coordinateSystem === WebGPUCoordinateSystem;
    const cubeDirections = isWebGPU ? _cubeDirectionsWebGPU : _cubeDirectionsWebGL;
    const cubeUps = isWebGPU ? _cubeUpsWebGPU : _cubeUpsWebGL;
    shadowMap.setSize(shadow2.mapSize.width, shadow2.mapSize.width);
    const previousAutoClear = renderer.autoClear;
    const previousClearColor = renderer.getClearColor(_clearColor$1);
    const previousClearAlpha = renderer.getClearAlpha();
    renderer.autoClear = false;
    renderer.setClearColor(shadow2.clearColor, shadow2.clearAlpha);
    for (let face = 0; face < 6; face++) {
      renderer.setRenderTarget(shadowMap, face);
      renderer.clear();
      const far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(cubeDirections[face]);
      camera.up.copy(cubeUps[face]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      shadow2._frustum.setFromProjectionMatrix(_projScreenMatrix$1, camera.coordinateSystem, camera.reversedDepth);
      const currentSceneName = scene.name;
      scene.name = `Point Light Shadow [ ${light.name || "ID: " + light.id} ] - Face ${face + 1}`;
      renderer.render(scene, camera);
      scene.name = currentSceneName;
    }
    renderer.autoClear = previousAutoClear;
    renderer.setClearColor(previousClearColor, previousClearAlpha);
  }
}
const pointShadow = (light, shadow2) => new PointShadowNode(light, shadow2);
const getDistanceAttenuation = /* @__PURE__ */ Fn$4(({ lightDistance, cutoffDistance, decayExponent }) => {
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).select(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});
const directPointLight = ({ color: color2, lightVector, cutoffDistance, decayExponent }) => {
  const lightDirection = lightVector.normalize();
  const lightDistance = lightVector.length();
  const attenuation = getDistanceAttenuation({
    lightDistance,
    cutoffDistance,
    decayExponent
  });
  const lightColor = color2.mul(attenuation);
  return { lightDirection, lightColor };
};
const checker = /* @__PURE__ */ Fn$4(([coord = uv$1()]) => {
  const uv2 = coord.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
const shapeCircle = Fn$4(([coord = uv$1()], { renderer, material }) => {
  const len2 = lengthSq(coord.mul(2).sub(1));
  let alpha;
  if (material.alphaToCoverage && renderer.currentSamples > 0) {
    const dlen = float$4(len2.fwidth()).toVar();
    alpha = smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
  } else {
    alpha = select$3(len2.greaterThan(1), 0, 1);
  }
  return alpha;
});
const mx_select = /* @__PURE__ */ Fn$4(([b_immutable, t_immutable, f_immutable]) => {
  const f = float$4(f_immutable).toVar();
  const t = float$4(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return select$3(b, t, f);
}).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
const mx_negate_if = /* @__PURE__ */ Fn$4(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float$4(val_immutable).toVar();
  return select$3(b, val.negate(), val);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
const mx_floor = /* @__PURE__ */ Fn$4(([x_immutable]) => {
  const x = float$4(x_immutable).toVar();
  return int$3(floor(x));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
const mx_floorfrac = /* @__PURE__ */ Fn$4(([x_immutable, i]) => {
  const x = float$4(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float$4(i));
});
const mx_bilerp_0 = /* @__PURE__ */ Fn$4(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float$4(t_immutable).toVar();
  const s = float$4(s_immutable).toVar();
  const v3 = float$4(v3_immutable).toVar();
  const v2 = float$4(v2_immutable).toVar();
  const v1 = float$4(v1_immutable).toVar();
  const v0 = float$4(v0_immutable).toVar();
  const s1 = float$4(sub$3(1, s)).toVar();
  return sub$3(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
const mx_bilerp_1 = /* @__PURE__ */ Fn$4(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float$4(t_immutable).toVar();
  const s = float$4(s_immutable).toVar();
  const v3 = vec3$2(v3_immutable).toVar();
  const v2 = vec3$2(v2_immutable).toVar();
  const v1 = vec3$2(v1_immutable).toVar();
  const v0 = vec3$2(v0_immutable).toVar();
  const s1 = float$4(sub$3(1, s)).toVar();
  return sub$3(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
const mx_bilerp = /* @__PURE__ */ overloadingFn([mx_bilerp_0, mx_bilerp_1]);
const mx_trilerp_0 = /* @__PURE__ */ Fn$4(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float$4(r_immutable).toVar();
  const t = float$4(t_immutable).toVar();
  const s = float$4(s_immutable).toVar();
  const v7 = float$4(v7_immutable).toVar();
  const v6 = float$4(v6_immutable).toVar();
  const v5 = float$4(v5_immutable).toVar();
  const v4 = float$4(v4_immutable).toVar();
  const v3 = float$4(v3_immutable).toVar();
  const v2 = float$4(v2_immutable).toVar();
  const v1 = float$4(v1_immutable).toVar();
  const v0 = float$4(v0_immutable).toVar();
  const s1 = float$4(sub$3(1, s)).toVar();
  const t1 = float$4(sub$3(1, t)).toVar();
  const r1 = float$4(sub$3(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
const mx_trilerp_1 = /* @__PURE__ */ Fn$4(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float$4(r_immutable).toVar();
  const t = float$4(t_immutable).toVar();
  const s = float$4(s_immutable).toVar();
  const v7 = vec3$2(v7_immutable).toVar();
  const v6 = vec3$2(v6_immutable).toVar();
  const v5 = vec3$2(v5_immutable).toVar();
  const v4 = vec3$2(v4_immutable).toVar();
  const v3 = vec3$2(v3_immutable).toVar();
  const v2 = vec3$2(v2_immutable).toVar();
  const v1 = vec3$2(v1_immutable).toVar();
  const v0 = vec3$2(v0_immutable).toVar();
  const s1 = float$4(sub$3(1, s)).toVar();
  const t1 = float$4(sub$3(1, t)).toVar();
  const r1 = float$4(sub$3(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
const mx_trilerp = /* @__PURE__ */ overloadingFn([mx_trilerp_0, mx_trilerp_1]);
const mx_gradient_float_0 = /* @__PURE__ */ Fn$4(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float$4(y_immutable).toVar();
  const x = float$4(x_immutable).toVar();
  const hash5 = uint$3(hash_immutable).toVar();
  const h = uint$3(hash5.bitAnd(uint$3(7))).toVar();
  const u = float$4(mx_select(h.lessThan(uint$3(4)), x, y)).toVar();
  const v = float$4(mul$3(2, mx_select(h.lessThan(uint$3(4)), y, x))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint$3(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint$3(2)))));
}).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
const mx_gradient_float_1 = /* @__PURE__ */ Fn$4(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float$4(z_immutable).toVar();
  const y = float$4(y_immutable).toVar();
  const x = float$4(x_immutable).toVar();
  const hash5 = uint$3(hash_immutable).toVar();
  const h = uint$3(hash5.bitAnd(uint$3(15))).toVar();
  const u = float$4(mx_select(h.lessThan(uint$3(8)), x, y)).toVar();
  const v = float$4(mx_select(h.lessThan(uint$3(4)), y, mx_select(h.equal(uint$3(12)).or(h.equal(uint$3(14))), x, z))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint$3(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint$3(2)))));
}).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
const mx_gradient_float = /* @__PURE__ */ overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
const mx_gradient_vec3_0 = /* @__PURE__ */ Fn$4(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float$4(y_immutable).toVar();
  const x = float$4(x_immutable).toVar();
  const hash5 = uvec3(hash_immutable).toVar();
  return vec3$2(mx_gradient_float(hash5.x, x, y), mx_gradient_float(hash5.y, x, y), mx_gradient_float(hash5.z, x, y));
}).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
const mx_gradient_vec3_1 = /* @__PURE__ */ Fn$4(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float$4(z_immutable).toVar();
  const y = float$4(y_immutable).toVar();
  const x = float$4(x_immutable).toVar();
  const hash5 = uvec3(hash_immutable).toVar();
  return vec3$2(mx_gradient_float(hash5.x, x, y, z), mx_gradient_float(hash5.y, x, y, z), mx_gradient_float(hash5.z, x, y, z));
}).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
const mx_gradient_vec3 = /* @__PURE__ */ overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
const mx_gradient_scale2d_0 = /* @__PURE__ */ Fn$4(([v_immutable]) => {
  const v = float$4(v_immutable).toVar();
  return mul$3(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
const mx_gradient_scale3d_0 = /* @__PURE__ */ Fn$4(([v_immutable]) => {
  const v = float$4(v_immutable).toVar();
  return mul$3(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
const mx_gradient_scale2d_1 = /* @__PURE__ */ Fn$4(([v_immutable]) => {
  const v = vec3$2(v_immutable).toVar();
  return mul$3(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
const mx_gradient_scale2d = /* @__PURE__ */ overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
const mx_gradient_scale3d_1 = /* @__PURE__ */ Fn$4(([v_immutable]) => {
  const v = vec3$2(v_immutable).toVar();
  return mul$3(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
const mx_gradient_scale3d = /* @__PURE__ */ overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
const mx_rotl32 = /* @__PURE__ */ Fn$4(([x_immutable, k_immutable]) => {
  const k = int$3(k_immutable).toVar();
  const x = uint$3(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int$3(32).sub(k)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
const mx_bjmix = /* @__PURE__ */ Fn$4(([a, b, c]) => {
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int$3(4)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int$3(6)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int$3(8)));
  b.addAssign(a);
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int$3(16)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int$3(19)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int$3(4)));
  b.addAssign(a);
});
const mx_bjfinal = /* @__PURE__ */ Fn$4(([a_immutable, b_immutable, c_immutable]) => {
  const c = uint$3(c_immutable).toVar();
  const b = uint$3(b_immutable).toVar();
  const a = uint$3(a_immutable).toVar();
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int$3(14)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int$3(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int$3(25)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int$3(16)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int$3(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int$3(14)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int$3(24)));
  return c;
}).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
const mx_bits_to_01 = /* @__PURE__ */ Fn$4(([bits_immutable]) => {
  const bits2 = uint$3(bits_immutable).toVar();
  return float$4(bits2).div(float$4(uint$3(int$3(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
const mx_fade = /* @__PURE__ */ Fn$4(([t_immutable]) => {
  const t = float$4(t_immutable).toVar();
  return t.mul(t).mul(t).mul(t.mul(t.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
const mx_hash_int_0 = /* @__PURE__ */ Fn$4(([x_immutable]) => {
  const x = int$3(x_immutable).toVar();
  const len = uint$3(uint$3(1)).toVar();
  const seed = uint$3(uint$3(int$3(3735928559)).add(len.shiftLeft(uint$3(2))).add(uint$3(13))).toVar();
  return mx_bjfinal(seed.add(uint$3(x)), seed, seed);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
const mx_hash_int_1 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable]) => {
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const len = uint$3(uint$3(2)).toVar();
  const a = uint$3().toVar(), b = uint$3().toVar(), c = uint$3().toVar();
  a.assign(b.assign(c.assign(uint$3(int$3(3735928559)).add(len.shiftLeft(uint$3(2))).add(uint$3(13)))));
  a.addAssign(uint$3(x));
  b.addAssign(uint$3(y));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
const mx_hash_int_2 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable, z_immutable]) => {
  const z = int$3(z_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const len = uint$3(uint$3(3)).toVar();
  const a = uint$3().toVar(), b = uint$3().toVar(), c = uint$3().toVar();
  a.assign(b.assign(c.assign(uint$3(int$3(3735928559)).add(len.shiftLeft(uint$3(2))).add(uint$3(13)))));
  a.addAssign(uint$3(x));
  b.addAssign(uint$3(y));
  c.addAssign(uint$3(z));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
const mx_hash_int_3 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int$3(xx_immutable).toVar();
  const z = int$3(z_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const len = uint$3(uint$3(4)).toVar();
  const a = uint$3().toVar(), b = uint$3().toVar(), c = uint$3().toVar();
  a.assign(b.assign(c.assign(uint$3(int$3(3735928559)).add(len.shiftLeft(uint$3(2))).add(uint$3(13)))));
  a.addAssign(uint$3(x));
  b.addAssign(uint$3(y));
  c.addAssign(uint$3(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint$3(xx));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
const mx_hash_int_4 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int$3(yy_immutable).toVar();
  const xx = int$3(xx_immutable).toVar();
  const z = int$3(z_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const len = uint$3(uint$3(5)).toVar();
  const a = uint$3().toVar(), b = uint$3().toVar(), c = uint$3().toVar();
  a.assign(b.assign(c.assign(uint$3(int$3(3735928559)).add(len.shiftLeft(uint$3(2))).add(uint$3(13)))));
  a.addAssign(uint$3(x));
  b.addAssign(uint$3(y));
  c.addAssign(uint$3(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint$3(xx));
  b.addAssign(uint$3(yy));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
const mx_hash_int = /* @__PURE__ */ overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
const mx_hash_vec3_0 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable]) => {
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const h = uint$3(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int$3(255)));
  result.y.assign(h.shiftRight(int$3(8)).bitAnd(int$3(255)));
  result.z.assign(h.shiftRight(int$3(16)).bitAnd(int$3(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
const mx_hash_vec3_1 = /* @__PURE__ */ Fn$4(([x_immutable, y_immutable, z_immutable]) => {
  const z = int$3(z_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const h = uint$3(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int$3(255)));
  result.y.assign(h.shiftRight(int$3(8)).bitAnd(int$3(255)));
  result.z.assign(h.shiftRight(int$3(16)).bitAnd(int$3(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
const mx_hash_vec3 = /* @__PURE__ */ overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
const mx_perlin_noise_float_0 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec2$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar();
  const fx = float$4(mx_floorfrac(p.x, X)).toVar();
  const fy = float$4(mx_floorfrac(p.y, Y)).toVar();
  const u = float$4(mx_fade(fx)).toVar();
  const v = float$4(mx_fade(fy)).toVar();
  const result = float$4(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int$3(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y.add(int$3(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
const mx_perlin_noise_float_1 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec3$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar(), Z = int$3().toVar();
  const fx = float$4(mx_floorfrac(p.x, X)).toVar();
  const fy = float$4(mx_floorfrac(p.y, Y)).toVar();
  const fz = float$4(mx_floorfrac(p.z, Z)).toVar();
  const u = float$4(mx_fade(fx)).toVar();
  const v = float$4(mx_fade(fy)).toVar();
  const w = float$4(mx_fade(fz)).toVar();
  const result = float$4(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int$3(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y.add(int$3(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int$3(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y, Z.add(int$3(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int$3(1)), Z.add(int$3(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int$3(1)), Y.add(int$3(1)), Z.add(int$3(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
const mx_perlin_noise_float = /* @__PURE__ */ overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
const mx_perlin_noise_vec3_0 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec2$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar();
  const fx = float$4(mx_floorfrac(p.x, X)).toVar();
  const fy = float$4(mx_floorfrac(p.y, Y)).toVar();
  const u = float$4(mx_fade(fx)).toVar();
  const v = float$4(mx_fade(fy)).toVar();
  const result = vec3$2(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$3(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y.add(int$3(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
const mx_perlin_noise_vec3_1 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec3$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar(), Z = int$3().toVar();
  const fx = float$4(mx_floorfrac(p.x, X)).toVar();
  const fy = float$4(mx_floorfrac(p.y, Y)).toVar();
  const fz = float$4(mx_floorfrac(p.z, Z)).toVar();
  const u = float$4(mx_fade(fx)).toVar();
  const v = float$4(mx_fade(fy)).toVar();
  const w = float$4(mx_fade(fz)).toVar();
  const result = vec3$2(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$3(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y.add(int$3(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int$3(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y, Z.add(int$3(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int$3(1)), Z.add(int$3(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int$3(1)), Y.add(int$3(1)), Z.add(int$3(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
const mx_perlin_noise_vec3 = /* @__PURE__ */ overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
const mx_cell_noise_float_0 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = float$4(p_immutable).toVar();
  const ix = int$3(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
const mx_cell_noise_float_1 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec2$2(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
const mx_cell_noise_float_2 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec3$2(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  const iz = int$3(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
const mx_cell_noise_float_3 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec4$3(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  const iz = int$3(mx_floor(p.z)).toVar();
  const iw = int$3(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
const mx_cell_noise_float$1 = /* @__PURE__ */ overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
const mx_cell_noise_vec3_0 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = float$4(p_immutable).toVar();
  const ix = int$3(mx_floor(p)).toVar();
  return vec3$2(mx_bits_to_01(mx_hash_int(ix, int$3(0))), mx_bits_to_01(mx_hash_int(ix, int$3(1))), mx_bits_to_01(mx_hash_int(ix, int$3(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
const mx_cell_noise_vec3_1 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec2$2(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  return vec3$2(mx_bits_to_01(mx_hash_int(ix, iy, int$3(0))), mx_bits_to_01(mx_hash_int(ix, iy, int$3(1))), mx_bits_to_01(mx_hash_int(ix, iy, int$3(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
const mx_cell_noise_vec3_2 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec3$2(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  const iz = int$3(mx_floor(p.z)).toVar();
  return vec3$2(mx_bits_to_01(mx_hash_int(ix, iy, iz, int$3(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int$3(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int$3(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
const mx_cell_noise_vec3_3 = /* @__PURE__ */ Fn$4(([p_immutable]) => {
  const p = vec4$3(p_immutable).toVar();
  const ix = int$3(mx_floor(p.x)).toVar();
  const iy = int$3(mx_floor(p.y)).toVar();
  const iz = int$3(mx_floor(p.z)).toVar();
  const iw = int$3(mx_floor(p.w)).toVar();
  return vec3$2(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$3(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$3(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int$3(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
const mx_cell_noise_vec3 = /* @__PURE__ */ overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
const mx_fractal_noise_float$1 = /* @__PURE__ */ Fn$4(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float$4(diminish_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const result = float$4(0).toVar();
  const amplitude = float$4(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_fractal_noise_vec3$1 = /* @__PURE__ */ Fn$4(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float$4(diminish_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const result = vec3$2(0).toVar();
  const amplitude = float$4(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_fractal_noise_vec2$1 = /* @__PURE__ */ Fn$4(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float$4(diminish_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  return vec2$2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3$2(int$3(19), int$3(193), int$3(17))), octaves, lacunarity, diminish));
}).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_fractal_noise_vec4$1 = /* @__PURE__ */ Fn$4(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float$4(diminish_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const c = vec3$2(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();
  const f = float$4(mx_fractal_noise_float$1(p.add(vec3$2(int$3(19), int$3(193), int$3(17))), octaves, lacunarity, diminish)).toVar();
  return vec4$3(c, f);
}).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_worley_distance_0 = /* @__PURE__ */ Fn$4(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const yoff = int$3(yoff_immutable).toVar();
  const xoff = int$3(xoff_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const p = vec2$2(p_immutable).toVar();
  const tmp = vec3$2(mx_cell_noise_vec3(vec2$2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2$2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2$2(vec2$2(float$4(x), float$4(y)).add(off)).toVar();
  const diff = vec2$2(cellpos.sub(p)).toVar();
  If(metric.equal(int$3(2)), () => {
    return abs$2(diff.x).add(abs$2(diff.y));
  });
  If(metric.equal(int$3(3)), () => {
    return max$1$1(abs$2(diff.x), abs$2(diff.y));
  });
  return dot$3(diff, diff);
}).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_distance_1 = /* @__PURE__ */ Fn$4(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const zoff = int$3(zoff_immutable).toVar();
  const yoff = int$3(yoff_immutable).toVar();
  const xoff = int$3(xoff_immutable).toVar();
  const z = int$3(z_immutable).toVar();
  const y = int$3(y_immutable).toVar();
  const x = int$3(x_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const off = vec3$2(mx_cell_noise_vec3(vec3$2(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3$2(vec3$2(float$4(x), float$4(y), float$4(z)).add(off)).toVar();
  const diff = vec3$2(cellpos.sub(p)).toVar();
  If(metric.equal(int$3(2)), () => {
    return abs$2(diff.x).add(abs$2(diff.y)).add(abs$2(diff.z));
  });
  If(metric.equal(int$3(3)), () => {
    return max$1$1(abs$2(diff.x), abs$2(diff.y), abs$2(diff.z));
  });
  return dot$3(diff, diff);
}).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_distance = /* @__PURE__ */ overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
const mx_worley_noise_float_0 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec2$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar();
  const localpos = vec2$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float$4(1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float$4(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      sqdist.assign(min$1$1(sqdist, dist));
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_vec2_0 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec2$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar();
  const localpos = vec2$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2$2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float$4(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_vec3_0 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec2$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar();
  const localpos = vec2$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3$2(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float$4(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_float_1 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar(), Z = int$3().toVar();
  const localpos = vec3$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float$4(1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int$3(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float$4(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min$1$1(sqdist, dist));
      });
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_float$1 = /* @__PURE__ */ overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
const mx_worley_noise_vec2_1 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar(), Z = int$3().toVar();
  const localpos = vec3$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2$2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int$3(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float$4(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_vec2$1 = /* @__PURE__ */ overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
const mx_worley_noise_vec3_1 = /* @__PURE__ */ Fn$4(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int$3(metric_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const p = vec3$2(p_immutable).toVar();
  const X = int$3().toVar(), Y = int$3().toVar(), Z = int$3().toVar();
  const localpos = vec3$2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3$2(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int$3(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int$3(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int$3(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float$4(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int$3(0)), () => {
    sqdist.assign(sqrt$3(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
const mx_worley_noise_vec3$1 = /* @__PURE__ */ overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
const mx_unifiednoise2d$1 = /* @__PURE__ */ Fn$4(([
  noiseType_immutable,
  texcoord_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int$3(noiseType_immutable).toVar();
  const texcoord = vec2$2(texcoord_immutable).toVar();
  const freq = vec2$2(freq_immutable).toVar();
  const offset = vec2$2(offset_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const outmin = float$4(outmin_immutable).toVar();
  const outmax = float$4(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const diminish = float$4(diminish_immutable).toVar();
  const p = texcoord.mul(freq).add(offset);
  const result = float$4(0).toVar();
  If(noiseType.equal(int$3(0)), () => {
    result.assign(mx_perlin_noise_vec3(p));
  });
  If(noiseType.equal(int$3(1)), () => {
    result.assign(mx_cell_noise_vec3(p));
  });
  If(noiseType.equal(int$3(2)), () => {
    result.assign(mx_worley_noise_vec3$1(p, jitter, int$3(0)));
  });
  If(noiseType.equal(int$3(3)), () => {
    result.assign(mx_fractal_noise_vec3$1(vec3$2(p, 0), octaves, lacunarity, diminish));
  });
  result.assign(result.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result.assign(clamp$1(result, outmin, outmax));
  });
  return result;
}).setLayout({
  name: "mx_unifiednoise2d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "texcoord", type: "vec2" },
    { name: "freq", type: "vec2" },
    { name: "offset", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_unifiednoise3d$1 = /* @__PURE__ */ Fn$4(([
  noiseType_immutable,
  position_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int$3(noiseType_immutable).toVar();
  const position = vec3$2(position_immutable).toVar();
  const freq = vec3$2(freq_immutable).toVar();
  const offset = vec3$2(offset_immutable).toVar();
  const jitter = float$4(jitter_immutable).toVar();
  const outmin = float$4(outmin_immutable).toVar();
  const outmax = float$4(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int$3(octaves_immutable).toVar();
  const lacunarity = float$4(lacunarity_immutable).toVar();
  const diminish = float$4(diminish_immutable).toVar();
  const p = position.mul(freq).add(offset);
  const result = float$4(0).toVar();
  If(noiseType.equal(int$3(0)), () => {
    result.assign(mx_perlin_noise_vec3(p));
  });
  If(noiseType.equal(int$3(1)), () => {
    result.assign(mx_cell_noise_vec3(p));
  });
  If(noiseType.equal(int$3(2)), () => {
    result.assign(mx_worley_noise_vec3$1(p, jitter, int$3(0)));
  });
  If(noiseType.equal(int$3(3)), () => {
    result.assign(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish));
  });
  result.assign(result.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result.assign(clamp$1(result, outmin, outmax));
  });
  return result;
}).setLayout({
  name: "mx_unifiednoise3d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "position", type: "vec3" },
    { name: "freq", type: "vec3" },
    { name: "offset", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
const mx_hsvtorgb = /* @__PURE__ */ Fn$4(([hsv]) => {
  const s = hsv.y;
  const v = hsv.z;
  const result = vec3$2().toVar();
  If(s.lessThan(1e-4), () => {
    result.assign(vec3$2(v, v, v));
  }).Else(() => {
    let h = hsv.x;
    h = h.sub(floor(h)).mul(6).toVar();
    const hi = int$3(trunc(h));
    const f = h.sub(float$4(hi));
    const p = v.mul(s.oneMinus());
    const q = v.mul(s.mul(f).oneMinus());
    const t = v.mul(s.mul(f.oneMinus()).oneMinus());
    If(hi.equal(int$3(0)), () => {
      result.assign(vec3$2(v, t, p));
    }).ElseIf(hi.equal(int$3(1)), () => {
      result.assign(vec3$2(q, v, p));
    }).ElseIf(hi.equal(int$3(2)), () => {
      result.assign(vec3$2(p, v, t));
    }).ElseIf(hi.equal(int$3(3)), () => {
      result.assign(vec3$2(p, q, v));
    }).ElseIf(hi.equal(int$3(4)), () => {
      result.assign(vec3$2(t, p, v));
    }).Else(() => {
      result.assign(vec3$2(v, p, q));
    });
  });
  return result;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
const mx_rgbtohsv = /* @__PURE__ */ Fn$4(([c_immutable]) => {
  const c = vec3$2(c_immutable).toVar();
  const r = float$4(c.x).toVar();
  const g = float$4(c.y).toVar();
  const b = float$4(c.z).toVar();
  const mincomp = float$4(min$1$1(r, min$1$1(g, b))).toVar();
  const maxcomp = float$4(max$1$1(r, max$1$1(g, b))).toVar();
  const delta = float$4(maxcomp.sub(mincomp)).toVar();
  const h = float$4().toVar(), s = float$4().toVar(), v = float$4().toVar();
  v.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s.assign(delta.div(maxcomp));
  }).Else(() => {
    s.assign(0);
  });
  If(s.lessThanEqual(0), () => {
    h.assign(0);
  }).Else(() => {
    If(r.greaterThanEqual(maxcomp), () => {
      h.assign(g.sub(b).div(delta));
    }).ElseIf(g.greaterThanEqual(maxcomp), () => {
      h.assign(add$3(2, b.sub(r).div(delta)));
    }).Else(() => {
      h.assign(add$3(4, r.sub(g).div(delta)));
    });
    h.mulAssign(1 / 6);
    If(h.lessThan(0), () => {
      h.addAssign(1);
    });
  });
  return vec3$2(h, s, v);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});
const mx_srgb_texture_to_lin_rec709 = /* @__PURE__ */ Fn$4(([color_immutable]) => {
  const color2 = vec3$2(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color2, vec3$2(0.04045))).toVar();
  const linSeg = vec3$2(color2.div(12.92)).toVar();
  const powSeg = vec3$2(pow(max$1$1(color2.add(vec3$2(0.055)), vec3$2(0)).div(1.055), vec3$2(2.4))).toVar();
  return mix(linSeg, powSeg, isAbove);
}).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
const mx_aastep = (threshold, value) => {
  threshold = float$4(threshold);
  value = float$4(value);
  const afwidth = vec2$2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
};
const _ramp = (a, b, uv2, p) => mix(a, b, uv2[p].clamp());
const mx_ramplr = (valuel, valuer, texcoord = uv$1()) => _ramp(valuel, valuer, texcoord, "x");
const mx_ramptb = (valuet, valueb, texcoord = uv$1()) => _ramp(valuet, valueb, texcoord, "y");
const mx_ramp4 = (valuetl, valuetr, valuebl, valuebr, texcoord = uv$1()) => {
  const u = texcoord.x.clamp();
  const v = texcoord.y.clamp();
  const top = mix(valuetl, valuetr, u);
  const bottom = mix(valuebl, valuebr, u);
  return mix(top, bottom, v);
};
const _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, uv2[p]));
const mx_splitlr = (valuel, valuer, center, texcoord = uv$1()) => _split(valuel, valuer, center, texcoord, "x");
const mx_splittb = (valuet, valueb, center, texcoord = uv$1()) => _split(valuet, valueb, center, texcoord, "y");
const mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv$1()) => uv_geo.mul(uv_scale).add(uv_offset);
const mx_safepower = (in1, in2 = 1) => {
  in1 = float$4(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
const mx_contrast = (input, amount = 1, pivot = 0.5) => float$4(input).sub(pivot).mul(amount).add(pivot);
const mx_noise_float = (texcoord = uv$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
const mx_noise_vec3 = (texcoord = uv$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
const mx_noise_vec4 = (texcoord = uv$1(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4$3(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2$2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
const mx_unifiednoise2d = (noiseType, texcoord = uv$1(), freq = vec2$2(1, 1), offset = vec2$2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise2d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
const mx_unifiednoise3d = (noiseType, texcoord = uv$1(), freq = vec2$2(1, 1), offset = vec2$2(0, 0), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise3d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
const mx_worley_noise_float = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter, int$3(1));
const mx_worley_noise_vec2 = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter, int$3(1));
const mx_worley_noise_vec3 = (texcoord = uv$1(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter, int$3(1));
const mx_cell_noise_float = (texcoord = uv$1()) => mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
const mx_fractal_noise_float = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float$1(position, int$3(octaves), lacunarity, diminish).mul(amplitude);
const mx_fractal_noise_vec2 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int$3(octaves), lacunarity, diminish).mul(amplitude);
const mx_fractal_noise_vec3 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int$3(octaves), lacunarity, diminish).mul(amplitude);
const mx_fractal_noise_vec4 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int$3(octaves), lacunarity, diminish).mul(amplitude);
const mx_add = (in1, in2 = float$4(0)) => add$3(in1, in2);
const mx_subtract = (in1, in2 = float$4(0)) => sub$3(in1, in2);
const mx_multiply = (in1, in2 = float$4(1)) => mul$3(in1, in2);
const mx_divide = (in1, in2 = float$4(1)) => div$2(in1, in2);
const mx_modulo = (in1, in2 = float$4(1)) => mod(in1, in2);
const mx_power = (in1, in2 = float$4(1)) => pow(in1, in2);
const mx_atan2 = (in1 = float$4(0), in2 = float$4(1)) => atan(in1, in2);
const mx_timer = () => time;
const mx_frame = () => frameId;
const mx_invert = (in1, amount = float$4(1)) => sub$3(amount, in1);
const mx_ifgreater = (value1, value2, in1, in2) => value1.greaterThan(value2).mix(in1, in2);
const mx_ifgreatereq = (value1, value2, in1, in2) => value1.greaterThanEqual(value2).mix(in1, in2);
const mx_ifequal = (value1, value2, in1, in2) => value1.equal(value2).mix(in1, in2);
const mx_separate = (in1, channelOrOut = null) => {
  if (typeof channelOrOut === "string") {
    const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    const c = channelOrOut.replace(/^out/, "").toLowerCase();
    if (map[c] !== void 0) return in1.element(map[c]);
  }
  if (typeof channelOrOut === "number") {
    return in1.element(channelOrOut);
  }
  if (typeof channelOrOut === "string" && channelOrOut.length === 1) {
    const map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    if (map[channelOrOut] !== void 0) return in1.element(map[channelOrOut]);
  }
  return in1;
};
const mx_place2d = (texcoord, pivot = vec2$2(0.5, 0.5), scale = vec2$2(1, 1), rotate2 = float$4(0), offset = vec2$2(0, 0)) => {
  let uv2 = texcoord;
  if (pivot) uv2 = uv2.sub(pivot);
  if (scale) uv2 = uv2.mul(scale);
  if (rotate2) {
    const rad = rotate2.mul(Math.PI / 180);
    const cosR = rad.cos();
    const sinR = rad.sin();
    uv2 = vec2$2(
      uv2.x.mul(cosR).sub(uv2.y.mul(sinR)),
      uv2.x.mul(sinR).add(uv2.y.mul(cosR))
    );
  }
  if (pivot) uv2 = uv2.add(pivot);
  if (offset) uv2 = uv2.add(offset);
  return uv2;
};
const mx_rotate2d = (input, amount) => {
  input = vec2$2(input);
  amount = float$4(amount);
  const radians2 = amount.mul(Math.PI / 180);
  return rotate(input, radians2);
};
const mx_rotate3d = (input, amount, axis) => {
  input = vec3$2(input);
  amount = float$4(amount);
  axis = vec3$2(axis);
  const radians2 = amount.mul(Math.PI / 180);
  const nAxis = axis.normalize();
  const cosA = radians2.cos();
  const sinA = radians2.sin();
  const oneMinusCosA = float$4(1).sub(cosA);
  const rot = input.mul(cosA).add(nAxis.cross(input).mul(sinA)).add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
  return rot;
};
const mx_heighttonormal = (input, scale) => {
  input = vec3$2(input);
  scale = float$4(scale);
  return bumpMap(input, scale);
};
const getParallaxCorrectNormal = /* @__PURE__ */ Fn$4(([normal2, cubeSize, cubePos]) => {
  const nDir = normalize$1(normal2).toVar();
  const rbmax = sub$3(float$4(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbmin = sub$3(float$4(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbminmax = vec3$2().toVar();
  rbminmax.x = nDir.x.greaterThan(float$4(0)).select(rbmax.x, rbmin.x);
  rbminmax.y = nDir.y.greaterThan(float$4(0)).select(rbmax.y, rbmin.y);
  rbminmax.z = nDir.z.greaterThan(float$4(0)).select(rbmax.z, rbmin.z);
  const correction = min$1$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar();
  return boxIntersection.sub(cubePos);
});
const getShIrradianceAt = /* @__PURE__ */ Fn$4(([normal2, shCoefficients]) => {
  const x = normal2.x, y = normal2.y, z = normal2.z;
  let result = shCoefficients.element(0).mul(0.886227);
  result = result.add(shCoefficients.element(1).mul(2 * 0.511664).mul(y));
  result = result.add(shCoefficients.element(2).mul(2 * 0.511664).mul(z));
  result = result.add(shCoefficients.element(3).mul(2 * 0.511664).mul(x));
  result = result.add(shCoefficients.element(4).mul(2 * 0.429043).mul(x).mul(y));
  result = result.add(shCoefficients.element(5).mul(2 * 0.429043).mul(y).mul(z));
  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));
  result = result.add(shCoefficients.element(7).mul(2 * 0.429043).mul(x).mul(z));
  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul$3(x, x).sub(mul$3(y, y))));
  return result;
});
var TSL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BRDF_GGX,
  BRDF_Lambert,
  BasicPointShadowFilter,
  BasicShadowFilter,
  Break,
  Const,
  Continue,
  DFGLUT,
  D_GGX,
  Discard: Discard$1,
  EPSILON,
  F_Schlick,
  Fn: Fn$4,
  HALF_PI,
  INFINITY,
  If,
  Loop,
  NodeAccess,
  NodeShaderStage,
  NodeType,
  NodeUpdateType,
  OnBeforeMaterialUpdate,
  OnBeforeObjectUpdate,
  OnMaterialUpdate,
  OnObjectUpdate,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  PI: PI$1,
  PI2,
  PointShadowFilter,
  Return,
  Schlick_to_F0,
  ScriptableNodeResources,
  ShaderNode,
  Stack,
  Switch,
  TBNViewMatrix,
  TWO_PI,
  VSMShadowFilter,
  V_GGX_SmithCorrelated,
  Var,
  VarIntent,
  abs: abs$2,
  acesFilmicToneMapping,
  acos,
  add: add$3,
  addMethodChaining,
  addNodeElement,
  agxToneMapping,
  all,
  alphaT,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append,
  array,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  atomicAdd,
  atomicAnd,
  atomicFunc,
  atomicLoad,
  atomicMax,
  atomicMin,
  atomicOr,
  atomicStore,
  atomicSub,
  atomicXor,
  attenuationColor,
  attenuationDistance,
  attribute: attribute$1,
  attributeArray: attributeArray$2,
  backgroundBlurriness,
  backgroundIntensity,
  backgroundRotation,
  batch,
  bentNormalView,
  billboarding,
  bitAnd: bitAnd$1,
  bitNot,
  bitOr: bitOr$1,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  blendBurn,
  blendColor,
  blendDodge,
  blendOverlay,
  blendScreen,
  blur,
  bool,
  buffer,
  bufferAttribute,
  builtin,
  builtinAOContext,
  builtinShadowContext,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraIndex,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraViewport,
  cameraWorldMatrix,
  cbrt,
  cdl,
  ceil,
  checker,
  cineonToneMapping,
  clamp: clamp$1,
  clearcoat,
  clearcoatNormalView,
  clearcoatRoughness,
  code,
  color,
  colorSpaceToWorking,
  colorToDirection,
  compute,
  computeKernel,
  computeSkinning,
  context,
  convert,
  convertColorSpace,
  convertToTexture,
  cos: cos$1,
  countLeadingZeros,
  countOneBits,
  countTrailingZeros,
  cross: cross$1,
  cubeTexture,
  cubeTextureBase,
  dFdx,
  dFdy,
  dashSize,
  debug,
  decrement,
  decrementBefore,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees,
  deltaTime,
  densityFog,
  densityFogFactor,
  depth,
  depthPass,
  determinant,
  difference,
  diffuseColor,
  diffuseContribution,
  directPointLight,
  directionToColor,
  directionToFaceDirection,
  dispersion,
  disposeShadowMaterial,
  distance,
  div: div$2,
  dodge,
  dot: dot$3,
  drawIndex,
  dynamicBufferAttribute,
  element,
  emissive,
  equal,
  equals,
  equirectUV,
  exp: exp$2,
  exp2,
  expression,
  faceDirection,
  faceForward,
  faceforward,
  float: float$4,
  floatBitsToInt,
  floatBitsToUint,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  getConstNodeType,
  getCurrentStack: getCurrentStack$3,
  getDirection,
  getDistanceAttenuation,
  getGeometryRoughness,
  getNormalFromDepth,
  getParallaxCorrectNormal,
  getRoughness,
  getScreenPosition,
  getShIrradianceAt,
  getShadowMaterial,
  getShadowRenderObjectFunction,
  getTextureIndex,
  getViewPosition,
  ggxConvolution,
  globalId,
  glsl,
  glslFn,
  grayscale,
  greaterThan,
  greaterThanEqual,
  hash,
  highpModelNormalViewMatrix,
  highpModelViewMatrix,
  hue,
  increment,
  incrementBefore,
  inspector,
  instance,
  instanceIndex: instanceIndex$2,
  instancedArray,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  instancedMesh,
  int: int$3,
  intBitsToFloat,
  interleavedGradientNoise,
  inverse,
  inverseSqrt,
  inversesqrt,
  invocationLocalIndex,
  invocationSubgroupIndex,
  ior,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  isolate,
  ivec2: ivec2$2,
  ivec3: ivec3$3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightPosition,
  lightProjectionUV,
  lightShadowMatrix,
  lightTargetDirection,
  lightTargetPosition,
  lightViewPosition,
  lightingContext,
  lights,
  linearDepth,
  linearToneMapping,
  localId,
  log: log$1,
  log2,
  logarithmicDepthToViewZ,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAO,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialAttenuationColor,
  materialAttenuationDistance,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialEnvIntensity,
  materialEnvRotation,
  materialIOR,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLightMap,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointSize,
  materialReference,
  materialReflectivity,
  materialRefractionRatio,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularColor,
  materialSpecularIntensity,
  materialSpecularStrength,
  materialThickness,
  materialTransmission,
  max: max$1$1,
  maxMipLevel,
  mediumpModelViewMatrix,
  metalness,
  min: min$1$1,
  mix,
  mixElement,
  mod,
  modInt,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelRadius,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mrt,
  mul: mul$3,
  mx_aastep,
  mx_add,
  mx_atan2,
  mx_cell_noise_float,
  mx_contrast,
  mx_divide,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_frame,
  mx_heighttonormal,
  mx_hsvtorgb,
  mx_ifequal,
  mx_ifgreater,
  mx_ifgreatereq,
  mx_invert,
  mx_modulo,
  mx_multiply,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_place2d,
  mx_power,
  mx_ramp4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_rotate2d,
  mx_rotate3d,
  mx_safepower,
  mx_separate,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_subtract,
  mx_timer,
  mx_transform_uv,
  mx_unifiednoise2d,
  mx_unifiednoise3d,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3,
  negate,
  neutralToneMapping,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjectIntent,
  nodeObjects,
  nodeProxy,
  nodeProxyIntent,
  normalFlat,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalViewGeometry,
  normalWorld,
  normalWorldGeometry,
  normalize: normalize$1,
  not,
  notEqual,
  numWorkgroups,
  objectDirection,
  objectGroup,
  objectPosition,
  objectRadius,
  objectScale,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  packHalf2x16,
  packSnorm2x16,
  packUnorm2x16,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  passTexture,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointShadow,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal: positionLocal$1,
  positionPrevious,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  premultiplyAlpha,
  property,
  quadBroadcast,
  quadSwapDiagonal,
  quadSwapX,
  quadSwapY,
  radians,
  rand,
  range,
  rangeFog,
  rangeFogFactor,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  refractVector,
  refractView,
  reinhardToneMapping,
  remap,
  remapClamp,
  renderGroup,
  renderOutput,
  rendererReference,
  replaceDefaultUV,
  rotate,
  rotateUV,
  roughness,
  round,
  rtt,
  sRGBTransferEOTF,
  sRGBTransferOETF,
  sample,
  sampler,
  samplerComparison,
  saturate,
  saturation,
  screen,
  screenCoordinate,
  screenDPR,
  screenSize,
  screenUV,
  scriptable,
  scriptableValue,
  select: select$3,
  setCurrentStack: setCurrentStack$3,
  setName,
  shaderStages,
  shadow,
  shadowPositionWorld,
  shapeCircle,
  sharedUniformGroup,
  sheen,
  sheenRoughness,
  shiftLeft: shiftLeft$1,
  shiftRight: shiftRight$1,
  shininess,
  sign,
  sin: sin$1,
  sinc,
  skinning,
  smoothstep,
  smoothstepElement,
  specularColor,
  specularColorBlended,
  specularF90,
  spherizeUV,
  split,
  spritesheetUV,
  sqrt: sqrt$3,
  stack,
  step,
  stepElement,
  storage,
  storageBarrier,
  storageObject,
  storageTexture,
  string,
  struct,
  sub: sub$3,
  subBuild,
  subgroupAdd,
  subgroupAll,
  subgroupAnd,
  subgroupAny,
  subgroupBallot,
  subgroupBroadcast,
  subgroupBroadcastFirst,
  subgroupElect,
  subgroupExclusiveAdd,
  subgroupExclusiveMul,
  subgroupInclusiveAdd,
  subgroupInclusiveMul,
  subgroupIndex,
  subgroupMax,
  subgroupMin,
  subgroupMul,
  subgroupOr,
  subgroupShuffle,
  subgroupShuffleDown,
  subgroupShuffleUp,
  subgroupShuffleXor,
  subgroupSize,
  subgroupXor,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  texture: texture$2,
  texture3D,
  texture3DLevel,
  texture3DLoad,
  textureBarrier,
  textureBicubic,
  textureBicubicLevel,
  textureCubeUV,
  textureLevel,
  textureLoad: textureLoad$2,
  textureSize,
  textureStore,
  thickness,
  time,
  toneMapping,
  toneMappingExposure,
  toonOutlinePass,
  transformDirection,
  transformNormal,
  transformNormalToView,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transmission,
  transpose,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  uint: uint$3,
  uintBitsToFloat,
  uniform: uniform$2,
  uniformArray,
  uniformCubeTexture,
  uniformFlow,
  uniformGroup,
  uniformTexture,
  unpackHalf2x16: unpackHalf2x16$1,
  unpackNormal,
  unpackSnorm2x16,
  unpackUnorm2x16,
  unpremultiplyAlpha,
  userData,
  uv: uv$1,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty: varyingProperty$1,
  vec2: vec2$2,
  vec3: vec3$2,
  vec4: vec4$3,
  vectorComponents,
  velocity,
  vertexColor,
  vertexIndex,
  vertexStage,
  vibrance,
  viewZToLogarithmicDepth,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportCoordinate,
  viewportDepthTexture,
  viewportLinearDepth,
  viewportMipTexture,
  viewportResolution,
  viewportSafeUV,
  viewportSharedTexture,
  viewportSize,
  viewportTexture,
  viewportUV,
  vogelDiskSample,
  wgsl,
  wgslFn,
  workgroupArray,
  workgroupBarrier,
  workgroupId,
  workingToColorSpace,
  xor
});
({
  bitcast_int_uint: new CodeNode(
    /* glsl */
    "uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }"
  ),
  bitcast_uint_int: new CodeNode(
    /* glsl */
    "uint tsl_bitcast_uint_to_int ( uint x ) { return floatBitsToInt( uintBitsToFloat ( x ) ); }"
  )
});
const GPUShaderStage = typeof self !== "undefined" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
({
  [NodeAccess.READ_ONLY]: "read",
  [NodeAccess.WRITE_ONLY]: "write",
  [NodeAccess.READ_WRITE]: "read_write"
});
({
  "vertex": GPUShaderStage.VERTEX,
  "fragment": GPUShaderStage.FRAGMENT,
  "compute": GPUShaderStage.COMPUTE
});
({
  tsl_xor: new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new CodeNode(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
});
const typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
if (typeof Float16Array !== "undefined") {
  typedArraysToVertexFormatPrefix.set(Float16Array, ["float16"]);
}
const SPLAT_TEX_WIDTH_BITS = 11;
const SPLAT_TEX_HEIGHT_BITS = 11;
const SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;
const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;
const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;
const SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;
const SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1;
const PI = 3.14159265359;
const DEFAULT_MAX_SPLATS = 1024 * 1024;
const QUAD_INDICES = [0, 1, 2, 0, 2, 3];
const {
  Fn: Fn$3,
  abs: abs$1,
  add: add$2,
  bitAnd,
  bitOr,
  clamp,
  cos,
  cross,
  div: div$1,
  dot: dot$2,
  exp: exp$1,
  float: float$3,
  int: int$2,
  ivec3: ivec3$2,
  log,
  max: max$1,
  min: min$1,
  mul: mul$2,
  normalize,
  select: select$2,
  shiftLeft,
  shiftRight,
  sin,
  sqrt: sqrt$2,
  sub: sub$2,
  uint: uint$2,
  unpackHalf2x16,
  vec2: vec2$1,
  vec3: vec3$1,
  vec4: vec4$2
} = TSL;
Fn$3(([index]) => {
  const x = bitAnd(index, uint$2(SPLAT_TEX_WIDTH_MASK));
  const y = bitAnd(
    shiftRight(index, uint$2(SPLAT_TEX_WIDTH_BITS)),
    uint$2(SPLAT_TEX_HEIGHT_MASK)
  );
  const z = shiftRight(index, uint$2(SPLAT_TEX_LAYER_BITS));
  return ivec3$2(int$2(x), int$2(y), int$2(z));
});
const quatVec = Fn$3(([q, v]) => {
  const qxyz = q.xyz;
  const t = mul$2(float$3(2), cross(qxyz, v));
  return add$2(v, add$2(mul$2(q.w, t), cross(qxyz, t)));
});
const quatQuat = Fn$3(([q12, q2]) => {
  return vec4$2(
    add$2(
      add$2(add$2(mul$2(q12.w, q2.x), mul$2(q12.x, q2.w)), mul$2(q12.y, q2.z)),
      mul$2(float$3(-1), mul$2(q12.z, q2.y))
    ),
    add$2(
      add$2(sub$2(mul$2(q12.w, q2.y), mul$2(q12.x, q2.z)), mul$2(q12.y, q2.w)),
      mul$2(q12.z, q2.x)
    ),
    add$2(
      sub$2(add$2(mul$2(q12.w, q2.z), mul$2(q12.x, q2.y)), mul$2(q12.y, q2.x)),
      mul$2(q12.z, q2.w)
    ),
    sub$2(
      sub$2(sub$2(mul$2(q12.w, q2.w), mul$2(q12.x, q2.x)), mul$2(q12.y, q2.y)),
      mul$2(q12.z, q2.z)
    )
  );
});
const decodeQuatOctXy88R8 = Fn$3(([encoded]) => {
  const quantU = bitAnd(encoded, uint$2(255));
  const quantV = bitAnd(shiftRight(encoded, uint$2(8)), uint$2(255));
  const angleInt = shiftRight(encoded, uint$2(16));
  const u_f = div$1(float$3(quantU), float$3(255));
  const v_f = div$1(float$3(quantV), float$3(255));
  const fx = sub$2(mul$2(u_f, float$3(2)), float$3(1));
  const fy = sub$2(mul$2(v_f, float$3(2)), float$3(1));
  const axisZ = sub$2(sub$2(float$3(1), abs$1(fx)), abs$1(fy));
  const t = max$1(mul$2(float$3(-1), axisZ), float$3(0));
  const axisX = add$2(
    fx,
    select$2(fx.greaterThanEqual(float$3(0)), mul$2(float$3(-1), t), t)
  );
  const axisY = add$2(
    fy,
    select$2(fy.greaterThanEqual(float$3(0)), mul$2(float$3(-1), t), t)
  );
  const axis = normalize(vec3$1(axisX, axisY, axisZ));
  const theta = mul$2(div$1(float$3(angleInt), float$3(255)), float$3(PI));
  const halfTheta = mul$2(theta, float$3(0.5));
  const s = sin(halfTheta);
  const w = cos(halfTheta);
  return vec4$2(mul$2(axis, s), w);
});
function unpackSplatEncoding(packed, rgbMinMaxLnScaleMinMax) {
  const word0 = packed.x;
  const word1 = packed.y;
  const word2 = packed.z;
  const word3 = packed.w;
  const uR = bitAnd(word0, uint$2(255));
  const uG = bitAnd(shiftRight(word0, uint$2(8)), uint$2(255));
  const uB = bitAnd(shiftRight(word0, uint$2(16)), uint$2(255));
  const uA = shiftRight(word0, uint$2(24));
  const rgbMin = rgbMinMaxLnScaleMinMax.x;
  const rgbMax = rgbMinMaxLnScaleMinMax.y;
  const r = add$2(mul$2(div$1(float$3(uR), float$3(255)), sub$2(rgbMax, rgbMin)), rgbMin);
  const g = add$2(mul$2(div$1(float$3(uG), float$3(255)), sub$2(rgbMax, rgbMin)), rgbMin);
  const b = add$2(mul$2(div$1(float$3(uB), float$3(255)), sub$2(rgbMax, rgbMin)), rgbMin);
  const a = div$1(float$3(uA), float$3(255));
  const rgba = vec4$2(r, g, b, a);
  const centerXY = unpackHalf2x16(word1);
  const centerZPart = unpackHalf2x16(bitAnd(word2, uint$2(65535)));
  const centerZ = float$3(centerZPart.x);
  const center = vec3$1(centerXY, centerZ);
  const uScaleX = bitAnd(word3, uint$2(255));
  const uScaleY = bitAnd(shiftRight(word3, uint$2(8)), uint$2(255));
  const uScaleZ = bitAnd(shiftRight(word3, uint$2(16)), uint$2(255));
  const lnScaleMin = rgbMinMaxLnScaleMinMax.z;
  const lnScaleMax = rgbMinMaxLnScaleMinMax.w;
  const lnScaleScale = div$1(sub$2(lnScaleMax, lnScaleMin), float$3(254));
  const decodeScale = (uScale) => {
    const isZero = uScale.equal(uint$2(0));
    const decoded = exp$1(
      add$2(lnScaleMin, mul$2(sub$2(float$3(uScale), float$3(1)), lnScaleScale))
    );
    return select$2(isZero, float$3(0), decoded);
  };
  const scales = vec3$1(
    decodeScale(uScaleX),
    decodeScale(uScaleY),
    decodeScale(uScaleZ)
  );
  const quatLower = bitAnd(shiftRight(word2, uint$2(16)), uint$2(65535));
  const quatUpper = bitAnd(shiftRight(word3, uint$2(8)), uint$2(16711680));
  const uQuat = bitOr(quatLower, quatUpper);
  const quaternion = decodeQuatOctXy88R8(uQuat);
  return { center, scales, quaternion, rgba };
}
function scaleQuaternionToMatrix(s, q) {
  const qx = q.x;
  const qy = q.y;
  const qz = q.z;
  const qw = q.w;
  const m00 = mul$2(
    s.x,
    sub$2(float$3(1), mul$2(float$3(2), add$2(mul$2(qy, qy), mul$2(qz, qz))))
  );
  const m01 = mul$2(s.x, mul$2(float$3(2), add$2(mul$2(qx, qy), mul$2(qw, qz))));
  const m02 = mul$2(s.x, mul$2(float$3(2), sub$2(mul$2(qx, qz), mul$2(qw, qy))));
  const m10 = mul$2(s.y, mul$2(float$3(2), sub$2(mul$2(qx, qy), mul$2(qw, qz))));
  const m11 = mul$2(
    s.y,
    sub$2(float$3(1), mul$2(float$3(2), add$2(mul$2(qx, qx), mul$2(qz, qz))))
  );
  const m12 = mul$2(s.y, mul$2(float$3(2), add$2(mul$2(qy, qz), mul$2(qw, qx))));
  const m20 = mul$2(s.z, mul$2(float$3(2), add$2(mul$2(qx, qz), mul$2(qw, qy))));
  const m21 = mul$2(s.z, mul$2(float$3(2), sub$2(mul$2(qy, qz), mul$2(qw, qx))));
  const m22 = mul$2(
    s.z,
    sub$2(float$3(1), mul$2(float$3(2), add$2(mul$2(qx, qx), mul$2(qy, qy))))
  );
  return { m00, m01, m02, m10, m11, m12, m20, m21, m22 };
}
function computeCov3D(RS) {
  const c00 = add$2(
    add$2(mul$2(RS.m00, RS.m00), mul$2(RS.m10, RS.m10)),
    mul$2(RS.m20, RS.m20)
  );
  const c01 = add$2(
    add$2(mul$2(RS.m00, RS.m01), mul$2(RS.m10, RS.m11)),
    mul$2(RS.m20, RS.m21)
  );
  const c02 = add$2(
    add$2(mul$2(RS.m00, RS.m02), mul$2(RS.m10, RS.m12)),
    mul$2(RS.m20, RS.m22)
  );
  const c11 = add$2(
    add$2(mul$2(RS.m01, RS.m01), mul$2(RS.m11, RS.m11)),
    mul$2(RS.m21, RS.m21)
  );
  const c12 = add$2(
    add$2(mul$2(RS.m01, RS.m02), mul$2(RS.m11, RS.m12)),
    mul$2(RS.m21, RS.m22)
  );
  const c22 = add$2(
    add$2(mul$2(RS.m02, RS.m02), mul$2(RS.m12, RS.m12)),
    mul$2(RS.m22, RS.m22)
  );
  return { c00, c01, c02, c11, c12, c22 };
}
function projectCov3DTo2D(viewCenter, cov3D, focal, isOrthographic) {
  const invZ = div$1(float$3(1), viewCenter.z);
  const invZ2 = mul$2(invZ, invZ);
  const J00 = mul$2(focal.x, invZ);
  const J02 = mul$2(mul$2(float$3(-1), focal.x), mul$2(viewCenter.x, invZ2));
  const J11 = mul$2(focal.y, invZ);
  const J12 = mul$2(mul$2(float$3(-1), focal.y), mul$2(viewCenter.y, invZ2));
  const a = add$2(
    add$2(
      mul$2(mul$2(J00, J00), cov3D.c00),
      mul$2(mul$2(float$3(2), mul$2(J00, J02)), cov3D.c02)
    ),
    mul$2(mul$2(J02, J02), cov3D.c22)
  );
  const b = add$2(
    add$2(
      add$2(mul$2(mul$2(J00, J11), cov3D.c01), mul$2(mul$2(J00, J12), cov3D.c02)),
      mul$2(mul$2(J02, J11), cov3D.c12)
    ),
    mul$2(mul$2(J02, J12), cov3D.c22)
  );
  const d = add$2(
    add$2(
      mul$2(mul$2(J11, J11), cov3D.c11),
      mul$2(mul$2(float$3(2), mul$2(J11, J12)), cov3D.c12)
    ),
    mul$2(mul$2(J12, J12), cov3D.c22)
  );
  return { a, b, d };
}
function eigenDecompose2x2(a, b, d) {
  const eigenAvg = mul$2(float$3(0.5), add$2(a, d));
  const det2 = sub$2(mul$2(a, d), mul$2(b, b));
  const eigenDelta = sqrt$2(max$1(float$3(0), sub$2(mul$2(eigenAvg, eigenAvg), det2)));
  const eigen1 = add$2(eigenAvg, eigenDelta);
  const eigen2 = sub$2(eigenAvg, eigenDelta);
  const bSmall = abs$1(b).lessThan(float$3(1e-3));
  const evx = select$2(bSmall, float$3(1), b);
  const evy = select$2(bSmall, float$3(0), sub$2(eigen1, a));
  const eigenVec1 = normalize(vec2$1(evx, evy));
  const eigenVec2 = vec2$1(eigenVec1.y, mul$2(float$3(-1), eigenVec1.x));
  return { eigen1, eigen2, eigenVec1, eigenVec2 };
}
const {
  Fn: Fn$2,
  abs,
  add: add$1,
  attributeArray: attributeArray$1,
  div,
  float: float$2,
  getCurrentStack: getCurrentStack$2,
  setCurrentStack: setCurrentStack$2,
  instanceIndex: instanceIndex$1,
  int: int$1,
  ivec2: ivec2$1,
  ivec3: ivec3$1,
  max,
  min,
  mul: mul$1,
  select: select$1,
  sqrt: sqrt$1,
  sub: sub$1,
  texture: texture$1,
  textureLoad: textureLoad$1,
  uint: uint$1,
  uniform: uniform$1,
  vec2,
  vec3,
  vec4: vec4$1
} = TSL;
class RenderComputePass {
  constructor(renderer, maxSplats = DEFAULT_MAX_SPLATS, sortedIndicesStorage = null) {
    this.renderer = renderer;
    this.maxSplats = maxSplats;
    const vertexCount = maxSplats * 4;
    this.positionBuffer = attributeArray$1(vertexCount, "vec3");
    this.colorBuffer = attributeArray$1(vertexCount, "vec4");
    this.uvBuffer = attributeArray$1(vertexCount, "vec2");
    this.geometry = new THREE.BufferGeometry();
    this.geometry.setAttribute("position", this.positionBuffer.value);
    this.geometry.setAttribute("color", this.colorBuffer.value);
    this.geometry.setAttribute("uv", this.uvBuffer.value);
    const indices = new Uint32Array(maxSplats * 6);
    for (let i = 0; i < maxSplats; i++) {
      const vi = i * 4;
      const ii = i * 6;
      indices[ii + 0] = vi + QUAD_INDICES[0];
      indices[ii + 1] = vi + QUAD_INDICES[1];
      indices[ii + 2] = vi + QUAD_INDICES[2];
      indices[ii + 3] = vi + QUAD_INDICES[3];
      indices[ii + 4] = vi + QUAD_INDICES[4];
      indices[ii + 5] = vi + QUAD_INDICES[5];
    }
    this.geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    this.geometry.setDrawRange(0, 0);
    this.uniforms = {
      numSplats: uniform$1(0),
      renderToViewQuat: uniform$1(new THREE.Vector4(0, 0, 0, 1)),
      renderToViewPos: uniform$1(new THREE.Vector3(0, 0, 0)),
      projMatrix: uniform$1(new THREE.Matrix4()),
      renderSize: uniform$1(new THREE.Vector2(1, 1)),
      rgbMinMaxLnScaleMinMax: uniform$1(new THREE.Vector4(0, 1, -12, 9)),
      maxStdDev: uniform$1(3),
      minAlpha: uniform$1(1 / 255),
      minPixelRadius: uniform$1(0),
      maxPixelRadius: uniform$1(2048),
      clipXY: uniform$1(1.2),
      focalAdjustment: uniform$1(1),
      blurAmount: uniform$1(0.3),
      preBlurAmount: uniform$1(0),
      isOrthographic: uniform$1(0)
    };
    const placeholderTexture = new THREE.DataArrayTexture(
      new Uint32Array(4),
      1,
      1,
      1
    );
    placeholderTexture.format = THREE.RGBAIntegerFormat;
    placeholderTexture.type = THREE.UnsignedIntType;
    placeholderTexture.internalFormat = "RGBA32UI";
    placeholderTexture.needsUpdate = true;
    this.packedSplatsTextureUniform = texture$1(placeholderTexture);
    this.computeNode = this.buildComputeNode(sortedIndicesStorage);
  }
  /**
   * Build the compute shader node (called once in constructor).
   */
  buildComputeNode(sortedIndicesStorage) {
    const posBuffer = this.positionBuffer;
    const colBuffer = this.colorBuffer;
    const uvBuf = this.uvBuffer;
    const uniforms = this.uniforms;
    const packedSplatsTexture = this.packedSplatsTextureUniform;
    const useSorted = sortedIndicesStorage !== null;
    return Fn$2((builder) => {
      var _a2;
      if (getCurrentStack$2() === null && ((_a2 = builder == null ? void 0 : builder.stack) == null ? void 0 : _a2.isStackNode)) {
        setCurrentStack$2(builder.stack);
      }
      const splatIdx = instanceIndex$1;
      const degeneratePos = vec3(0, 0, 2);
      const degenerateColor = vec4$1(0, 0, 0, 0);
      const degenerateUv = vec2(0, 0);
      const withinRange = splatIdx.lessThan(uniforms.numSplats);
      const actualIdx = useSorted && sortedIndicesStorage ? sortedIndicesStorage.element(splatIdx) : splatIdx;
      const ix = int$1(uint$1(actualIdx).bitAnd(uint$1(SPLAT_TEX_WIDTH_MASK)));
      const iy = int$1(
        uint$1(actualIdx).shiftRight(uint$1(SPLAT_TEX_WIDTH_BITS)).bitAnd(uint$1(SPLAT_TEX_HEIGHT_MASK))
      );
      const iz = int$1(uint$1(actualIdx).shiftRight(uint$1(SPLAT_TEX_LAYER_BITS)));
      const packed = textureLoad$1(packedSplatsTexture, ivec2$1(ix, iy)).depth(iz);
      const { center, scales, quaternion, rgba } = unpackSplatEncoding(
        packed,
        uniforms.rgbMinMaxLnScaleMinMax
      );
      const alphaValid = rgba.w.greaterThanEqual(uniforms.minAlpha);
      const hasNonZeroScale = scales.x.greaterThan(float$2(0)).or(scales.y.greaterThan(float$2(0))).or(scales.z.greaterThan(float$2(0)));
      const viewQuat = vec4$1(
        uniforms.renderToViewQuat.x,
        uniforms.renderToViewQuat.y,
        uniforms.renderToViewQuat.z,
        uniforms.renderToViewQuat.w
      );
      const viewPos = vec3(
        uniforms.renderToViewPos.x,
        uniforms.renderToViewPos.y,
        uniforms.renderToViewPos.z
      );
      const viewCenter = add$1(quatVec(viewQuat, center), viewPos);
      const inFrontOfCamera = viewCenter.z.lessThan(float$2(0));
      const clipCenter = uniforms.projMatrix.mul(vec4$1(viewCenter, float$2(1)));
      const withinDepthRange = abs(clipCenter.z).lessThan(clipCenter.w);
      const clipLimit = mul$1(uniforms.clipXY, clipCenter.w);
      const withinXYFrustum = abs(clipCenter.x).lessThanEqual(clipLimit).and(abs(clipCenter.y).lessThanEqual(clipLimit));
      const safeW = select$1(
        clipCenter.w.equal(float$2(0)),
        float$2(1),
        clipCenter.w
      );
      const ndcCenter = div(clipCenter.xyz, safeW);
      const viewQuaternion = quatQuat(viewQuat, quaternion);
      const RS = scaleQuaternionToMatrix(scales, viewQuaternion);
      const cov3D = computeCov3D(RS);
      const scaledRenderSize = mul$1(
        uniforms.renderSize,
        uniforms.focalAdjustment
      );
      const fx = mul$1(
        mul$1(float$2(0.5), scaledRenderSize.x),
        uniforms.projMatrix.element(0).element(0)
      );
      const fy = mul$1(
        mul$1(float$2(0.5), scaledRenderSize.y),
        uniforms.projMatrix.element(1).element(1)
      );
      const focal = vec2(fx, fy);
      const cov2D = projectCov3DTo2D(viewCenter, cov3D, focal);
      const a = add$1(cov2D.a, uniforms.preBlurAmount);
      const b = cov2D.b;
      const d = add$1(cov2D.d, uniforms.preBlurAmount);
      const detOrig = sub$1(mul$1(a, d), mul$1(b, b));
      const aBlur = add$1(a, uniforms.blurAmount);
      const dBlur = add$1(d, uniforms.blurAmount);
      const det2 = sub$1(mul$1(aBlur, dBlur), mul$1(b, b));
      const safeDet = max(float$2(1e-10), det2);
      const blurAdjust = sqrt$1(max(float$2(0), div(detOrig, safeDet)));
      const finalAlpha = mul$1(rgba.w, blurAdjust);
      const finalAlphaValid = finalAlpha.greaterThanEqual(uniforms.minAlpha);
      const { eigen1, eigen2, eigenVec1, eigenVec2 } = eigenDecompose2x2(
        aBlur,
        b,
        dBlur
      );
      const scale1 = min(
        uniforms.maxPixelRadius,
        mul$1(uniforms.maxStdDev, sqrt$1(max(float$2(0), eigen1)))
      );
      const scale2 = min(
        uniforms.maxPixelRadius,
        mul$1(uniforms.maxStdDev, sqrt$1(max(float$2(0), eigen2)))
      );
      const hasMinRadius = scale1.greaterThanEqual(uniforms.minPixelRadius).or(scale2.greaterThanEqual(uniforms.minPixelRadius));
      const isValid = withinRange.and(alphaValid).and(hasNonZeroScale).and(inFrontOfCamera).and(withinDepthRange).and(withinXYFrustum).and(finalAlphaValid).and(hasMinRadius);
      const finalRgba = vec4$1(rgba.xyz, finalAlpha);
      const baseVertex = mul$1(splatIdx, uint$1(4));
      const invRenderSize = div(float$2(2), scaledRenderSize);
      const computeCornerPos = (cornerX, cornerY) => {
        const pixelOffset = add$1(
          mul$1(mul$1(cornerX, eigenVec1), scale1),
          mul$1(mul$1(cornerY, eigenVec2), scale2)
        );
        const ndcOffset = mul$1(invRenderSize, pixelOffset);
        return vec3(add$1(ndcCenter.xy, ndcOffset), ndcCenter.z);
      };
      const corner0 = vec2(float$2(-1), float$2(-1));
      const pos0 = computeCornerPos(corner0.x, corner0.y);
      const uv0 = mul$1(corner0, uniforms.maxStdDev);
      const vertexIdx0 = add$1(baseVertex, uint$1(0));
      posBuffer.element(vertexIdx0).assign(select$1(isValid, pos0, degeneratePos));
      colBuffer.element(vertexIdx0).assign(select$1(isValid, finalRgba, degenerateColor));
      uvBuf.element(vertexIdx0).assign(select$1(isValid, uv0, degenerateUv));
      const corner1 = vec2(float$2(1), float$2(-1));
      const pos1 = computeCornerPos(corner1.x, corner1.y);
      const uv1 = mul$1(corner1, uniforms.maxStdDev);
      const vertexIdx1 = add$1(baseVertex, uint$1(1));
      posBuffer.element(vertexIdx1).assign(select$1(isValid, pos1, degeneratePos));
      colBuffer.element(vertexIdx1).assign(select$1(isValid, finalRgba, degenerateColor));
      uvBuf.element(vertexIdx1).assign(select$1(isValid, uv1, degenerateUv));
      const corner2 = vec2(float$2(1), float$2(1));
      const pos2 = computeCornerPos(corner2.x, corner2.y);
      const uv2 = mul$1(corner2, uniforms.maxStdDev);
      const vertexIdx2 = add$1(baseVertex, uint$1(2));
      posBuffer.element(vertexIdx2).assign(select$1(isValid, pos2, degeneratePos));
      colBuffer.element(vertexIdx2).assign(select$1(isValid, finalRgba, degenerateColor));
      uvBuf.element(vertexIdx2).assign(select$1(isValid, uv2, degenerateUv));
      const corner3 = vec2(float$2(-1), float$2(1));
      const pos3 = computeCornerPos(corner3.x, corner3.y);
      const uv3 = mul$1(corner3, uniforms.maxStdDev);
      const vertexIdx3 = add$1(baseVertex, uint$1(3));
      posBuffer.element(vertexIdx3).assign(select$1(isValid, pos3, degeneratePos));
      colBuffer.element(vertexIdx3).assign(select$1(isValid, finalRgba, degenerateColor));
      uvBuf.element(vertexIdx3).assign(select$1(isValid, uv3, degenerateUv));
    })().compute(this.maxSplats);
  }
  /**
   * Update uniforms and run the compute shader.
   */
  async update(params) {
    this.uniforms.numSplats.value = params.numSplats;
    this.uniforms.renderToViewQuat.value.set(
      params.renderToViewQuat.x,
      params.renderToViewQuat.y,
      params.renderToViewQuat.z,
      params.renderToViewQuat.w
    );
    this.uniforms.renderToViewPos.value.copy(params.renderToViewPos);
    this.uniforms.projMatrix.value.copy(params.projectionMatrix);
    this.uniforms.renderSize.value.copy(params.renderSize);
    this.uniforms.rgbMinMaxLnScaleMinMax.value.copy(
      params.rgbMinMaxLnScaleMinMax
    );
    this.uniforms.maxStdDev.value = params.maxStdDev;
    this.uniforms.minAlpha.value = params.minAlpha;
    this.uniforms.minPixelRadius.value = params.minPixelRadius;
    this.uniforms.maxPixelRadius.value = params.maxPixelRadius;
    this.uniforms.clipXY.value = params.clipXY;
    this.uniforms.focalAdjustment.value = params.focalAdjustment;
    this.uniforms.blurAmount.value = params.blurAmount;
    this.uniforms.preBlurAmount.value = params.preBlurAmount;
    this.uniforms.isOrthographic.value = params.isOrthographic ? 1 : 0;
    if (this.packedSplatsTextureUniform.value !== params.packedSplatsTexture) {
      this.packedSplatsTextureUniform.value = params.packedSplatsTexture;
    }
    await this.renderer.computeAsync(this.computeNode);
    this.geometry.setDrawRange(0, params.numSplats * 6);
  }
  /**
   * Dispose of GPU resources.
   */
  dispose() {
    this.geometry.dispose();
  }
}
const {
  Fn: Fn$1,
  add,
  attributeArray,
  dot: dot$1,
  float: float$1,
  getCurrentStack: getCurrentStack$1,
  setCurrentStack: setCurrentStack$1,
  instanceIndex,
  int,
  ivec2,
  ivec3,
  select,
  sqrt,
  sub,
  texture,
  textureLoad,
  uint,
  uniform
} = TSL;
class SortComputePass {
  constructor(renderer, maxSplats = DEFAULT_MAX_SPLATS) {
    this.renderer = renderer;
    this.maxSplats = maxSplats;
    this.distanceBuffer = attributeArray(maxSplats, "float");
    this.sortedIndicesBuffer = attributeArray(maxSplats, "uint");
    this.indicesArray = new Uint32Array(maxSplats);
    for (let i = 0; i < maxSplats; i++) {
      this.indicesArray[i] = i;
    }
    this.uniforms = {
      numSplats: uniform(0),
      viewOrigin: uniform(new THREE.Vector3(0, 0, 0)),
      viewDirection: uniform(new THREE.Vector3(0, 0, -1)),
      rgbMinMaxLnScaleMinMax: uniform(new THREE.Vector4(0, 1, -12, 9)),
      sortRadial: uniform(1),
      // 1 = radial, 0 = depth
      depthBias: uniform(1)
    };
    const placeholderTexture = new THREE.DataArrayTexture(
      new Uint32Array(4),
      1,
      1,
      1
    );
    placeholderTexture.format = THREE.RGBAIntegerFormat;
    placeholderTexture.type = THREE.UnsignedIntType;
    placeholderTexture.internalFormat = "RGBA32UI";
    placeholderTexture.needsUpdate = true;
    this.packedSplatsTextureUniform = texture(placeholderTexture);
    this.distanceComputeNode = this.buildDistanceComputeNode();
  }
  /**
   * Build the distance computation shader (called once in constructor).
   */
  buildDistanceComputeNode() {
    const distBuffer = this.distanceBuffer;
    const uniforms = this.uniforms;
    const packedSplatsTexture = this.packedSplatsTextureUniform;
    return Fn$1((builder) => {
      var _a2;
      if (getCurrentStack$1() === null && ((_a2 = builder == null ? void 0 : builder.stack) == null ? void 0 : _a2.isStackNode)) {
        setCurrentStack$1(builder.stack);
      }
      const splatIdx = instanceIndex;
      const isValid = splatIdx.lessThan(uniforms.numSplats);
      const ix = int(uint(splatIdx).bitAnd(uint(SPLAT_TEX_WIDTH_MASK)));
      const iy = int(
        uint(splatIdx).shiftRight(uint(SPLAT_TEX_WIDTH_BITS)).bitAnd(uint(SPLAT_TEX_HEIGHT_MASK))
      );
      const iz = int(uint(splatIdx).shiftRight(uint(SPLAT_TEX_LAYER_BITS)));
      const packed = textureLoad(packedSplatsTexture, ivec2(ix, iy)).depth(iz);
      const { center } = unpackSplatEncoding(
        packed,
        uniforms.rgbMinMaxLnScaleMinMax
      );
      const toSplat = sub(center, uniforms.viewOrigin);
      const radialDist = sqrt(dot$1(toSplat, toSplat));
      const depthDist = add(
        dot$1(toSplat, uniforms.viewDirection),
        uniforms.depthBias
      );
      const computedDistance = select(
        uniforms.sortRadial.equal(int(1)),
        radialDist,
        depthDist
      );
      const finalDistance = select(isValid, computedDistance, float$1(1e30));
      distBuffer.element(splatIdx).assign(finalDistance);
    })().compute(this.maxSplats);
  }
  /**
   * Sort splats and return sorted indices storage.
   */
  async sort(params) {
    const { numSplats } = params;
    if (numSplats === 0) {
      return;
    }
    this.uniforms.numSplats.value = numSplats;
    this.uniforms.viewOrigin.value.copy(params.viewOrigin);
    this.uniforms.viewDirection.value.copy(params.viewDirection);
    this.uniforms.rgbMinMaxLnScaleMinMax.value.copy(
      params.rgbMinMaxLnScaleMinMax
    );
    this.uniforms.sortRadial.value = params.sortRadial ? 1 : 0;
    this.uniforms.depthBias.value = params.depthBias;
    if (this.packedSplatsTextureUniform.value !== params.packedSplatsTexture) {
      this.packedSplatsTextureUniform.value = params.packedSplatsTexture;
    }
    await this.renderer.computeAsync(this.distanceComputeNode);
    const distanceAttr = this.distanceBuffer.value;
    let distArray;
    try {
      const buffer2 = await this.renderer.getArrayBufferAsync(distanceAttr);
      distArray = new Float32Array(buffer2);
    } catch (e) {
      return;
    }
    for (let i = 0; i < numSplats; i++) {
      this.indicesArray[i] = i;
    }
    const indices = this.indicesArray;
    const distances = distArray;
    if (numSplats < 1e3) {
      for (let i = 1; i < numSplats; i++) {
        const idx = indices[i];
        const dist = distances[idx];
        let j = i - 1;
        while (j >= 0 && distances[indices[j]] < dist) {
          indices[j + 1] = indices[j];
          j--;
        }
        indices[j + 1] = idx;
      }
    } else {
      const indexArray = Array.from(indices.subarray(0, numSplats));
      indexArray.sort((a, b) => distances[b] - distances[a]);
      for (let i = 0; i < numSplats; i++) {
        indices[i] = indexArray[i];
      }
    }
    const sortedAttr = this.sortedIndicesBuffer.value;
    const sortedArray = sortedAttr.array;
    sortedArray.set(indices.subarray(0, numSplats));
    sortedAttr.needsUpdate = true;
  }
  /**
   * Get the sorted indices storage node for use in render pass.
   */
  getSortedIndicesStorage() {
    return this.sortedIndicesBuffer;
  }
  /**
   * Dispose of GPU resources.
   */
  dispose() {
  }
}
const {
  Discard,
  Fn,
  attribute,
  dot,
  exp,
  float,
  getCurrentStack,
  setCurrentStack,
  mul,
  positionLocal,
  varyingProperty,
  vec4
} = TSL;
function createWebGPUSplatMaterial(options = {}) {
  const {
    falloff = 1,
    minAlpha = 1 / 255,
    premultipliedAlpha = true,
    stochastic = false,
    disableFalloff = false
  } = options;
  const material = new NodeMaterial();
  material.transparent = true;
  material.depthTest = true;
  material.depthWrite = stochastic;
  material.side = THREE.DoubleSide;
  const vColor = varyingProperty("vec4", "vColor");
  const vUv = varyingProperty("vec2", "vUv");
  material.positionNode = Fn((builder) => {
    var _a2;
    if (getCurrentStack() === null && ((_a2 = builder == null ? void 0 : builder.stack) == null ? void 0 : _a2.isStackNode)) {
      setCurrentStack(builder.stack);
    }
    const colorAttr = attribute("color");
    const uvAttr = attribute("uv");
    vColor.assign(colorAttr);
    vUv.assign(uvAttr);
    return positionLocal;
  })();
  material.colorNode = Fn(() => {
    const uv2 = vUv;
    const color2 = vColor;
    const distSq = dot(uv2, uv2);
    let alpha;
    if (disableFalloff) {
      alpha = color2.w;
    } else {
      const gaussian = exp(mul(float(-0.5), mul(distSq, float(falloff))));
      alpha = mul(color2.w, gaussian);
    }
    Discard(alpha.lessThan(float(minAlpha)));
    if (premultipliedAlpha) {
      return vec4(mul(color2.xyz, alpha), alpha);
    } else {
      return vec4(color2.xyz, alpha);
    }
  })();
  if (premultipliedAlpha) {
    material.blending = THREE.CustomBlending;
    material.blendSrc = THREE.OneFactor;
    material.blendDst = THREE.OneMinusSrcAlphaFactor;
    material.blendSrcAlpha = THREE.OneFactor;
    material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
  } else {
    material.blending = THREE.NormalBlending;
  }
  return material;
}
function createDebugSplatMaterial() {
  const material = new NodeMaterial();
  material.transparent = true;
  material.depthTest = true;
  material.depthWrite = false;
  material.side = THREE.DoubleSide;
  material.colorNode = attribute("color");
  return material;
}
class WebGPUSplatPipeline {
  constructor(renderer, options = {}) {
    this.worldToView = new THREE.Matrix4();
    this.accumToView = new THREE.Matrix4();
    this.viewToAccum = new THREE.Matrix4();
    this.renderToViewQuat = new THREE.Quaternion();
    this.renderToViewPos = new THREE.Vector3();
    this.renderer = renderer;
    this.maxSplats = options.maxSplats ?? DEFAULT_MAX_SPLATS;
    this.sortPass = new SortComputePass(renderer, this.maxSplats);
    this.renderPass = new RenderComputePass(
      renderer,
      this.maxSplats,
      this.sortPass.getSortedIndicesStorage()
    );
    if (options.debug) {
      this.material = createDebugSplatMaterial();
    } else {
      this.material = createWebGPUSplatMaterial(options.materialOptions ?? {});
    }
    this.mesh = new THREE.Mesh(this.renderPass.geometry, this.material);
    this.mesh.frustumCulled = false;
    this.mesh.renderOrder = 1e3;
    console.log("[WebGPUSplatPipeline] Pipeline initialized");
  }
  /**
   * Update the pipeline and render splats.
   *
   * @param params - Pipeline parameters
   */
  async update(params) {
    const {
      packedSplatsTexture,
      numSplats,
      camera,
      accumToWorld,
      renderSize,
      rgbMinMaxLnScaleMinMax,
      maxStdDev = 3,
      minAlpha = 1 / 255,
      minPixelRadius = 0,
      maxPixelRadius = 2048,
      clipXY = 1.2,
      focalAdjustment = 1,
      blurAmount = 0.3,
      preBlurAmount = 0,
      sortRadial = true,
      depthBias = 1
    } = params;
    if (numSplats === 0) {
      this.renderPass.geometry.setDrawRange(0, 0);
      return;
    }
    this.worldToView.copy(camera.matrixWorld).invert();
    this.accumToView.multiplyMatrices(this.worldToView, accumToWorld);
    this.viewToAccum.copy(this.accumToView).invert();
    this.accumToView.decompose(
      this.renderToViewPos,
      this.renderToViewQuat,
      new THREE.Vector3()
      // scale (ignored)
    );
    const viewOrigin = new THREE.Vector3(0, 0, 0);
    viewOrigin.applyMatrix4(this.viewToAccum);
    const viewDirection = new THREE.Vector3(0, 0, -1);
    viewDirection.transformDirection(this.viewToAccum).normalize();
    const isOrthographic = !camera.isPerspectiveCamera;
    const sortParams = {
      packedSplatsTexture,
      numSplats,
      viewOrigin,
      viewDirection,
      rgbMinMaxLnScaleMinMax,
      sortRadial,
      depthBias
    };
    await this.sortPass.sort(sortParams);
    const renderParams = {
      packedSplatsTexture,
      numSplats,
      renderToViewQuat: this.renderToViewQuat,
      renderToViewPos: this.renderToViewPos,
      projectionMatrix: camera.projectionMatrix,
      renderSize,
      rgbMinMaxLnScaleMinMax,
      maxStdDev,
      minAlpha,
      minPixelRadius,
      maxPixelRadius,
      clipXY,
      focalAdjustment,
      blurAmount,
      preBlurAmount,
      isOrthographic
    };
    await this.renderPass.update(renderParams);
  }
  /**
   * Dispose of GPU resources.
   */
  dispose() {
    this.sortPass.dispose();
    this.renderPass.dispose();
    this.material.dispose();
    this.mesh.geometry.dispose();
  }
}
const MAX_ACCUMULATORS = 5;
const _SparkRenderer = class _SparkRenderer extends THREE.Mesh {
  constructor(options) {
    const uniforms = _SparkRenderer.makeUniforms();
    const premultipliedAlpha = options.premultipliedAlpha ?? true;
    let material;
    let computePipeline = null;
    if (isWebGPURenderer(options.renderer)) {
      setUsingWebGPU(true);
      computePipeline = new WebGPUSplatPipeline(
        options.renderer,
        // WebGPURenderer type not in @types/three
        {
          maxSplats: 1024 * 1024,
          // 1M max splats
          materialOptions: {
            premultipliedAlpha: options.premultipliedAlpha ?? true,
            falloff: options.falloff ?? 1,
            minAlpha: options.minAlpha ?? 0.5 * (1 / 255)
          }
        }
      );
      material = new THREE.MeshBasicMaterial({
        visible: false
      });
    } else {
      setUsingWebGPU(false);
      const shaders2 = getShaders();
      material = new THREE.ShaderMaterial({
        glslVersion: THREE.GLSL3,
        vertexShader: shaders2.splatVertex,
        fragmentShader: shaders2.splatFragment,
        uniforms,
        premultipliedAlpha,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide
      });
    }
    super(EMPTY_GEOMETRY, material);
    this.splatTexture = null;
    this.autoViewpoints = [];
    this.rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });
    this.translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() });
    this.lastFrame = -1;
    this.lastUpdateTime = null;
    this.defaultCameras = [];
    this.lastStochastic = null;
    this.pendingUpdate = {
      scene: null,
      originToWorld: new THREE.Matrix4(),
      timeoutId: -1
    };
    this.envViewpoint = null;
    this.computePipeline = null;
    this.computePipeline = computePipeline;
    if (computePipeline) {
      this.add(computePipeline.mesh);
      console.log("[SparkRenderer] Added WebGPU pipeline mesh as child");
      console.log("[SparkRenderer] Setting up onBeforeRender on compute mesh");
      computePipeline.mesh.onBeforeRender = (renderer, scene, camera) => {
        var _a2;
        if (this.autoUpdate) {
          this.defaultView.viewToWorld = camera.matrixWorld.clone();
          this.update({ scene, viewToWorld: this.defaultView.viewToWorld });
        }
        this.prepareViewpoint();
        if (this.uniforms.numSplats.value > 0) {
          console.log(
            "[SparkRenderer] Running WebGPU compute for",
            this.uniforms.numSplats.value,
            "splats"
          );
          const accumToWorld = ((_a2 = this.viewpoint.display) == null ? void 0 : _a2.accumulator.toWorld) ?? new THREE.Matrix4();
          void computePipeline.update({
            packedSplatsTexture: this.uniforms.packedSplats.value,
            numSplats: this.uniforms.numSplats.value,
            camera,
            accumToWorld,
            renderSize: this.uniforms.renderSize.value,
            rgbMinMaxLnScaleMinMax: this.uniforms.rgbMinMaxLnScaleMinMax.value,
            maxStdDev: this.maxStdDev,
            minAlpha: this.minAlpha,
            minPixelRadius: this.minPixelRadius,
            maxPixelRadius: this.maxPixelRadius,
            clipXY: this.clipXY,
            focalAdjustment: this.focalAdjustment,
            blurAmount: this.blurAmount,
            preBlurAmount: this.preBlurAmount,
            sortRadial: this.viewpoint.sortRadial ?? true,
            depthBias: this.viewpoint.depthBias ?? 1
          });
        }
      };
    }
    this.frustumCulled = false;
    this.renderer = options.renderer;
    this.material = material;
    this.uniforms = uniforms;
    const modifier = dynoBlock(
      { gsplat: Gsplat },
      { gsplat: Gsplat },
      ({ gsplat }) => {
        if (!gsplat) {
          throw new Error("gsplat not defined");
        }
        gsplat = transformGsplat(gsplat, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        });
        return { gsplat };
      }
    );
    this.modifier = new SplatModifier(modifier);
    this.premultipliedAlpha = premultipliedAlpha;
    this.autoUpdate = options.autoUpdate ?? true;
    this.preUpdate = options.preUpdate ?? false;
    this.needsUpdate = false;
    this.originDistance = options.originDistance ?? 1;
    this.maxStdDev = options.maxStdDev ?? Math.sqrt(8);
    this.minPixelRadius = options.minPixelRadius ?? 0;
    this.maxPixelRadius = options.maxPixelRadius ?? 512;
    this.minAlpha = options.minAlpha ?? 0.5 * (1 / 255);
    this.enable2DGS = options.enable2DGS ?? false;
    this.preBlurAmount = options.preBlurAmount ?? 0;
    this.blurAmount = options.blurAmount ?? 0.3;
    this.focalDistance = options.focalDistance ?? 0;
    this.apertureAngle = options.apertureAngle ?? 0;
    this.falloff = options.falloff ?? 1;
    this.clipXY = options.clipXY ?? 1.4;
    this.focalAdjustment = options.focalAdjustment ?? 1;
    this.splatEncoding = options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };
    this.active = new SplatAccumulator();
    this.active.refCount = 1;
    this.accumulatorCount = 1;
    this.freeAccumulators = [];
    for (let count = 0; count < 1; ++count) {
      this.freeAccumulators.push(new SplatAccumulator());
      this.accumulatorCount += 1;
    }
    this.defaultView = new SparkViewpoint({
      ...options.view,
      autoUpdate: true,
      spark: this
    });
    this.viewpoint = this.defaultView;
    this.prepareViewpoint(this.viewpoint);
    this.clock = options.clock ? cloneClock(options.clock) : new THREE.Clock();
  }
  static makeUniforms() {
    const uniforms = {
      // Size of render viewport in pixels
      renderSize: { value: new THREE.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new THREE.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new THREE.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Minimum pixel radius for splat rendering
      minPixelRadius: { value: 0 },
      // Maximum pixel radius for splat rendering
      maxPixelRadius: { value: 512 },
      // Minimum alpha value for splat rendering
      minAlpha: { value: 0.5 * (1 / 255) },
      // Enable stochastic splat rendering
      stochastic: { value: false },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: false },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: false },
      // Splat texture to render
      splatTexture: { type: "t", value: _SparkRenderer.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new THREE.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new THREE.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: PackedSplats.getEmpty() },
      // Splat encoding ranges
      rgbMinMaxLnScaleMinMax: { value: new THREE.Vector4() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: false },
      // Debug flag that alternates each frame
      debugFlag: { value: false }
    };
    return uniforms;
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < MAX_ACCUMULATORS;
  }
  maybeAllocAccumulator() {
    let accumulator = this.freeAccumulators.pop();
    if (accumulator === void 0) {
      if (this.accumulatorCount >= MAX_ACCUMULATORS) {
        return null;
      }
      accumulator = new SplatAccumulator();
      this.accumulatorCount += 1;
    }
    accumulator.refCount = 1;
    return accumulator;
  }
  releaseAccumulator(accumulator) {
    accumulator.refCount -= 1;
    if (accumulator.refCount === 0) {
      this.freeAccumulators.push(accumulator);
    }
  }
  newViewpoint(options) {
    return new SparkViewpoint({ ...options, spark: this });
  }
  onBeforeRender(renderer, scene, camera) {
    var _a2, _b2;
    const time2 = this.time ?? this.clock.getElapsedTime();
    const deltaTime2 = time2 - (this.viewpoint.lastTime ?? time2);
    this.viewpoint.lastTime = time2;
    const frame = renderer.info.render.frame;
    const isNewFrame = frame !== this.lastFrame;
    this.lastFrame = frame;
    const viewpoint = this.viewpoint;
    if (viewpoint === this.defaultView) {
      if (isNewFrame) {
        if (!renderer.xr.isPresenting) {
          this.defaultView.viewToWorld = camera.matrixWorld.clone();
          this.defaultCameras = [this.defaultView.viewToWorld];
        } else {
          const cameras = renderer.xr.getCamera().cameras;
          this.defaultCameras = cameras.map((camera2) => camera2.matrixWorld);
          this.defaultView.viewToWorld = averageOriginToWorlds(this.defaultCameras) ?? new THREE.Matrix4();
        }
      }
      if (this.autoUpdate) {
        this.update({ scene, viewToWorld: this.defaultView.viewToWorld });
      }
    }
    if (isNewFrame) {
      if (this.material.premultipliedAlpha !== this.premultipliedAlpha) {
        this.material.premultipliedAlpha = this.premultipliedAlpha;
        this.material.needsUpdate = true;
      }
      this.uniforms.time.value = time2;
      this.uniforms.deltaTime.value = deltaTime2;
      this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1;
      if (viewpoint.display && viewpoint.stochastic) {
        this.geometry.instanceCount = this.uniforms.numSplats.value;
      }
    }
    if (viewpoint.target) {
      this.uniforms.renderSize.value.set(
        viewpoint.target.width,
        viewpoint.target.height
      );
    } else {
      const renderSize = renderer.getDrawingBufferSize(
        this.uniforms.renderSize.value
      );
      if (renderSize.x === 1 && renderSize.y === 1) {
        const baseLayer = (_a2 = renderer.xr.getSession()) == null ? void 0 : _a2.renderState.baseLayer;
        if (baseLayer) {
          renderSize.x = baseLayer.framebufferWidth;
          renderSize.y = baseLayer.framebufferHeight;
        }
      }
    }
    const typedCamera = camera;
    this.uniforms.near.value = typedCamera.near;
    this.uniforms.far.value = typedCamera.far;
    this.uniforms.encodeLinear.value = viewpoint.encodeLinear;
    this.uniforms.maxStdDev.value = this.maxStdDev;
    this.uniforms.minPixelRadius.value = this.minPixelRadius;
    this.uniforms.maxPixelRadius.value = this.maxPixelRadius;
    this.uniforms.minAlpha.value = this.minAlpha;
    this.uniforms.stochastic.value = viewpoint.stochastic;
    this.uniforms.enable2DGS.value = this.enable2DGS;
    this.uniforms.preBlurAmount.value = this.preBlurAmount;
    this.uniforms.blurAmount.value = this.blurAmount;
    this.uniforms.focalDistance.value = this.focalDistance;
    this.uniforms.apertureAngle.value = this.apertureAngle;
    this.uniforms.falloff.value = this.falloff;
    this.uniforms.clipXY.value = this.clipXY;
    this.uniforms.focalAdjustment.value = this.focalAdjustment;
    if (this.lastStochastic !== !viewpoint.stochastic) {
      this.lastStochastic = !viewpoint.stochastic;
      this.material.transparent = !viewpoint.stochastic;
      this.material.depthWrite = viewpoint.stochastic;
      this.material.needsUpdate = true;
    }
    if (this.splatTexture) {
      const { enable, texture: texture2, multiply, add: add2, near, far, mid } = this.splatTexture;
      if (enable && texture2) {
        this.uniforms.splatTexEnable.value = true;
        this.uniforms.splatTexture.value = texture2;
        if (multiply) {
          this.uniforms.splatTexMul.value.fromArray(multiply.elements);
        } else {
          this.uniforms.splatTexMul.value.set(
            0.5 / this.maxStdDev,
            0,
            0,
            0.5 / this.maxStdDev
          );
        }
        this.uniforms.splatTexAdd.value.set((add2 == null ? void 0 : add2.x) ?? 0.5, (add2 == null ? void 0 : add2.y) ?? 0.5);
        this.uniforms.splatTexNear.value = near ?? this.uniforms.near.value;
        this.uniforms.splatTexFar.value = far ?? this.uniforms.far.value;
        this.uniforms.splatTexMid.value = mid ?? 0;
      } else {
        this.uniforms.splatTexEnable.value = false;
        this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;
      }
    } else {
      this.uniforms.splatTexEnable.value = false;
      this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;
    }
    const accumToWorld = ((_b2 = viewpoint.display) == null ? void 0 : _b2.accumulator.toWorld) ?? new THREE.Matrix4();
    const worldToCamera = camera.matrixWorld.clone().invert();
    const originToCamera = accumToWorld.clone().premultiply(worldToCamera);
    originToCamera.decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new THREE.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(viewpoint) {
    var _a2, _b2, _c, _d;
    this.viewpoint = viewpoint ?? this.viewpoint;
    if (this.viewpoint.display) {
      const { accumulator, geometry } = this.viewpoint.display;
      const numSplats = accumulator.splats.numSplats;
      this.uniforms.numSplats.value = numSplats;
      this.uniforms.packedSplats.value = accumulator.splats.getTexture();
      this.uniforms.rgbMinMaxLnScaleMinMax.value.set(
        ((_a2 = accumulator.splats.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,
        ((_b2 = accumulator.splats.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,
        ((_c = accumulator.splats.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,
        ((_d = accumulator.splats.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX
      );
      if (!this.computePipeline) {
        this.geometry = geometry;
      }
      this.material.transparent = !this.viewpoint.stochastic;
      this.material.depthWrite = this.viewpoint.stochastic;
      this.material.needsUpdate = true;
    } else {
      this.uniforms.numSplats.value = 0;
      this.uniforms.packedSplats.value = PackedSplats.getEmpty();
      if (!this.computePipeline) {
        this.geometry = EMPTY_GEOMETRY;
      }
    }
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene,
    viewToWorld
  }) {
    const originToWorld = this.matrixWorld;
    if (this.preUpdate) {
      this.updateInternal({
        scene,
        originToWorld: originToWorld.clone(),
        viewToWorld
      });
    } else {
      this.pendingUpdate.scene = scene;
      this.pendingUpdate.originToWorld.copy(originToWorld);
      if (this.pendingUpdate.timeoutId === -1) {
        this.pendingUpdate.timeoutId = setTimeout(() => {
          const { scene: scene2, originToWorld: originToWorld2 } = this.pendingUpdate;
          this.pendingUpdate.scene = null;
          this.pendingUpdate.timeoutId = -1;
          const updated = this.updateInternal({
            scene: scene2,
            originToWorld: originToWorld2,
            viewToWorld
          });
          if (updated && !isWebGPURenderer(this.renderer)) {
            const gl = this.renderer.getContext();
            gl.flush();
          }
        }, 1);
      }
    }
  }
  updateInternal({
    scene,
    originToWorld,
    viewToWorld
  }) {
    var _a2;
    if (!this.canAllocAccumulator()) {
      return false;
    }
    if (!originToWorld) {
      originToWorld = this.active.toWorld;
    }
    viewToWorld = viewToWorld ?? originToWorld.clone();
    const time2 = this.time ?? this.clock.getElapsedTime();
    const deltaTime2 = time2 - (this.lastUpdateTime ?? time2);
    this.lastUpdateTime = time2;
    const activeMapping = this.active.mapping.reduce((map, record) => {
      map.set(record.node, record);
      return map;
    }, /* @__PURE__ */ new Map());
    const { generators: generators2, visibleGenerators, globalEdits } = this.compileScene(scene);
    for (const object of generators2) {
      (_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {
        object,
        time: time2,
        deltaTime: deltaTime2,
        viewToWorld,
        globalEdits
      });
    }
    const visibleGenHash = new Set(visibleGenerators.map((g) => g.uuid));
    for (const object of generators2) {
      const current = activeMapping.get(object);
      const isVisible = object.generator && visibleGenHash.has(object.uuid);
      const numSplats = isVisible ? object.numSplats : 0;
      if (this.needsUpdate || object.generator !== (current == null ? void 0 : current.generator) || numSplats !== (current == null ? void 0 : current.count)) {
        object.updateVersion();
      }
    }
    const originUpdate = !withinCoorientDist({
      matrix1: originToWorld,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    });
    const needsUpdate = this.needsUpdate || originUpdate || generators2.length !== activeMapping.size || generators2.some((g) => {
      var _a3;
      return g.version !== ((_a3 = activeMapping.get(g)) == null ? void 0 : _a3.version);
    });
    this.needsUpdate = false;
    let accumulator = null;
    if (needsUpdate) {
      accumulator = this.maybeAllocAccumulator();
      if (!accumulator) {
        throw new Error("Unreachable");
      }
      const originChanged = !withinCoorientDist({
        matrix1: originToWorld,
        matrix2: accumulator.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      });
      const sorted = visibleGenerators.map((g, gIndex) => {
        const lastGen = activeMapping.get(g);
        return !lastGen ? [Number.POSITIVE_INFINITY, g.version, g] : (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [g.version - lastGen.version, lastGen.base, g]
        );
      }).sort((a, b) => {
        if (a[0] !== b[0]) {
          return a[0] - b[0];
        }
        return a[1] - b[1];
      });
      const genOrder = sorted.map(([_version, _seq, g]) => g);
      const splatCounts = genOrder.map((g) => g.numSplats);
      const { maxSplats, mapping } = accumulator.splats.generateMapping(splatCounts);
      const newGenerators = genOrder.map((node, gIndex) => {
        const { base, count } = mapping[gIndex];
        return {
          node,
          generator: node.generator,
          version: node.version,
          base,
          count
        };
      });
      originToWorld.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new THREE.Vector3()
      );
      if (isWebGPURenderer(this.renderer)) {
        accumulator.ensureGenerateCpu(maxSplats);
        accumulator.splats.splatEncoding = { ...this.splatEncoding };
        accumulator.generateSplatsCpu({
          generators: newGenerators,
          originToWorld
        });
      } else {
        accumulator.ensureGenerate(maxSplats);
        accumulator.splats.splatEncoding = { ...this.splatEncoding };
        accumulator.generateSplats({
          renderer: this.renderer,
          modifier: this.modifier,
          generators: newGenerators,
          forceUpdate: originChanged,
          originToWorld
        });
      }
      accumulator.splatsVersion = this.active.splatsVersion + 1;
      const hasCorrespondence = accumulator.hasCorrespondence(this.active);
      accumulator.mappingVersion = this.active.mappingVersion + (hasCorrespondence ? 0 : 1);
      this.releaseAccumulator(this.active);
      this.active = accumulator;
      this.prepareViewpoint();
    }
    setTimeout(() => {
      for (const view of this.autoViewpoints) {
        const forceStochastic = isWebGPURenderer(this.renderer);
        view.autoPoll({
          accumulator: accumulator ?? void 0,
          forceStochastic
        });
      }
    }, 1);
    return true;
  }
  compileScene(scene) {
    const generators2 = [];
    scene.traverse((node) => {
      if (node instanceof SplatGenerator) {
        generators2.push(node);
      }
    });
    const visibleGenerators = [];
    scene.traverseVisible((node) => {
      if (node instanceof SplatGenerator) {
        visibleGenerators.push(node);
      }
    });
    const globalEdits = /* @__PURE__ */ new Set();
    scene.traverseVisible((node) => {
      if (node instanceof SplatEdit) {
        let ancestor = node.parent;
        while (ancestor != null && !(ancestor instanceof SplatMesh)) {
          ancestor = ancestor.parent;
        }
        if (ancestor == null) {
          globalEdits.add(node);
        }
      }
    });
    return {
      generators: generators2,
      visibleGenerators,
      globalEdits: Array.from(globalEdits)
    };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  // Note: This function is not supported with WebGPU renderer due to PMREMGenerator
  // using ShaderMaterial internally.
  async renderEnvMap({
    renderer,
    scene,
    worldCenter,
    size = 256,
    near = 0.1,
    far = 1e3,
    hideObjects = [],
    update = false
  }) {
    var _a2, _b2;
    if (isWebGPURenderer(this.renderer)) {
      console.warn(
        "SparkRenderer.renderEnvMap is not supported with WebGPU renderer. PMREMGenerator uses ShaderMaterial internally which is incompatible."
      );
      return _SparkRenderer.EMPTY_SPLAT_TEXTURE;
    }
    if (!this.envViewpoint) {
      this.envViewpoint = this.newViewpoint({ sort360: true });
    }
    if (!_SparkRenderer.cubeRender || _SparkRenderer.cubeRender.target.width !== size || _SparkRenderer.cubeRender.near !== near || _SparkRenderer.cubeRender.far !== far) {
      if (_SparkRenderer.cubeRender) {
        _SparkRenderer.cubeRender.target.dispose();
      }
      const target2 = new THREE.WebGLCubeRenderTarget(size, {
        format: THREE.RGBAFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipMapLinearFilter
      });
      const camera2 = new THREE.CubeCamera(near, far, target2);
      _SparkRenderer.cubeRender = { target: target2, camera: camera2, near, far };
    }
    if (!_SparkRenderer.pmrem) {
      _SparkRenderer.pmrem = new THREE.PMREMGenerator(renderer ?? this.renderer);
    }
    const viewToWorld = new THREE.Matrix4().setPosition(worldCenter);
    await ((_a2 = this.envViewpoint) == null ? void 0 : _a2.prepare({ scene, viewToWorld, update }));
    const { target, camera } = _SparkRenderer.cubeRender;
    camera.position.copy(worldCenter);
    const objectVisibility = /* @__PURE__ */ new Map();
    for (const object of hideObjects) {
      objectVisibility.set(object, object.visible);
      object.visible = false;
    }
    this.prepareViewpoint(this.envViewpoint);
    camera.update(renderer ?? this.renderer, scene);
    this.prepareViewpoint(this.defaultView);
    for (const [object, visible] of objectVisibility.entries()) {
      object.visible = visible;
    }
    return (_b2 = _SparkRenderer.pmrem) == null ? void 0 : _b2.fromCubemap(target.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(root, envMap) {
    root.traverse((node) => {
      if (node instanceof THREE.Mesh) {
        if (Array.isArray(node.material)) {
          for (const material of node.material) {
            if (material instanceof THREE.MeshStandardMaterial) {
              material.envMap = envMap;
            }
          }
        } else {
          if (node.material instanceof THREE.MeshStandardMaterial) {
            node.material.envMap = envMap;
          }
        }
      }
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator,
    rgba
  }) {
    const mapping = this.active.mapping.find(({ node }) => node === generator);
    if (!mapping) {
      throw new Error("Generator not found");
    }
    rgba = rgba ?? new RgbaArray();
    rgba.fromPackedSplats({
      packedSplats: this.active.splats,
      base: mapping.base,
      count: mapping.count,
      renderer: this.renderer
    });
    return rgba;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator,
    rgba
  }) {
    rgba = this.getRgba({ generator, rgba });
    return rgba.read();
  }
};
_SparkRenderer.cubeRender = null;
_SparkRenderer.pmrem = null;
_SparkRenderer.EMPTY_SPLAT_TEXTURE = new THREE.Data3DTexture();
let SparkRenderer = _SparkRenderer;
const EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);
dynoBlock(
  { packedSplats: TPackedSplats, index: "int" },
  { gsplat: Gsplat },
  ({ packedSplats, index }) => {
    if (!packedSplats || !index) {
      throw new Error("Invalid input");
    }
    const gsplat = readPackedSplat(packedSplats, index);
    return { gsplat };
  }
);
function averageOriginToWorlds(originToWorlds) {
  if (originToWorlds.length === 0) {
    return null;
  }
  const position = new THREE.Vector3();
  const quaternion = new THREE.Quaternion();
  const scale = new THREE.Vector3();
  const positions = [];
  const quaternions = [];
  for (const matrix of originToWorlds) {
    matrix.decompose(position, quaternion, scale);
    positions.push(position);
    quaternions.push(quaternion);
  }
  return new THREE.Matrix4().compose(
    averagePositions(positions),
    averageQuaternions(quaternions),
    new THREE.Vector3(1, 1, 1)
  );
}
function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {
  const numSplats = Math.floor(fileBytes.length / 32);
  if (numSplats * 32 !== fileBytes.length) {
    throw new Error("Invalid .splat file size");
  }
  const f32 = new Float32Array(fileBytes.buffer);
  for (let i = 0; i < numSplats; ++i) {
    const i322 = i * 32;
    const i8 = i * 8;
    const x = f32[i8 + 0];
    const y = f32[i8 + 1];
    const z = f32[i8 + 2];
    const scaleX = f32[i8 + 3];
    const scaleY = f32[i8 + 4];
    const scaleZ = f32[i8 + 5];
    const r = fileBytes[i322 + 24] / 255;
    const g = fileBytes[i322 + 25] / 255;
    const b = fileBytes[i322 + 26] / 255;
    const opacity = fileBytes[i322 + 27] / 255;
    const quatW = (fileBytes[i322 + 28] - 128) / 128;
    const quatX = (fileBytes[i322 + 29] - 128) / 128;
    const quatY = (fileBytes[i322 + 30] - 128) / 128;
    const quatZ = (fileBytes[i322 + 31] - 128) / 128;
    splatCallback(
      i,
      x,
      y,
      z,
      scaleX,
      scaleY,
      scaleZ,
      quatX,
      quatY,
      quatZ,
      quatW,
      opacity,
      r,
      g,
      b
    );
  }
}
const KSPLAT_COMPRESSION = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
};
const KSPLAT_SH_DEGREE_TO_COMPONENTS = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {
  var _a2;
  const HEADER_BYTES = 4096;
  const SECTION_BYTES = 1024;
  let headerOffset = 0;
  const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
  headerOffset += HEADER_BYTES;
  const versionMajor = header.getUint8(0);
  const versionMinor = header.getUint8(1);
  if (versionMajor !== 0 || versionMinor < 1) {
    throw new Error(
      `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`
    );
  }
  const maxSectionCount = header.getUint32(4, true);
  header.getUint32(16, true);
  const compressionLevel = header.getUint16(20, true);
  if (compressionLevel < 0 || compressionLevel > 2) {
    throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);
  }
  const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
  const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
  let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
  for (let section = 0; section < maxSectionCount; ++section) {
    let getSh = function(splatOffset, component) {
      if (compressionLevel === 0) {
        return data.getFloat32(
          splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
          true
        );
      }
      if (compressionLevel === 1) {
        return fromHalf(
          data.getUint16(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
            true
          )
        );
      }
      const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
      return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
    };
    const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
    headerOffset += SECTION_BYTES;
    const sectionSplatCount = section2.getUint32(0, true);
    const sectionMaxSplatCount = section2.getUint32(4, true);
    const bucketSize = section2.getUint32(8, true);
    const bucketCount = section2.getUint32(12, true);
    const bucketBlockSize = section2.getFloat32(16, true);
    const bucketStorageSizeBytes = section2.getUint16(20, true);
    const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
    const fullBucketCount = section2.getUint32(32, true);
    const fullBucketSplats = fullBucketCount * bucketSize;
    const partiallyFilledBucketCount = section2.getUint32(36, true);
    const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
    const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
    const sphericalHarmonicsDegree = section2.getUint16(40, true);
    const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
    const {
      bytesPerCenter,
      bytesPerScale,
      bytesPerRotation,
      bytesPerColor,
      bytesPerSphericalHarmonicsComponent,
      scaleOffsetBytes,
      rotationOffsetBytes,
      colorOffsetBytes,
      sphericalHarmonicsOffsetBytes
    } = KSPLAT_COMPRESSION[compressionLevel];
    const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
    const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
    const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
    const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
    const sh2Index = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ];
    const sh3Index = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ];
    const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
    const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
    const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
    const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
    const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
    const dataBase = sectionBase + bucketsStorageSizeBytes;
    const data = new DataView(
      fileBytes.buffer,
      dataBase,
      splatDataStorageSizeBytes
    );
    const bucketArray = new Float32Array(
      fileBytes.buffer,
      bucketsBase,
      bucketCount * 3
    );
    const partiallyFilledBucketLengths = new Uint32Array(
      fileBytes.buffer,
      sectionBase,
      partiallyFilledBucketCount
    );
    let partialBucketIndex = fullBucketCount;
    let partialBucketBase = fullBucketSplats;
    for (let i = 0; i < sectionSplatCount; ++i) {
      const splatOffset = i * bytesPerSplat;
      let bucketIndex;
      if (i < fullBucketSplats) {
        bucketIndex = Math.floor(i / bucketSize);
      } else {
        const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
        if (i >= partialBucketBase + bucketLength) {
          partialBucketIndex += 1;
          partialBucketBase += bucketLength;
        }
        bucketIndex = partialBucketIndex;
      }
      const x = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
      const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
      const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
      const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
      const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
      const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
      const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
      );
      const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
      );
      const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
      );
      const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
      );
      const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
      const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
      const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
      const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
      splatCallback(
        i,
        x,
        y,
        z,
        scaleX,
        scaleY,
        scaleZ,
        quatX,
        quatY,
        quatZ,
        quatW,
        opacity,
        r,
        g,
        b
      );
      if (sphericalHarmonicsDegree >= 1 && sh1) {
        for (const [i2, key] of sh1Index.entries()) {
          sh1[i2] = getSh(splatOffset, key);
        }
        if (sh2) {
          for (const [i2, key] of sh2Index.entries()) {
            sh2[i2] = getSh(splatOffset, key);
          }
        }
        if (sh3) {
          for (const [i2, key] of sh3Index.entries()) {
            sh3[i2] = getSh(splatOffset, key);
          }
        }
        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);
      }
    }
    sectionBase += storageSizeBytes;
  }
}
class SpzReader {
  constructor({ fileBytes }) {
    this.version = -1;
    this.numSplats = 0;
    this.shDegree = 0;
    this.fractionalBits = 0;
    this.flags = 0;
    this.flagAntiAlias = false;
    this.reserved = 0;
    this.headerParsed = false;
    this.parsed = false;
    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
    this.reader = new GunzipReader({ fileBytes: this.fileBytes });
  }
  async parseHeader() {
    if (this.headerParsed) {
      throw new Error("SPZ file header already parsed");
    }
    const header = new DataView((await this.reader.read(16)).buffer);
    if (header.getUint32(0, true) !== 1347635022) {
      throw new Error("Invalid SPZ file");
    }
    this.version = header.getUint32(4, true);
    if (this.version < 1 || this.version > 3) {
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    }
    this.numSplats = header.getUint32(8, true);
    this.shDegree = header.getUint8(12);
    this.fractionalBits = header.getUint8(13);
    this.flags = header.getUint8(14);
    this.flagAntiAlias = (this.flags & 1) !== 0;
    this.reserved = header.getUint8(15);
    this.headerParsed = true;
    this.parsed = false;
  }
  async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {
    if (!this.headerParsed) {
      throw new Error("SPZ file header must be parsed first");
    }
    if (this.parsed) {
      throw new Error("SPZ file already parsed");
    }
    this.parsed = true;
    if (this.version === 1) {
      const centerBytes = await this.reader.read(this.numSplats * 3 * 2);
      const centerUint16 = new Uint16Array(centerBytes.buffer);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const x = fromHalf(centerUint16[i3]);
        const y = fromHalf(centerUint16[i3 + 1]);
        const z = fromHalf(centerUint16[i3 + 2]);
        centerCallback == null ? void 0 : centerCallback(i, x, y, z);
      }
    } else if (this.version === 2 || this.version === 3) {
      const fixed = 1 << this.fractionalBits;
      const centerBytes = await this.reader.read(this.numSplats * 3 * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i9 = i * 9;
        const x = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;
        const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;
        const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;
        centerCallback == null ? void 0 : centerCallback(i, x, y, z);
      }
    } else {
      throw new Error("Unreachable");
    }
    {
      const bytes = await this.reader.read(this.numSplats);
      for (let i = 0; i < this.numSplats; i++) {
        alphaCallback == null ? void 0 : alphaCallback(i, bytes[i] / 255);
      }
    }
    {
      const rgbBytes = await this.reader.read(this.numSplats * 3);
      const scale = SH_C0 / 0.15;
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;
        const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;
        const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;
        rgbCallback == null ? void 0 : rgbCallback(i, r, g, b);
      }
    }
    {
      const scalesBytes = await this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);
        const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);
        const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);
        scalesCallback == null ? void 0 : scalesCallback(i, scaleX, scaleY, scaleZ);
      }
    }
    if (this.version === 3) {
      const maxValue = 1 / Math.sqrt(2);
      const quatBytes = await this.reader.read(this.numSplats * 4);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 4;
        const quaternion = [0, 0, 0, 0];
        const values = [
          quatBytes[i3],
          quatBytes[i3 + 1],
          quatBytes[i3 + 2],
          quatBytes[i3 + 3]
        ];
        const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);
        const valueMask = (1 << 9) - 1;
        const largestIndex = combinedValues >>> 30;
        let remainingValues = combinedValues;
        let sumSquares = 0;
        for (let i2 = 3; i2 >= 0; --i2) {
          if (i2 !== largestIndex) {
            const value = remainingValues & valueMask;
            const sign2 = remainingValues >>> 9 & 1;
            remainingValues = remainingValues >>> 10;
            quaternion[i2] = maxValue * (value / valueMask);
            quaternion[i2] = sign2 === 0 ? quaternion[i2] : -quaternion[i2];
            sumSquares += quaternion[i2] * quaternion[i2];
          }
        }
        const square = 1 - sumSquares;
        quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));
        quatCallback == null ? void 0 : quatCallback(
          i,
          quaternion[0],
          quaternion[1],
          quaternion[2],
          quaternion[3]
        );
      }
    } else {
      const quatBytes = await this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const quatX = quatBytes[i3] / 127.5 - 1;
        const quatY = quatBytes[i3 + 1] / 127.5 - 1;
        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;
        const quatW = Math.sqrt(
          Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)
        );
        quatCallback == null ? void 0 : quatCallback(i, quatX, quatY, quatZ, quatW);
      }
    }
    if (shCallback && this.shDegree >= 1) {
      const sh1 = new Float32Array(3 * 3);
      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const shBytes = await this.reader.read(
        this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3
      );
      let offset = 0;
      for (let i = 0; i < this.numSplats; i++) {
        for (let j = 0; j < 9; ++j) {
          sh1[j] = (shBytes[offset + j] - 128) / 128;
        }
        offset += 9;
        if (sh2) {
          for (let j = 0; j < 15; ++j) {
            sh2[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 15;
        }
        if (sh3) {
          for (let j = 0; j < 21; ++j) {
            sh3[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 21;
        }
        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);
      }
    }
  }
}
const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };
const SH_C0 = 0.28209479177387814;
const SPZ_MAGIC = 1347635022;
const SPZ_VERSION = 3;
const FLAG_ANTIALIASED = 1;
class SpzWriter {
  constructor({
    numSplats,
    shDegree,
    fractionalBits = 12,
    flagAntiAlias = true
  }) {
    this.clippedCount = 0;
    const splatSize = 9 + // Position
    1 + // Opacity
    3 + // Scale
    3 + // DC-rgb
    4 + // Rotation
    (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);
    const bufferSize = 16 + numSplats * splatSize;
    this.buffer = new ArrayBuffer(bufferSize);
    this.view = new DataView(this.buffer);
    this.view.setUint32(0, SPZ_MAGIC, true);
    this.view.setUint32(4, SPZ_VERSION, true);
    this.view.setUint32(8, numSplats, true);
    this.view.setUint8(12, shDegree);
    this.view.setUint8(13, fractionalBits);
    this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);
    this.view.setUint8(15, 0);
    this.numSplats = numSplats;
    this.shDegree = shDegree;
    this.fractionalBits = fractionalBits;
    this.fraction = 1 << fractionalBits;
    this.flagAntiAlias = flagAntiAlias;
  }
  setCenter(index, x, y, z) {
    const xRounded = Math.round(x * this.fraction);
    const xInt = Math.max(-8388607, Math.min(8388607, xRounded));
    const yRounded = Math.round(y * this.fraction);
    const yInt = Math.max(-8388607, Math.min(8388607, yRounded));
    const zRounded = Math.round(z * this.fraction);
    const zInt = Math.max(-8388607, Math.min(8388607, zRounded));
    const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;
    if (clipped) {
      this.clippedCount += 1;
    }
    const i9 = index * 9;
    const base = 16 + i9;
    this.view.setUint8(base, xInt & 255);
    this.view.setUint8(base + 1, xInt >> 8 & 255);
    this.view.setUint8(base + 2, xInt >> 16 & 255);
    this.view.setUint8(base + 3, yInt & 255);
    this.view.setUint8(base + 4, yInt >> 8 & 255);
    this.view.setUint8(base + 5, yInt >> 16 & 255);
    this.view.setUint8(base + 6, zInt & 255);
    this.view.setUint8(base + 7, zInt >> 8 & 255);
    this.view.setUint8(base + 8, zInt >> 16 & 255);
  }
  setAlpha(index, alpha) {
    const base = 16 + this.numSplats * 9 + index;
    this.view.setUint8(
      base,
      Math.max(0, Math.min(255, Math.round(alpha * 255)))
    );
  }
  static scaleRgb(r) {
    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(v)));
  }
  setRgb(index, r, g, b) {
    const base = 16 + this.numSplats * 10 + index * 3;
    this.view.setUint8(base, SpzWriter.scaleRgb(r));
    this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));
    this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));
  }
  setScale(index, scaleX, scaleY, scaleZ) {
    const base = 16 + this.numSplats * 13 + index * 3;
    this.view.setUint8(
      base,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))
    );
    this.view.setUint8(
      base + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))
    );
    this.view.setUint8(
      base + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))
    );
  }
  setQuat(index, ...q) {
    const base = 16 + this.numSplats * 16 + index * 4;
    const quat = normalize$4(q);
    let iLargest = 0;
    for (let i = 1; i < 4; ++i) {
      if (Math.abs(quat[i]) > Math.abs(quat[iLargest])) {
        iLargest = i;
      }
    }
    const negate2 = quat[iLargest] < 0 ? 1 : 0;
    let comp = iLargest;
    for (let i = 0; i < 4; ++i) {
      if (i !== iLargest) {
        const negbit = (quat[i] < 0 ? 1 : 0) ^ negate2;
        const mag = Math.floor(
          ((1 << 9) - 1) * (Math.abs(quat[i]) / Math.SQRT1_2) + 0.5
        );
        comp = comp << 10 | negbit << 9 | mag;
      }
    }
    this.view.setUint8(base, comp & 255);
    this.view.setUint8(base + 1, comp >> 8 & 255);
    this.view.setUint8(base + 2, comp >> 16 & 255);
    this.view.setUint8(base + 3, comp >>> 24 & 255);
  }
  static quantizeSh(sh, bits2) {
    const value = Math.round(sh * 128) + 128;
    const bucketSize = 1 << 8 - bits2;
    const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;
    return Math.max(0, Math.min(255, quantized));
  }
  setSh(index, sh1, sh2, sh3) {
    const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;
    const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;
    for (let j = 0; j < 9; ++j) {
      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));
    }
    if (sh2) {
      const base2 = base1 + 9;
      for (let j = 0; j < 15; ++j) {
        this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));
      }
      if (sh3) {
        const base3 = base2 + 15;
        for (let j = 0; j < 21; ++j) {
          this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));
        }
      }
    }
  }
  async finalize() {
    const input = new Uint8Array(this.buffer);
    const stream = new ReadableStream({
      async start(controller) {
        controller.enqueue(input);
        controller.close();
      }
    });
    const compressed = stream.pipeThrough(new CompressionStream("gzip"));
    const response = new Response(compressed);
    const buffer2 = await response.arrayBuffer();
    console.log(
      "Compressed",
      input.length,
      "bytes to",
      buffer2.byteLength,
      "bytes"
    );
    return new Uint8Array(buffer2);
  }
}
async function transcodeSpz(input) {
  var _a2, _b2, _c;
  const splats = new SplatData();
  const {
    inputs,
    clipXyz,
    maxSh,
    fractionalBits = 12,
    opacityThreshold
  } = input;
  for (const input2 of inputs) {
    let transformPos2 = function(pos) {
      pos.multiplyScalar(scale);
      pos.applyQuaternion(quaternion);
      pos.add(translate);
      return pos;
    }, transformScales = function(scales) {
      scales.multiplyScalar(scale);
      return scales;
    }, transformQuaternion = function(quat) {
      quat.premultiply(quaternion);
      return quat;
    }, withinClip = function(p) {
      return !clip || clip.containsPoint(p);
    }, withinOpacity = function(opacity) {
      return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;
    };
    const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;
    const quaternion = new THREE.Quaternion().fromArray(
      ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]
    );
    const translate = new THREE.Vector3().fromArray(
      ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]
    );
    const clip = clipXyz ? new THREE.Box3(
      new THREE.Vector3().fromArray(clipXyz.min),
      new THREE.Vector3().fromArray(clipXyz.max)
    ) : void 0;
    let fileType = input2.fileType;
    if (!fileType) {
      fileType = getSplatFileType(input2.fileBytes);
      if (!fileType && input2.pathOrUrl) {
        fileType = getSplatFileTypeFromPath(input2.pathOrUrl);
      }
    }
    switch (fileType) {
      case SplatFileType.PLY: {
        const ply = new PlyReader({ fileBytes: input2.fileBytes });
        await ply.parseHeader();
        let lastIndex = null;
        ply.parseSplats(
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              lastIndex = splats.pushSplat();
              splats.setCenter(lastIndex, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(lastIndex, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                lastIndex,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(lastIndex, opacity);
              splats.setColor(lastIndex, r, g, b);
            } else {
              lastIndex = null;
            }
          },
          (index, sh1, sh2, sh3) => {
            if (sh1 && lastIndex !== null) {
              splats.setSh1(lastIndex, sh1);
            }
            if (sh2 && lastIndex !== null) {
              splats.setSh2(lastIndex, sh2);
            }
            if (sh3 && lastIndex !== null) {
              splats.setSh3(lastIndex, sh3);
            }
          }
        );
        break;
      }
      case SplatFileType.SPZ: {
        const spz2 = new SpzReader({ fileBytes: input2.fileBytes });
        await spz2.parseHeader();
        const mapping = new Int32Array(spz2.numSplats);
        mapping.fill(-1);
        const centers = new Float32Array(spz2.numSplats * 3);
        const center = new THREE.Vector3();
        spz2.parseSplats(
          (index, x, y, z) => {
            const center2 = transformPos2(new THREE.Vector3(x, y, z));
            centers[index * 3] = center2.x;
            centers[index * 3 + 1] = center2.y;
            centers[index * 3 + 2] = center2.z;
          },
          (index, alpha) => {
            center.fromArray(centers, index * 3);
            if (withinClip(center) && withinOpacity(alpha)) {
              mapping[index] = splats.pushSplat();
              splats.setCenter(mapping[index], center.x, center.y, center.z);
              splats.setOpacity(mapping[index], alpha);
            }
          },
          (index, r, g, b) => {
            if (mapping[index] >= 0) {
              splats.setColor(mapping[index], r, g, b);
            }
          },
          (index, scaleX, scaleY, scaleZ) => {
            if (mapping[index] >= 0) {
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(mapping[index], scales.x, scales.y, scales.z);
            }
          },
          (index, quatX, quatY, quatZ, quatW) => {
            if (mapping[index] >= 0) {
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                mapping[index],
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
            }
          },
          (index, sh1, sh2, sh3) => {
            if (mapping[index] >= 0) {
              splats.setSh1(mapping[index], sh1);
              if (sh2) {
                splats.setSh2(mapping[index], sh2);
              }
              if (sh3) {
                splats.setSh3(mapping[index], sh3);
              }
            }
          }
        );
        break;
      }
      case SplatFileType.SPLAT:
        decodeAntiSplat(
          input2.fileBytes,
          (numSplats) => {
          },
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              const index2 = splats.pushSplat();
              splats.setCenter(index2, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(index2, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                index2,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(index2, opacity);
              splats.setColor(index2, r, g, b);
            }
          }
        );
        break;
      case SplatFileType.KSPLAT: {
        let lastIndex = null;
        decodeKsplat(
          input2.fileBytes,
          (numSplats) => {
          },
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              lastIndex = splats.pushSplat();
              splats.setCenter(lastIndex, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(lastIndex, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                lastIndex,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(lastIndex, opacity);
              splats.setColor(lastIndex, r, g, b);
            } else {
              lastIndex = null;
            }
          },
          (index, sh1, sh2, sh3) => {
            if (lastIndex !== null) {
              splats.setSh1(lastIndex, sh1);
              if (sh2) {
                splats.setSh2(lastIndex, sh2);
              }
              if (sh3) {
                splats.setSh3(lastIndex, sh3);
              }
            }
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${fileType}`);
    }
  }
  const shDegree = Math.min(
    maxSh ?? 3,
    splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0
  );
  const spz = new SpzWriter({
    numSplats: splats.numSplats,
    shDegree,
    fractionalBits,
    flagAntiAlias: true
  });
  for (let i = 0; i < splats.numSplats; ++i) {
    const i3 = i * 3;
    const i4 = i * 4;
    spz.setCenter(
      i,
      splats.centers[i3],
      splats.centers[i3 + 1],
      splats.centers[i3 + 2]
    );
    spz.setScale(
      i,
      splats.scales[i3],
      splats.scales[i3 + 1],
      splats.scales[i3 + 2]
    );
    spz.setQuat(
      i,
      splats.quaternions[i4],
      splats.quaternions[i4 + 1],
      splats.quaternions[i4 + 2],
      splats.quaternions[i4 + 3]
    );
    spz.setAlpha(i, splats.opacities[i]);
    spz.setRgb(
      i,
      splats.colors[i3],
      splats.colors[i3 + 1],
      splats.colors[i3 + 2]
    );
    if (splats.sh1 && shDegree >= 1) {
      spz.setSh(
        i,
        splats.sh1.slice(i * 9, (i + 1) * 9),
        shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i * 15, (i + 1) * 15) : void 0,
        shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i * 21, (i + 1) * 21) : void 0
      );
    }
  }
  const spzBytes = await spz.finalize();
  return { fileBytes: spzBytes, clippedCount: spz.clippedCount };
}
class SplatSkinning {
  constructor(options) {
    this.mesh = options.mesh;
    this.numSplats = options.numSplats ?? this.mesh.numSplats;
    const { width, height, depth: depth2, maxSplats } = getTextureSize(this.numSplats);
    this.skinData = new Uint16Array(maxSplats * 4);
    this.skinTexture = new THREE.DataArrayTexture(
      this.skinData,
      width,
      height,
      depth2
    );
    this.skinTexture.format = THREE.RGBAIntegerFormat;
    this.skinTexture.type = THREE.UnsignedShortType;
    setTextureInternalFormat(this.skinTexture, "RGBA16UI");
    this.skinTexture.needsUpdate = true;
    this.numBones = options.numBones ?? 256;
    this.boneData = new Float32Array(this.numBones * 16);
    this.boneTexture = new THREE.DataTexture(
      this.boneData,
      4,
      this.numBones,
      THREE.RGBAFormat,
      THREE.FloatType
    );
    setTextureInternalFormat(this.boneTexture, "RGBA32F");
    this.boneTexture.needsUpdate = true;
    this.uniform = new DynoUniform({
      key: "skinning",
      type: GsplatSkinning,
      globals: () => [defineGsplatSkinning],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(gsplat) {
    return applyGsplatSkinning(gsplat, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(boneIndex, quat, pos) {
    const i16 = boneIndex * 16;
    this.boneData[i16 + 0] = quat.x;
    this.boneData[i16 + 1] = quat.y;
    this.boneData[i16 + 2] = quat.z;
    this.boneData[i16 + 3] = quat.w;
    this.boneData[i16 + 4] = pos.x;
    this.boneData[i16 + 5] = pos.y;
    this.boneData[i16 + 6] = pos.z;
    this.boneData[i16 + 7] = 0;
    this.boneData[i16 + 8] = 0;
    this.boneData[i16 + 9] = 0;
    this.boneData[i16 + 10] = 0;
    this.boneData[i16 + 11] = 1;
    this.boneData[i16 + 12] = 0;
    this.boneData[i16 + 13] = 0;
    this.boneData[i16 + 14] = 0;
    this.boneData[i16 + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(boneIndex, quat, pos) {
    const i16 = boneIndex * 16;
    const origQuat = new THREE.Quaternion(
      this.boneData[i16 + 0],
      this.boneData[i16 + 1],
      this.boneData[i16 + 2],
      this.boneData[i16 + 3]
    );
    const origPos = new THREE.Vector3(
      this.boneData[i16 + 4],
      this.boneData[i16 + 5],
      this.boneData[i16 + 6]
    );
    const relQuat = origQuat.clone().invert();
    const relPos = pos.clone().sub(origPos);
    relPos.applyQuaternion(relQuat);
    relQuat.multiply(quat);
    const dual = new THREE.Quaternion(
      relPos.x,
      relPos.y,
      relPos.z,
      0
    ).multiply(origQuat);
    this.boneData[i16 + 8] = relQuat.x;
    this.boneData[i16 + 9] = relQuat.y;
    this.boneData[i16 + 10] = relQuat.z;
    this.boneData[i16 + 11] = relQuat.w;
    this.boneData[i16 + 12] = 0.5 * dual.x;
    this.boneData[i16 + 13] = 0.5 * dual.y;
    this.boneData[i16 + 14] = 0.5 * dual.z;
    this.boneData[i16 + 15] = 0.5 * dual.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(splatIndex, boneIndices, weights) {
    const i4 = splatIndex * 4;
    this.skinData[i4 + 0] = Math.min(255, Math.max(0, Math.round(weights.x * 255))) + (boneIndices.x << 8);
    this.skinData[i4 + 1] = Math.min(255, Math.max(0, Math.round(weights.y * 255))) + (boneIndices.y << 8);
    this.skinData[i4 + 2] = Math.min(255, Math.max(0, Math.round(weights.z * 255))) + (boneIndices.z << 8);
    this.skinData[i4 + 3] = Math.min(255, Math.max(0, Math.round(weights.w * 255))) + (boneIndices.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = true;
    this.mesh.needsUpdate = true;
  }
}
const GsplatSkinning = { type: "GsplatSkinning" };
const defineGsplatSkinning = unindent(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`);
const defineApplyGsplatSkinning = unindent(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function applyGsplatSkinning(gsplat, skinning2) {
  const dyno2 = new Dyno({
    inTypes: { gsplat: Gsplat, skinning: GsplatSkinning },
    outTypes: { gsplat: Gsplat },
    globals: () => [defineGsplatSkinning, defineApplyGsplatSkinning],
    inputs: { gsplat, skinning: skinning2 },
    statements: ({ inputs, outputs }) => {
      const { skinning: skinning22 } = inputs;
      const { gsplat: gsplat2 } = outputs;
      return unindentLines(`
        ${gsplat2} = ${inputs.gsplat};
        if (isGsplatActive(${gsplat2}.flags)) {
          applyGsplatSkinning(
            ${skinning22}.numSplats, ${skinning22}.numBones,
            ${skinning22}.skinTexture, ${skinning22}.boneTexture,
            ${gsplat2}.index, ${gsplat2}.center, ${gsplat2}.quaternion
          );
        }
      `);
    }
  });
  return dyno2.outputs.gsplat;
}
function constructGrid({
  // PackedSplats object to add splats to
  splats,
  // min and max box extents of the grid
  extents,
  // step size along each grid axis
  stepSize = 1,
  // spherical radius of each Gsplat
  pointRadius = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale = 2,
  // Gsplat opacity
  opacity = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: color2
}) {
  const EPSILON2 = 1e-6;
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3();
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  if (color2 == null) {
    color2 = (color22, point) => color22.set(
      0.55 + 0.45 * Math.cos(point.x * 1),
      0.55 + 0.45 * Math.cos(point.y * 1),
      0.55 + 0.45 * Math.cos(point.z * 1)
    );
  }
  const pointColor = new THREE.Color();
  for (let z = extents.min.z; z < extents.max.z + EPSILON2; z += stepSize) {
    for (let y = extents.min.y; y < extents.max.y + EPSILON2; y += stepSize) {
      for (let x = extents.min.x; x < extents.max.x + EPSILON2; x += stepSize) {
        center.set(x, y, z);
        for (let layer = 0; layer < 2; ++layer) {
          scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));
          if (!layer) {
            pointColor.setScalar(0);
          } else if (typeof color2 === "function") {
            color2(pointColor, center);
          } else {
            pointColor.copy(color2);
          }
          splats.pushSplat(center, scales, quaternion, opacity, pointColor);
        }
      }
    }
  }
}
function constructAxes({
  // PackedSplats object to add splats to
  splats,
  // scale (Gsplat scale along axis)
  scale = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale = 2,
  // origins of the axes (default single axis at origin)
  origins = [new THREE.Vector3()]
}) {
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3();
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  const color2 = new THREE.Color();
  const opacity = 1;
  for (const origin of origins) {
    for (let axis = 0; axis < 3; ++axis) {
      center.set(
        origin.x + (axis === 0 ? scale : 0),
        origin.y + (axis === 1 ? scale : 0),
        origin.z + (axis === 2 ? scale : 0)
      );
      for (let layer = 0; layer < 2; ++layer) {
        scales.set(
          (axis === 0 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),
          (axis === 1 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),
          (axis === 2 ? scale : axisRadius) * (layer ? 1 : axisShadowScale)
        );
        color2.setRGB(
          layer === 0 ? 0 : axis === 0 ? 1 : 0,
          layer === 0 ? 0 : axis === 1 ? 1 : 0,
          layer === 0 ? 0 : axis === 2 ? 1 : 0
        );
        splats.pushSplat(center, scales, quaternion, opacity, color2);
      }
    }
  }
}
function constructSpherePoints({
  // PackedSplats object to add splats to
  splats,
  // center of the sphere (default: origin)
  origin = new THREE.Vector3(),
  // radius of the sphere
  radius = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter = null,
  // radius of each oriented Gsplat
  pointRadius = 0.02,
  // flatness of each oriented Gsplat
  pointThickness = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: color2 = new THREE.Color(1, 1, 1)
}) {
  const pointsHash = {};
  function addPoint(p) {
    if (filter && !filter(p)) {
      return;
    }
    const key = `${p.x},${p.y},${p.z}`;
    if (!pointsHash[key]) {
      pointsHash[key] = p;
    }
  }
  function recurse(depth2, p0, p1, p2) {
    addPoint(p0);
    addPoint(p1);
    addPoint(p2);
    if (depth2 >= maxDepth) {
      return;
    }
    const p01 = new THREE.Vector3().addVectors(p0, p1).normalize();
    const p12 = new THREE.Vector3().addVectors(p1, p2).normalize();
    const p20 = new THREE.Vector3().addVectors(p2, p0).normalize();
    recurse(depth2 + 1, p0, p01, p20);
    recurse(depth2 + 1, p01, p1, p12);
    recurse(depth2 + 1, p20, p12, p2);
    recurse(depth2 + 1, p01, p12, p20);
  }
  for (const x of [-1, 1]) {
    for (const y of [-1, 1]) {
      for (const z of [-1, 1]) {
        const p0 = new THREE.Vector3(x, 0, 0);
        const p1 = new THREE.Vector3(0, y, 0);
        const p2 = new THREE.Vector3(0, 0, z);
        recurse(0, p0, p1, p2);
      }
    }
  }
  const points = Object.values(pointsHash);
  const scales = new THREE.Vector3(pointRadius, pointRadius, pointThickness);
  const quaternion = new THREE.Quaternion();
  const pointColor = typeof color2 === "function" ? new THREE.Color() : color2;
  for (const point of points) {
    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);
    if (typeof color2 === "function") {
      color2(pointColor, point);
    }
    point.multiplyScalar(radius);
    point.add(origin);
    splats.pushSplat(point, scales, quaternion, 1, pointColor);
  }
}
function textSplats({
  // text string to display
  text,
  // browser font to render text with (default: "Arial")
  font,
  // font size in pixels/Gsplats (default: 32)
  fontSize,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: color2,
  // Individual Gsplat color (default: white)
  rgb,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: objectScale2
}) {
  font = font ?? "Arial";
  fontSize = fontSize ?? 32;
  color2 = color2 ?? new THREE.Color(1, 1, 1);
  dotRadius = dotRadius ?? 0.8;
  textAlign = textAlign ?? "start";
  lineHeight = lineHeight ?? 1;
  objectScale2 = objectScale2 ?? 1;
  const lines = text.split("\n");
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Failed to create canvas context");
  }
  ctx.font = `${fontSize}px ${font}`;
  ctx.textAlign = textAlign;
  const metrics = ctx.measureText("");
  const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
  let minLeft = Number.POSITIVE_INFINITY;
  let maxRight = Number.NEGATIVE_INFINITY;
  let minTop = Number.POSITIVE_INFINITY;
  let maxBottom = Number.NEGATIVE_INFINITY;
  for (let line = 0; line < lines.length; ++line) {
    const metrics2 = ctx.measureText(lines[line]);
    const y = fontHeight * lineHeight * line;
    minLeft = Math.min(minLeft, -metrics2.actualBoundingBoxLeft);
    maxRight = Math.max(maxRight, metrics2.actualBoundingBoxRight);
    minTop = Math.min(minTop, y - metrics2.actualBoundingBoxAscent);
    maxBottom = Math.max(maxBottom, y + metrics2.actualBoundingBoxDescent);
  }
  const originLeft = Math.floor(minLeft);
  const originTop = Math.floor(minTop);
  const width = Math.ceil(maxRight) - originLeft;
  const height = Math.ceil(maxBottom) - originTop;
  canvas.width = width;
  canvas.height = height;
  ctx.font = `${fontSize}px ${font}`;
  ctx.textAlign = textAlign;
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = "#FFFFFF";
  for (let i = 0; i < lines.length; ++i) {
    const y = fontHeight * lineHeight * i - originTop;
    ctx.fillText(lines[i], -originLeft, y);
  }
  const imageData = ctx.getImageData(0, 0, width, height);
  const rgba = new Uint8Array(imageData.data.buffer);
  const splats = new PackedSplats();
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3().setScalar(dotRadius * objectScale2);
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  rgb = rgb ?? new THREE.Color(1, 1, 1);
  let offset = 0;
  for (let y = 0; y < height; ++y) {
    for (let x = 0; x < width; ++x) {
      const a = rgba[offset + 3];
      if (a > 0) {
        const opacity = a / 255;
        center.set(x - 0.5 * (width - 1), 0.5 * (height - 1) - y, 0);
        center.multiplyScalar(objectScale2);
        splats.pushSplat(center, scales, quaternion, opacity, rgb);
      }
      offset += 4;
    }
  }
  const mesh = new SplatMesh({ packedSplats: splats });
  mesh.recolor = color2;
  return mesh;
}
function imageSplats({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat
}) {
  dotRadius = dotRadius ?? 0.8;
  subXY = Math.max(1, Math.floor(subXY ?? 1));
  return new SplatMesh({
    constructSplats: async (splats) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onerror = reject;
        img.onload = () => {
          const { width, height } = img;
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            reject(new Error("Failed to create canvas context"));
            return;
          }
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          const destWidth = Math.round(width / subXY);
          const destHeight = Math.round(height / subXY);
          ctx.drawImage(img, 0, 0, destWidth, destHeight);
          try {
            const imageData = ctx.getImageData(0, 0, destWidth, destHeight);
            const rgba = new Uint8Array(imageData.data.buffer);
            const center = new THREE.Vector3();
            const scales = new THREE.Vector3().setScalar(dotRadius);
            const quaternion = new THREE.Quaternion(0, 0, 0, 1);
            const rgb = new THREE.Color();
            let index = 0;
            for (let y = 0; y < destHeight; ++y) {
              for (let x = 0; x < destWidth; ++x) {
                const offset = index * 4;
                const a = rgba[offset + 3];
                if (a > 0) {
                  let opacity = a / 255;
                  rgb.set(
                    rgba[offset + 0] / 255,
                    rgba[offset + 1] / 255,
                    rgba[offset + 2] / 255
                  );
                  center.set(
                    x - 0.5 * (destWidth - 1),
                    0.5 * (destHeight - 1) - y,
                    0
                  );
                  scales.setScalar(dotRadius);
                  quaternion.set(0, 0, 0, 1);
                  let push = true;
                  if (forEachSplat) {
                    const maybeOpacity = forEachSplat(
                      destWidth,
                      destHeight,
                      index,
                      center,
                      scales,
                      quaternion,
                      opacity,
                      rgb
                    );
                    opacity = maybeOpacity ?? opacity;
                    push = maybeOpacity !== null;
                  }
                  if (push) {
                    splats.pushSplat(center, scales, quaternion, opacity, rgb);
                  }
                }
                index += 1;
              }
            }
            resolve();
          } catch (error2) {
            reject(error2);
          }
        };
        img.src = url;
      });
    }
  });
}
function staticBox({
  box,
  cells,
  dotScale,
  color: color2,
  opacity
}) {
  cells.x = Math.max(1, Math.round(cells.x));
  cells.y = Math.max(1, Math.round(cells.y));
  cells.z = Math.max(1, Math.round(cells.z));
  opacity = opacity ?? 1;
  const numSplats = cells.x * cells.y * cells.z;
  const dynoX = dynoConst("int", cells.x);
  const dynoY = dynoConst("int", cells.y);
  dynoConst("int", cells.z);
  const dynoTime = dynoFloat(0);
  const generator = new SplatGenerator({
    numSplats,
    generator: dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index is undefined");
        }
        const cellX = imod(index, dynoX);
        const index2 = div$3(index, dynoX);
        const cellY = imod(index2, dynoY);
        const cellZ = div$3(index2, dynoY);
        const cell = combine({
          vectorType: "ivec3",
          x: cellX,
          y: cellY,
          z: cellZ
        });
        const intTime = floatBitsToInt$1(dynoTime);
        const inputs = combine({ vectorType: "ivec2", x: index, y: intTime });
        const random = hashVec3(inputs);
        const min2 = dynoConst("vec3", box.min);
        const max2 = dynoConst("vec3", box.max);
        const size = sub$4(max2, min2);
        const coord = div$3(add$4(vec3$3(cell), random), dynoConst("vec3", cells));
        let r;
        let g;
        let b;
        if (color2) {
          r = dynoConst("float", color2.r);
          g = dynoConst("float", color2.g);
          b = dynoConst("float", color2.b);
        } else {
          ({ r, g, b } = split$1(coord).outputs);
        }
        const rgba = combine({
          vectorType: "vec4",
          r,
          g,
          b,
          a: dynoConst("float", opacity)
        });
        const center = add$4(min2, mul$4(size, coord));
        const scales = vec3$3(dynoConst("float", dotScale));
        const quaternion = dynoConst("vec4", new THREE.Quaternion(0, 0, 0, 1));
        let gsplat = combineGsplat({
          flags: dynoLiteral("uint", "GSPLAT_FLAG_ACTIVE"),
          index,
          center,
          scales,
          quaternion,
          rgba
        });
        gsplat = transformer.applyGsplat(gsplat);
        return { gsplat };
      },
      {
        globals: () => [defineGsplat]
      }
    ),
    update: ({ time: time2 }) => {
      dynoTime.value = time2;
      transformer.update(generator);
      generator.updateVersion();
    }
  });
  const transformer = new SplatTransformer();
  return generator;
}
const DEFAULT_SNOW = {
  box: new THREE.Box3(
    new THREE.Vector3(-1, -1, -1),
    new THREE.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new THREE.Color(1, 1, 1),
  color2: new THREE.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new THREE.Vector3(1, 1, 1)
};
const DEFAULT_RAIN = {
  box: new THREE.Box3(
    new THREE.Vector3(-2, -1, -2),
    new THREE.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new THREE.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new THREE.Color(1, 1, 1),
  color2: new THREE.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new THREE.Vector3(0.1, 1, 0.1)
};
function snowBox({
  // min and max box extents of the snowBox
  box,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats,
  // density of Gsplats per unit volume (default: 100)
  density,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2,
  // The base opacity of the Gsplats (default: 1)
  opacity,
  // Optional callback function to call each frame.
  onFrame
}) {
  box = box ?? new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
  const volume = (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z - box.min.z);
  density = density ?? 100;
  numSplats = numSplats ?? Math.max(1, Math.min(1e6, Math.round(volume * density)));
  const dynoMinScale = dynoFloat(minScale ?? 1e-3);
  const dynoMaxScale = dynoFloat(maxScale ?? 5e-3);
  const dynoAnisoScale = dynoVec3(
    ((anisoScale == null ? void 0 : anisoScale.clone()) ?? new THREE.Vector3(1, 1, 1)).normalize()
  );
  const dynoFallDirection = dynoVec3(
    (fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize()
  );
  const dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);
  const dynoWanderScale = dynoFloat(wanderScale ?? 0.01);
  const dynoWanderVariance = dynoFloat(wanderVariance ?? 2);
  const dynoColor1 = dynoVec3(color1 ?? new THREE.Color(1, 1, 1));
  const dynoColor2 = dynoVec3(color2 ?? new THREE.Color(0.5, 0.5, 1));
  const dynoOpacity = dynoFloat(opacity ?? 1);
  const dynoTime = dynoFloat(0);
  const globalOffset = dynoVec3(new THREE.Vector3(0, 0, 0));
  const dynoMin = dynoVec3(box.min);
  const dynoMax = dynoVec3(box.max);
  const dynoMinY = dynoFloat(minY ?? Number.NEGATIVE_INFINITY);
  const minMax = sub$4(dynoMax, dynoMin);
  const snow = new SplatGenerator({
    numSplats,
    generator: dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index not defined");
        }
        const random = hashVec4(index);
        const randomW = split$1(random).outputs.w;
        let position = vec3$3(random);
        let size = fract$1(mul$4(randomW, dynoConst("float", 100)));
        size = sin$2(mul$4(dynoLiteral("float", "PI"), size));
        size = add$4(dynoMinScale, mul$4(size, sub$4(dynoMaxScale, dynoMinScale)));
        const scales = mul$4(size, dynoAnisoScale);
        const intensity = fract$1(mul$4(randomW, dynoConst("float", 10)));
        const hue2 = fract$1(randomW);
        const color3 = mix$1(dynoColor1, dynoColor2, hue2);
        const rgb = mul$4(color3, intensity);
        const random2 = hashVec4(
          combine({
            vectorType: "ivec2",
            x: index,
            y: dynoConst("int", 6837)
          })
        );
        let perturb = vec3$3(random2);
        let timeOffset = mul$4(split$1(random2).outputs.w, dynoWanderVariance);
        timeOffset = add$4(dynoTime, timeOffset);
        position = add$4(position, globalOffset);
        const modulo = mod$1(
          position,
          dynoConst("vec3", new THREE.Vector3(1, 1, 1))
        );
        position = add$4(dynoMin, mul$4(minMax, modulo));
        const quaternion = dynoConst("vec4", new THREE.Quaternion(0, 0, 0, 1));
        perturb = sin$2(add$4(vec3$3(timeOffset), perturb));
        perturb = mul$4(perturb, dynoWanderScale);
        let center = add$4(position, perturb);
        let centerY = split$1(center).outputs.y;
        centerY = max$3(dynoMinY, centerY);
        center = combine({ vector: center, y: centerY });
        let gsplat = combineGsplat({
          flags: dynoLiteral("uint", "GSPLAT_FLAG_ACTIVE"),
          index,
          center,
          scales,
          quaternion,
          rgb,
          opacity: dynoOpacity
        });
        gsplat = transformer.applyGsplat(gsplat);
        return { gsplat };
      },
      {
        globals: () => [defineGsplat]
      }
    ),
    update: ({ object, time: time2, deltaTime: deltaTime2 }) => {
      dynoTime.value = time2;
      transformer.update(snow);
      const fallDelta = dynoFallDirection.value.clone().multiplyScalar(dynoFallVelocity.value * deltaTime2);
      globalOffset.value.add(fallDelta);
      object.visible = dynoOpacity.value > 0;
      onFrame == null ? void 0 : onFrame({ object, time: time2, deltaTime: deltaTime2 });
      snow.updateVersion();
    }
  });
  const transformer = new SplatTransformer();
  return {
    snow,
    min: dynoMin,
    max: dynoMax,
    minY: dynoMinY,
    color1: dynoColor1,
    color2: dynoColor2,
    opacity: dynoOpacity,
    fallVelocity: dynoFallVelocity,
    wanderVariance: dynoWanderVariance,
    wanderScale: dynoWanderScale,
    fallDirection: dynoFallDirection,
    minScale: dynoMinScale,
    maxScale: dynoMaxScale,
    anisoScale: dynoAnisoScale
  };
}
const generators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN,
  DEFAULT_SNOW,
  snowBox,
  staticBox
}, Symbol.toStringTag, { value: "Module" }));
function makeNormalColorModifier(splatToView) {
  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {
    if (!gsplat) {
      throw new Error("No gsplat input");
    }
    let normal2 = gsplatNormal(gsplat);
    const viewGsplat = splatToView.applyGsplat(gsplat);
    const viewCenter = splitGsplat(viewGsplat).outputs.center;
    const viewNormal = gsplatNormal(viewGsplat);
    const splatDot = dot$4(viewCenter, viewNormal);
    const sameDir = greaterThanEqual$1(splatDot, dynoConst("float", 0));
    normal2 = select$4(sameDir, neg(normal2), normal2);
    const rgb = add$4(
      mul$4(normal2, dynoConst("float", 0.5)),
      dynoConst("float", 0.5)
    );
    gsplat = combineGsplat({ gsplat, rgb });
    return { gsplat };
  });
}
function setWorldNormalColor(splats) {
  splats.enableWorldToView = true;
  splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);
  splats.updateGenerator();
}
function makeDepthColorModifier(splatToView, minDepth, maxDepth, reverse) {
  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {
    if (!gsplat) {
      throw new Error("No gsplat input");
    }
    let { center } = splitGsplat(gsplat).outputs;
    center = splatToView.apply(center);
    const { z } = split$1(center).outputs;
    let depth2 = normalizedDepth(neg(z), minDepth, maxDepth);
    depth2 = select$4(reverse, sub$4(dynoConst("float", 1), depth2), depth2);
    gsplat = combineGsplat({ gsplat, r: depth2, g: depth2, b: depth2 });
    return { gsplat };
  });
}
function setDepthColor(splats, minDepth, maxDepth, reverse) {
  splats.enableWorldToView = true;
  const dynoMinDepth = dynoConst("float", minDepth);
  const dynoMaxDepth = dynoConst("float", maxDepth);
  const dynoReverse = dynoConst("bool", reverse ?? false);
  splats.worldModifier = makeDepthColorModifier(
    splats.context.worldToView,
    dynoMinDepth,
    dynoMaxDepth,
    dynoReverse
  );
  splats.updateGenerator();
  return {
    minDepth: dynoMinDepth,
    maxDepth: dynoMaxDepth,
    reverse: dynoReverse
  };
}
const modifiers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier,
  makeNormalColorModifier,
  setDepthColor,
  setWorldNormalColor
}, Symbol.toStringTag, { value: "Module" }));
const _VRButton = class _VRButton {
  static createButton(renderer, sessionInit = {}) {
    const navigatorXr = navigator.xr;
    if (!navigatorXr) {
      return null;
    }
    const xr = navigatorXr;
    const button = document.createElement("button");
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType("local");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        console.log("onSessionStarted");
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        console.log("onSessionEnded");
        currentSession == null ? void 0 : currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 100px)";
      button.style.width = "200px";
      button.style.height = "100px";
      button.textContent = "ENTER VR";
      const sessionOptions = {
        ...sessionInit,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...sessionInit.optionalFeatures || []
        ]
      };
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          console.log("requesting session");
          xr.requestSession("immersive-vr", sessionOptions).then(
            onSessionStarted
          );
        } else {
          console.log("ending session");
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "none";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function showVRNotAllowed(exception) {
      disableButton();
      console.warn(
        "Exception when trying to call xr.isSessionSupported",
        exception
      );
      button.textContent = "VR NOT ALLOWED";
    }
    function stylizeElement(element2) {
      element2.style.position = "absolute";
      element2.style.bottom = "20px";
      element2.style.padding = "12px 6px";
      element2.style.border = "1px solid #fff";
      element2.style.borderRadius = "4px";
      element2.style.background = "rgba(0,0,0,0.1)";
      element2.style.color = "#fff";
      element2.style.font = "normal 13px sans-serif";
      element2.style.textAlign = "center";
      element2.style.opacity = "0.5";
      element2.style.outline = "none";
      element2.style.zIndex = "999";
    }
    button.id = "VRButton";
    button.style.display = "none";
    stylizeElement(button);
    xr.isSessionSupported("immersive-vr").then((supported) => {
      supported ? showEnterVR() : showWebXRNotFound();
      if (supported && _VRButton.xrSessionIsGranted) {
        button.click();
      }
    }).catch(showVRNotAllowed);
    return button;
  }
  static registerSessionGrantedListener() {
    const navigatorXr = navigator.xr;
    if (!navigatorXr) {
      return null;
    }
    const xr = navigatorXr;
    if (/WebXRViewer\//i.test(navigator.userAgent)) return;
    xr.addEventListener("sessiongranted", () => {
      _VRButton.xrSessionIsGranted = true;
    });
  }
};
_VRButton.xrSessionIsGranted = false;
let VRButton = _VRButton;
VRButton.registerSessionGrantedListener();
const DEFAULT_MOVE_INERTIA$1 = 0.5;
const DEFAULT_ROTATE_INERTIA$1 = 0.5;
const TOUCH_BIAS = 0;
var JointEnum = /* @__PURE__ */ ((JointEnum2) => {
  JointEnum2["w"] = "wrist";
  JointEnum2["t0"] = "thumb-metacarpal";
  JointEnum2["t1"] = "thumb-phalanx-proximal";
  JointEnum2["t2"] = "thumb-phalanx-distal";
  JointEnum2["t3"] = "thumb-tip";
  JointEnum2["i0"] = "index-finger-metacarpal";
  JointEnum2["i1"] = "index-finger-phalanx-proximal";
  JointEnum2["i2"] = "index-finger-phalanx-intermediate";
  JointEnum2["i3"] = "index-finger-phalanx-distal";
  JointEnum2["i4"] = "index-finger-tip";
  JointEnum2["m0"] = "middle-finger-metacarpal";
  JointEnum2["m1"] = "middle-finger-phalanx-proximal";
  JointEnum2["m2"] = "middle-finger-phalanx-intermediate";
  JointEnum2["m3"] = "middle-finger-phalanx-distal";
  JointEnum2["m4"] = "middle-finger-tip";
  JointEnum2["r0"] = "ring-finger-metacarpal";
  JointEnum2["r1"] = "ring-finger-phalanx-proximal";
  JointEnum2["r2"] = "ring-finger-phalanx-intermediate";
  JointEnum2["r3"] = "ring-finger-phalanx-distal";
  JointEnum2["r4"] = "ring-finger-tip";
  JointEnum2["p0"] = "pinky-finger-metacarpal";
  JointEnum2["p1"] = "pinky-finger-phalanx-proximal";
  JointEnum2["p2"] = "pinky-finger-phalanx-intermediate";
  JointEnum2["p3"] = "pinky-finger-phalanx-distal";
  JointEnum2["p4"] = "pinky-finger-tip";
  return JointEnum2;
})(JointEnum || {});
const JOINT_IDS = Object.keys(JointEnum);
const NUM_JOINTS = JOINT_IDS.length;
const JOINT_INDEX = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
};
const JOINT_RADIUS = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
};
const JOINT_SEGMENTS = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
];
const JOINT_SEGMENT_STEPS = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
];
const JOINT_TIPS = ["t3", "i4", "m4", "r4", "p4"];
const FINGER_TIPS = ["i4", "m4", "r4", "p4"];
var Hand = /* @__PURE__ */ ((Hand2) => {
  Hand2["left"] = "left";
  Hand2["right"] = "right";
  return Hand2;
})(Hand || {});
const HANDS = Object.keys(Hand);
class XrHands {
  constructor() {
    this.hands = {};
    this.last = {};
    this.values = {};
    this.tests = {};
    this.lastTests = {};
    this.updated = false;
  }
  update({ xr, xrFrame }) {
    const xrSession = xr.getSession();
    if (!xrSession) {
      return;
    }
    const referenceSpace = xr.getReferenceSpace();
    if (!referenceSpace) {
      return;
    }
    if (!xrFrame.getJointPose) {
      return;
    }
    this.last = this.hands;
    this.lastTests = this.tests;
    this.hands = {};
    this.values = {};
    this.tests = {};
    for (const inputSource of xrSession.inputSources) {
      if (!inputSource.hand) {
        continue;
      }
      const hand = inputSource.handedness;
      this.hands[hand] = {};
      for (const jointId of JOINT_IDS) {
        const jointSpace = inputSource.hand.get(JointEnum[jointId]);
        if (jointSpace) {
          const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);
          if (jointPose) {
            const { position, orientation } = jointPose.transform;
            this.hands[hand][jointId] = {
              position: new Vector3$1(position.x, position.y, position.z),
              quaternion: new Quaternion$1(
                orientation.x,
                orientation.y,
                orientation.z,
                orientation.w
              ),
              radius: jointPose.radius || 1e-3
            };
          }
        }
      }
    }
    for (const hand of HANDS) {
      for (const { key, value } of [
        { key: `${hand}AllTips`, value: this.allTipsTouching(hand) },
        {
          key: `${hand}IndexThumb`,
          value: this.touching(hand, "i4", hand, "t3")
        },
        {
          key: `${hand}MiddleThumb`,
          value: this.touching(hand, "m4", hand, "t3")
        },
        {
          key: `${hand}RingThumb`,
          value: this.touching(hand, "r4", hand, "t3")
        },
        {
          key: `${hand}PinkyThumb`,
          value: this.touching(hand, "p4", hand, "t3")
        },
        { key: `${hand}TriTips`, value: this.triTipsTouching(hand) }
      ]) {
        this.values[key] = value;
        this.tests[key] = value === 1 ? true : value === 0 ? false : this.lastTests[key] ?? false;
      }
    }
  }
  makeGhostMesh() {
    const center = new Vector3$1();
    const scales = new Vector3$1(0.01, 0.01, 0.01);
    const quaternion = new Quaternion$1(0, 0, 0, 1);
    const color2 = new Color$1(1, 1, 1);
    const CYCLE = Math.PI * 3;
    new Color$1(1, 1, 1);
    let opacity = 1;
    const mesh = new SplatMesh({
      onFrame: () => {
        let splatIndex = 0;
        for (const handedness of HANDS) {
          const xrHand = this.hands[handedness];
          for (const [index, segment] of JOINT_SEGMENTS.entries()) {
            for (let i = 1; i < segment.length; ++i) {
              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] * 2;
              const lastSegment = i + 1 === segment.length;
              const jointA = xrHand == null ? void 0 : xrHand[segment[i - 1]];
              const jointB = xrHand == null ? void 0 : xrHand[segment[i]];
              for (let j = 0; j < segmentSplats; ++j) {
                const t = (j + 0.5) / segmentSplats;
                opacity = 0;
                if (jointA && jointB) {
                  center.copy(jointA.position).lerp(jointB.position, t);
                  quaternion.copy(jointA.quaternion).slerp(jointB.quaternion, t);
                  const radiusA = JOINT_RADIUS[segment[i - 1]];
                  const radiusB = JOINT_RADIUS[segment[i]];
                  let radius = (1 - t) * radiusA + t * radiusB;
                  if (lastSegment && t > 0.8) {
                    radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);
                  }
                  scales.set(0.65 * radius, 0.5 * radius, 3e-3);
                  color2.set(
                    0.55 + 0.45 * Math.sin(center.x * CYCLE),
                    0.55 + 0.45 * Math.sin(center.y * CYCLE),
                    0.55 + 0.45 * Math.sin(center.z * CYCLE)
                  );
                  if (handedness === "right") {
                    color2.set(1 - color2.r, 1 - color2.g, 1 - color2.b);
                  }
                  opacity = 0.75;
                }
                mesh.packedSplats.setSplat(
                  splatIndex,
                  center,
                  scales,
                  quaternion,
                  opacity,
                  color2
                );
                splatIndex += 1;
              }
            }
          }
        }
        mesh.packedSplats.numSplats = splatIndex;
        mesh.packedSplats.needsUpdate = true;
        mesh.numSplats = splatIndex;
        mesh.updateVersion();
      }
    });
    return mesh;
  }
  distance(handA, jointA, handB, jointB, last = false) {
    const hA = last ? this.last[handA] : this.hands[handA];
    const hB = last ? this.last[handB] : this.hands[handB];
    const jA = hA == null ? void 0 : hA[jointA];
    const jB = hB == null ? void 0 : hB[jointB];
    if (!jA || !jB) {
      return Number.POSITIVE_INFINITY;
    }
    return jA.position.distanceTo(jB.position);
  }
  separation(handA, jointA, handB, jointB, last = false) {
    const d = this.distance(handA, jointA, handB, jointB, last);
    if (d === Number.POSITIVE_INFINITY) {
      return Number.POSITIVE_INFINITY;
    }
    return d - JOINT_RADIUS[jointA] - JOINT_RADIUS[jointB];
  }
  touching(handA, jointA, handB, jointB, last = false) {
    const d = this.separation(handA, jointA, handB, jointB, last);
    if (d === Number.POSITIVE_INFINITY) {
      return Number.POSITIVE_INFINITY;
    }
    return 1 - Math.max(0, Math.min(1, d / 0.01 - TOUCH_BIAS));
  }
  allTipsTouching(hand, last = false) {
    return Math.min(
      this.touching(hand, "t3", hand, "i4", last),
      this.touching(hand, "i4", hand, "m4", last),
      this.touching(hand, "m4", hand, "r4", last),
      this.touching(hand, "r4", hand, "p4", last)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(hand, last = false) {
    return Math.min(
      this.touching(hand, "t3", hand, "i4", last),
      this.touching(hand, "i4", hand, "m4", last),
      this.touching(hand, "m4", hand, "t3", last)
    );
  }
}
class HandMovement {
  constructor({
    xrHands,
    control,
    moveInertia,
    rotateInertia
  }) {
    this.lastGrip = {};
    this.lastPivot = new Vector3$1();
    this.rotateVelocity = 0;
    this.velocity = new Vector3$1();
    this.xrHands = xrHands;
    this.control = control;
    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA$1;
    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA$1;
  }
  update(deltaTime2) {
    var _a2, _b2, _c, _d, _e;
    const grip = {};
    for (const handedness of HANDS) {
      const hand = this.xrHands.hands[handedness];
      if (hand && this.xrHands.tests[`${handedness}MiddleThumb`]) {
        grip[handedness] = new Vector3$1().add(((_a2 = hand.t3) == null ? void 0 : _a2.position) ?? new Vector3$1()).add(((_b2 = hand.i4) == null ? void 0 : _b2.position) ?? new Vector3$1()).add(((_c = hand.m4) == null ? void 0 : _c.position) ?? new Vector3$1()).add(((_d = hand.r4) == null ? void 0 : _d.position) ?? new Vector3$1()).add(((_e = hand.p4) == null ? void 0 : _e.position) ?? new Vector3$1()).multiplyScalar(1 / 5);
      }
    }
    if (grip.left && grip.right && this.lastGrip.left && this.lastGrip.right) {
      const mid = grip.left.clone().add(grip.right).multiplyScalar(0.5);
      const lastMid = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = mid;
      const delta = mid.clone().applyMatrix4(this.control.matrix);
      delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));
      delta.multiplyScalar(1 / deltaTime2);
      this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime2));
      const angle = Math.atan2(grip.left.z - mid.z, grip.left.x - mid.x);
      const lastAngle = Math.atan2(
        this.lastGrip.left.z - lastMid.z,
        this.lastGrip.left.x - lastMid.x
      );
      let closestAngle = angle - lastAngle;
      if (closestAngle > Math.PI) {
        closestAngle -= Math.PI * 2;
      } else if (closestAngle < -Math.PI) {
        closestAngle += Math.PI * 2;
      }
      const rotateVelocity = closestAngle / deltaTime2;
      const blend = Math.exp(-20 * deltaTime2);
      this.rotateVelocity = this.rotateVelocity * blend + rotateVelocity * (1 - blend);
    } else {
      this.rotateVelocity *= Math.exp(-deltaTime2 / this.rotateInertia);
      if (grip.left && this.lastGrip.left) {
        const delta = grip.left.clone().applyMatrix4(this.control.matrix);
        delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));
        delta.multiplyScalar(1 / deltaTime2);
        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime2));
      } else if (grip.right && this.lastGrip.right) {
        const delta = grip.right.clone().applyMatrix4(this.control.matrix);
        delta.sub(
          this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
        );
        delta.multiplyScalar(1 / deltaTime2);
        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime2));
      } else {
        this.velocity.multiplyScalar(Math.exp(-deltaTime2 / this.moveInertia));
      }
    }
    const negPivot = this.lastPivot.clone().negate();
    const rotate2 = new Matrix4$1().makeTranslation(negPivot).premultiply(new Matrix4$1().makeRotationY(this.rotateVelocity * deltaTime2)).premultiply(new Matrix4$1().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(rotate2);
    this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    );
    this.control.updateMatrixWorld(true);
    this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime2));
    this.lastGrip = grip;
  }
}
const DEFAULT_MOVEMENT_SPEED = 1;
const DEFAULT_ROLL_SPEED = 2;
const DEFAULT_ROTATE_SPEED = 2e-3;
const DEFAULT_SLIDE_SPEED = 6e-3;
const DEFAULT_SCROLL_SPEED = 15e-4;
const DEFAULT_ROTATE_INERTIA = 0.15;
const DEFAULT_MOVE_INERTIA = 0.15;
const DEFAULT_STICK_THRESHOLD = 0.1;
const DEFAULT_FPS_ROTATE_SPEED = 2;
const DEFAULT_POINTER_ROLL_SCALE = 1;
const DUAL_PRESS_MS = 200;
const DOUBLE_PRESS_LIMIT_MS = 400;
const DOUBLE_PRESS_DISTANCE = 50;
const WASD_KEYCODE_MOVE = {
  KeyW: new THREE.Vector3(0, 0, -1),
  KeyS: new THREE.Vector3(0, 0, 1),
  KeyA: new THREE.Vector3(-1, 0, 0),
  KeyD: new THREE.Vector3(1, 0, 0),
  KeyR: new THREE.Vector3(0, 1, 0),
  KeyF: new THREE.Vector3(0, -1, 0)
};
const ARROW_KEYCODE_MOVE = {
  ArrowUp: new THREE.Vector3(0, 0, -1),
  ArrowDown: new THREE.Vector3(0, 0, 1),
  ArrowLeft: new THREE.Vector3(-1, 0, 0),
  ArrowRight: new THREE.Vector3(1, 0, 0),
  PageUp: new THREE.Vector3(0, 1, 0),
  PageDown: new THREE.Vector3(0, -1, 0)
};
const QE_KEYCODE_ROTATE = {
  KeyQ: new THREE.Vector3(0, 0, 1),
  KeyE: new THREE.Vector3(0, 0, -1)
};
const ARROW_KEYCODE_ROTATE = {
  Home: new THREE.Vector3(0, -1, 0),
  End: new THREE.Vector3(0, 1, 0),
  Insert: new THREE.Vector3(-1, 0, 0),
  Delete: new THREE.Vector3(1, 0, 0)
};
class SparkControls {
  constructor({ canvas }) {
    this.lastTime = 0;
    this.fpsMovement = new FpsMovement({});
    this.pointerControls = new PointerControls({ canvas });
  }
  update(control) {
    const time2 = performance.now();
    const deltaTime2 = (time2 - (this.lastTime || time2)) / 1e3;
    this.lastTime = time2;
    this.fpsMovement.update(deltaTime2, control);
    this.pointerControls.update(deltaTime2, control);
  }
}
class FpsMovement {
  constructor({
    moveSpeed,
    rollSpeed,
    stickThreshold,
    rotateSpeed,
    keycodeMoveMapping,
    keycodeRotateMapping,
    gamepadMapping,
    capsMultiplier,
    shiftMultiplier,
    ctrlMultiplier,
    xr
  } = {}) {
    this.enable = true;
    this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;
    this.rollSpeed = rollSpeed ?? DEFAULT_ROLL_SPEED;
    this.stickThreshold = stickThreshold ?? DEFAULT_STICK_THRESHOLD;
    this.rotateSpeed = rotateSpeed ?? DEFAULT_FPS_ROTATE_SPEED;
    this.keycodeMoveMapping = keycodeMoveMapping ?? {
      ...WASD_KEYCODE_MOVE,
      ...ARROW_KEYCODE_MOVE
    };
    this.keycodeRotateMapping = keycodeRotateMapping ?? {
      ...QE_KEYCODE_ROTATE,
      ...ARROW_KEYCODE_ROTATE
    };
    this.gamepadMapping = gamepadMapping ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    };
    this.capsMultiplier = capsMultiplier ?? 10;
    this.shiftMultiplier = shiftMultiplier ?? 5;
    this.ctrlMultiplier = ctrlMultiplier ?? 1 / 5;
    this.xr = xr;
    this.keydown = {};
    this.keycode = {};
    document.addEventListener("keydown", (event) => {
      this.keydown[event.key] = true;
      this.keycode[event.code] = true;
    });
    document.addEventListener("keyup", (event) => {
      this.keydown[event.key] = false;
      this.keycode[event.code] = false;
    });
    window.addEventListener("blur", () => {
      this.keydown = {};
      this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(deltaTime2, control) {
    var _a2, _b2;
    if (!this.enable) {
      return;
    }
    const sticks = [new THREE.Vector2(), new THREE.Vector2()];
    const gamepad = navigator.getGamepads()[0];
    if (gamepad) {
      sticks[0].set(gamepad.axes[0], gamepad.axes[1]);
      sticks[1].set(gamepad.axes[2], gamepad.axes[3]);
    }
    const gamepadButtons = (gamepad == null ? void 0 : gamepad.buttons.map((button) => button.pressed)) || [];
    const xrSources = Array.from(((_b2 = (_a2 = this.xr) == null ? void 0 : _a2.getSession()) == null ? void 0 : _b2.inputSources) ?? []);
    for (const source of xrSources) {
      const gamepad2 = source.gamepad;
      if (gamepad2) {
        switch (source.handedness) {
          case "none": {
            sticks[0].x += gamepad2.axes[0];
            sticks[0].y += gamepad2.axes[1];
            sticks[1].x += gamepad2.axes[2];
            sticks[1].y += gamepad2.axes[3];
            break;
          }
          case "left": {
            sticks[0].x += gamepad2.axes[2];
            sticks[0].y += gamepad2.axes[3];
            break;
          }
          case "right": {
            sticks[1].x += gamepad2.axes[2];
            sticks[1].y += gamepad2.axes[3];
            break;
          }
        }
      }
    }
    for (const stick of sticks) {
      stick.x = Math.abs(stick.x) >= this.stickThreshold ? stick.x : 0;
      stick.y = Math.abs(stick.y) >= this.stickThreshold ? stick.y : 0;
    }
    const rotate2 = new THREE.Vector3(
      sticks[1].x,
      sticks[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [keycode, rot] of Object.entries(this.keycodeRotateMapping)) {
      if (this.keycode[keycode]) {
        rotate2.add(rot);
      }
    }
    for (const button in this.gamepadMapping) {
      if (gamepadButtons[Number.parseInt(button)]) {
        switch (this.gamepadMapping[button]) {
          case "rollLeft":
            rotate2.z += 1;
            break;
          case "rollRight":
            rotate2.z -= 1;
            break;
        }
      }
    }
    rotate2.multiply(
      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    );
    if (rotate2.manhattanLength() > 0) {
      rotate2.multiplyScalar(deltaTime2);
      const eulers = new THREE.Euler().setFromQuaternion(
        control.quaternion,
        "YXZ"
      );
      eulers.y -= rotate2.x;
      eulers.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, eulers.x - rotate2.y)
      );
      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + rotate2.z));
      control.quaternion.setFromEuler(eulers);
    }
    const moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);
    for (const [keycode, move] of Object.entries(this.keycodeMoveMapping)) {
      if (this.keycode[keycode]) {
        moveVector.add(move);
      }
    }
    let speedMultiplier = 1;
    if (this.keydown.CapsLock) {
      speedMultiplier *= this.capsMultiplier;
    }
    if (this.keycode.ShiftLeft || this.keycode.ShiftRight) {
      speedMultiplier *= this.shiftMultiplier;
    }
    if (this.keycode.ControlLeft || this.keycode.ControlRight) {
      speedMultiplier *= this.ctrlMultiplier;
    }
    for (const button in this.gamepadMapping) {
      if (gamepadButtons[Number.parseInt(button)]) {
        switch (this.gamepadMapping[button]) {
          case "shift":
            speedMultiplier *= this.shiftMultiplier;
            break;
          case "ctrl":
            speedMultiplier *= this.ctrlMultiplier;
            break;
        }
      }
    }
    moveVector.applyQuaternion(control.quaternion);
    control.position.add(
      moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime2)
    );
  }
}
class PointerControls {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide,
    // Reverse the direction of rotation (default: false)
    reverseRotate,
    // Reverse the direction of sliding (default: false)
    reverseSlide,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale,
    // Callback for double press events (default: () => {})
    doublePress
  }) {
    this.enable = true;
    this.canvas = canvas;
    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;
    this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;
    this.scrollSpeed = scrollSpeed ?? DEFAULT_SCROLL_SPEED;
    this.swapRotateSlide = swapRotateSlide ?? false;
    this.reverseRotate = reverseRotate ?? false;
    this.reverseSlide = reverseSlide ?? false;
    this.reverseSwipe = reverseSwipe ?? false;
    this.reverseScroll = reverseScroll ?? false;
    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;
    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;
    this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;
    this.doublePress = doublePress ?? (() => {
    });
    this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;
    this.doublePressDistance = DOUBLE_PRESS_DISTANCE;
    this.lastUp = null;
    this.rotating = null;
    this.sliding = null;
    this.dualPress = false;
    this.scroll = new THREE.Vector3();
    this.rotateVelocity = new THREE.Vector3();
    this.moveVelocity = new THREE.Vector3();
    canvas.addEventListener("pointerdown", (event) => {
      const position = this.getPointerPosition(event);
      const initial = position.clone();
      const last = position.clone();
      const isRotate = !this.swapRotateSlide && !this.rotating && (event.pointerType !== "mouse" || event.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (event.pointerType !== "mouse" || event.button === 1);
      const { pointerId, timeStamp } = event;
      if (isRotate) {
        this.rotating = { initial, last, position, pointerId, timeStamp };
        canvas.setPointerCapture(event.pointerId);
        this.dualPress = false;
      } else if (!this.sliding) {
        const button = event.pointerType === "mouse" ? event.button : void 0;
        this.sliding = {
          initial,
          last,
          position,
          pointerId,
          button,
          timeStamp
        };
        canvas.setPointerCapture(event.pointerId);
        this.dualPress = this.rotating != null && timeStamp - this.rotating.timeStamp < DUAL_PRESS_MS;
      }
    });
    const pointerUp = (event) => {
      var _a2, _b2;
      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {
        this.rotating = null;
        canvas.releasePointerCapture(event.pointerId);
        if (this.dualPress && this.sliding) {
          canvas.releasePointerCapture(this.sliding.pointerId);
          this.sliding = null;
        }
      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {
        this.sliding = null;
        canvas.releasePointerCapture(event.pointerId);
        if (this.dualPress && this.rotating) {
          canvas.releasePointerCapture(this.rotating.pointerId);
          this.rotating = null;
        }
      }
      const position = this.getPointerPosition(event);
      const lastUp = this.lastUp;
      this.lastUp = { position, time: event.timeStamp };
      if (lastUp) {
        const distance2 = lastUp.position.distanceTo(position);
        if (distance2 < this.doublePressDistance) {
          const intervalMs = event.timeStamp - lastUp.time;
          if (intervalMs < this.doublePressLimitMs) {
            this.lastUp = null;
            this.doublePress({ position, intervalMs });
          }
        }
      }
    };
    document.addEventListener("pointerup", pointerUp);
    document.addEventListener("pointercancel", pointerUp);
    document.addEventListener("pointermove", (event) => {
      var _a2, _b2;
      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {
        this.rotating.position = this.getPointerPosition(event);
      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {
        this.sliding.position = this.getPointerPosition(event);
      }
    });
    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });
    canvas.addEventListener("wheel", (event) => {
      this.scroll.add(
        new THREE.Vector3(event.deltaX, event.deltaY, event.deltaZ)
      );
      event.preventDefault();
    });
  }
  getPointerPosition(event) {
    const rect = this.canvas.getBoundingClientRect();
    return new THREE.Vector2(
      event.clientX - rect.left,
      event.clientY - rect.top
    );
  }
  update(deltaTime2, control) {
    if (!this.enable) {
      return;
    }
    if (this.dualPress && this.rotating && this.sliding) {
      const motion = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ];
      const coincidence = motion[0].dot(motion[1]);
      if (coincidence >= 0.2) {
        const totalMotion = motion[0].clone().add(motion[1]);
        const slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);
        slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));
        slide.applyQuaternion(control.quaternion);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime2);
      } else if (coincidence <= -0.2) {
        const deltaDir = this.sliding.last.clone().sub(this.rotating.last);
        const deltaDist = deltaDir.length();
        deltaDir.multiplyScalar(1 / deltaDist).normalize();
        const orthoDir = new THREE.Vector2(-deltaDir.y, deltaDir.x);
        const motionDir = [motion[0].dot(deltaDir), motion[1].dot(deltaDir)];
        const motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];
        const midpoint = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let midpointDir = new THREE.Vector3();
        if (control instanceof THREE.Camera) {
          const ndcMidpoint = new THREE.Vector2(
            midpoint.x / this.canvas.clientWidth * 2 - 1,
            -(midpoint.y / this.canvas.clientHeight) * 2 + 1
          );
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(ndcMidpoint, control);
          midpointDir = raycaster.ray.direction;
        }
        const pinchOut = motionDir[1] - motionDir[0];
        const slide = midpointDir.multiplyScalar(pinchOut * this.slideSpeed);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime2);
        const angles = [
          Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),
          Math.atan(motionOrtho[1] / (0.5 * deltaDist))
        ];
        const rotate2 = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;
        const eulers = new THREE.Euler().setFromQuaternion(
          control.quaternion,
          "YXZ"
        );
        eulers.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, eulers.z + 0.5 * rotate2)
        );
        control.quaternion.setFromEuler(eulers);
      }
      this.rotating.last.copy(this.rotating.position);
      this.sliding.last.copy(this.sliding.position);
    } else {
      const rotate2 = new THREE.Vector3();
      if (this.rotating && !this.dualPress) {
        const delta = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position);
        rotate2.set(delta.x, delta.y, 0);
        rotate2.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1));
        this.rotateVelocity = rotate2.clone().multiplyScalar(1 / deltaTime2);
      } else {
        this.rotateVelocity.multiplyScalar(
          Math.exp(-deltaTime2 / this.rotateInertia)
        );
        rotate2.addScaledVector(this.rotateVelocity, deltaTime2);
      }
      const eulers = new THREE.Euler().setFromQuaternion(
        control.quaternion,
        "YXZ"
      );
      eulers.y -= rotate2.x;
      eulers.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, eulers.x - rotate2.y)
      );
      eulers.z *= Math.exp(-0 * deltaTime2);
      control.quaternion.setFromEuler(eulers);
      if (this.sliding && !this.dualPress) {
        const delta = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const slide = this.sliding.button !== 2 ? new THREE.Vector3(delta.x, 0, delta.y) : new THREE.Vector3(delta.x, -delta.y, 0);
        slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));
        slide.applyQuaternion(control.quaternion);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime2);
      } else {
        this.moveVelocity.multiplyScalar(
          Math.exp(-deltaTime2 / this.moveInertia)
        );
        control.position.addScaledVector(this.moveVelocity, deltaTime2);
      }
    }
    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);
    scroll.set(scroll.x, scroll.z, scroll.y);
    if (this.reverseScroll) {
      scroll.multiplyScalar(-1);
    }
    scroll.applyQuaternion(control.quaternion);
    control.position.add(scroll);
    this.scroll.set(0, 0, 0);
  }
}
export {
  FINGER_TIPS,
  FpsMovement,
  HANDS,
  Hand,
  HandMovement,
  JOINT_IDS,
  JOINT_INDEX,
  JOINT_RADIUS,
  JOINT_SEGMENTS,
  JOINT_SEGMENT_STEPS,
  JOINT_TIPS,
  JointEnum,
  LN_SCALE_MAX,
  LN_SCALE_MIN,
  NUM_JOINTS,
  PackedSplats,
  PlyReader,
  PointerControls,
  Readback,
  RgbaArray,
  Sint8ToFloat,
  SparkControls,
  SparkRenderer,
  SparkViewpoint,
  SplatAccumulator,
  SplatEdit,
  SplatEditRgbaBlendMode,
  SplatEditSdf,
  SplatEditSdfType,
  SplatEdits,
  SplatFileType,
  SplatGenerator,
  SplatLoader,
  SplatMesh,
  SplatModifier,
  SplatSkinning,
  SplatTransformer,
  SpzReader,
  SpzWriter,
  Uint8ToFloat,
  VRButton,
  XrHands,
  constructAxes,
  constructGrid,
  constructSpherePoints,
  defines,
  dyno,
  flipPixels,
  floatToSint8,
  floatToUint8,
  fromHalf,
  generators,
  getSplatFileType,
  imageSplats,
  isAndroid,
  isMobile,
  isOculus,
  isPcSogs,
  modifiers,
  pixelsToPngUrl,
  readRgbaArray,
  setPackedSplat,
  textSplats,
  toHalf,
  transcodeSpz,
  unpackSplat,
  unpackSplats,
  utils
};
//# sourceMappingURL=spark.module.js.map
